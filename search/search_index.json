{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante. Pr\u00e1ctica 1 Enunciado de la pr\u00e1ctica Introducci\u00f3n a Spring Boot Resumen de comandos Git Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Pr\u00e1ctica 5 Construido con MkDocs \u00b6 Versi\u00f3n HTML compilada usando el tema Material de MkDocs . Repositorio en GitHub .","title":"Index"},{"location":"01-intro-spring-boot/comandos-git.html","text":"Resumen de comandos Git \u00b6 Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi). 1. Comandos b\u00e1sicos \u00b6 Configurar el usuario y direcci\u00f3n de correo en git: $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Inicializar git en un directorio: $ cd /ruta/a/mi/directorio $ git config --global user.name <nombre-usuario> $ git config --global user.email <email> $ git init $ git add . $ git commit -m \"Versi\u00f3n inicial\" Publicar por primera vez el repositorio local en el remoto (en GitHub): $ git remote add origin <url-repo>.git $ git push -u origin main El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama main (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): $ git add <fichero o directorio> El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : $ git commit -m \"Mensaje\" Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): $ git reset HEAD <fichero> Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: $ git commit -a -m \"Mensaje\" Se puede abreviar como $ git commit -am \"Mensaje\"` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: $ git reset --hard HEAD $ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero) Publicar los cambios en el repositorio remoto: $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). $ git log [--oneline] [--graph] [--all] Comprobar las diferencias entre dos commits: $ git diff <hash-previo> <hash-nuevo> Devuelve las cambios que se han introducido desde el commit identificado por y hasta el . 2. Ramas \u00b6 Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: $ git checkout -b nueva-rama M hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama) Switched to a new branch 'nueva-rama' Listar todas las ramas de un repositorio (incluyendo ramas remotas) $ git branch -av main * nueva-rama $ git commit -a -m \"Confirmamos los cambios en la nueva rama\" Moverse a otra rama: $ git checkout main Switched to branch 'main' Mostrar un fichero de una rama (o commit) dado: $ git show <commit o rama>:<nombre-fichero> Comparar dos ramas: $ git diff main nueva-rama El comando git diff main nueva-rama devuelve las diferencias entre las ramas main y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama main . Merge de ramas : Mezclar la rama nueva-rama en la rama main (a\u00f1ade a la main los commits adicionales de la rama nueva-rama ): $ git checkout main $ git merge [--no-ff] nueva-rama -m \"Mensaje de commit\" La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. $ git merge nueva-rama CONFLICT (content): Merge conflict in hola.txt Automatic merge failed; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m \"Arreglado el conflicto en el merge\" $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama main ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : $ git checkout -b experiment # hacemos cambios $ git commit -m \"Cambios en experiment\" $ git checkout main # hacemos cambios $ git commit -a -m \"Cambios en main\" $ git checkout experiment $ git rebase main First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama main ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. \u00a1Cuidado! No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama main y tener una historia lineal: $ git checkout main $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : $ git rebase main CONFLICT (content): Merge conflict in <some-file> # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use \"git reset HEAD <some-file>...\" to unstage) # (use \"git add/rm <some-file>...\" as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add <some-file> $ git rebase --continue Nota Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: $ git log --graph --oneline Borrar una rama: $ git branch -d nueva-rama Deleted branch nueva-rama (was c241d7b) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: $ git branch -D rama Subir una rama al repositorio remoto: $ git push -u origin <rama> Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) $ git fetch $ git checkout -b <rama> origin/<rama> Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) $ git remote show origin Subir todas las ramas y etiquetas: $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: $ git push origin --delete <branchName> 3. Modificar la historia \u00b6 Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: $ git commit --amend [--m \"Nuevo mensaje\"] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: $ git checkout <hash> (o tag, por ejemplo v2.0) You are in 'detached HEAD' state. # Ahora est\u00e1s en un detached HEAD $ git branch * (HEAD detached at 594b606) main $ git checkout -b v2.0.1 Switched to a new branch 'v2.0.1' $ git branch main * v2.0.1 $ git checkout main Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) $ git reset --hard <hash> 4. M\u00e1s informaci\u00f3n \u00b6 Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"Resumen de comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#resumen-de-comandos-git","text":"Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).","title":"Resumen de comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#1-comandos-basicos","text":"Configurar el usuario y direcci\u00f3n de correo en git: $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Inicializar git en un directorio: $ cd /ruta/a/mi/directorio $ git config --global user.name <nombre-usuario> $ git config --global user.email <email> $ git init $ git add . $ git commit -m \"Versi\u00f3n inicial\" Publicar por primera vez el repositorio local en el remoto (en GitHub): $ git remote add origin <url-repo>.git $ git push -u origin main El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama main (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): $ git add <fichero o directorio> El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : $ git commit -m \"Mensaje\" Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): $ git reset HEAD <fichero> Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: $ git commit -a -m \"Mensaje\" Se puede abreviar como $ git commit -am \"Mensaje\"` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: $ git reset --hard HEAD $ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero) Publicar los cambios en el repositorio remoto: $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). $ git log [--oneline] [--graph] [--all] Comprobar las diferencias entre dos commits: $ git diff <hash-previo> <hash-nuevo> Devuelve las cambios que se han introducido desde el commit identificado por y hasta el .","title":"1. Comandos b\u00e1sicos"},{"location":"01-intro-spring-boot/comandos-git.html#2-ramas","text":"Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: $ git checkout -b nueva-rama M hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama) Switched to a new branch 'nueva-rama' Listar todas las ramas de un repositorio (incluyendo ramas remotas) $ git branch -av main * nueva-rama $ git commit -a -m \"Confirmamos los cambios en la nueva rama\" Moverse a otra rama: $ git checkout main Switched to branch 'main' Mostrar un fichero de una rama (o commit) dado: $ git show <commit o rama>:<nombre-fichero> Comparar dos ramas: $ git diff main nueva-rama El comando git diff main nueva-rama devuelve las diferencias entre las ramas main y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama main . Merge de ramas : Mezclar la rama nueva-rama en la rama main (a\u00f1ade a la main los commits adicionales de la rama nueva-rama ): $ git checkout main $ git merge [--no-ff] nueva-rama -m \"Mensaje de commit\" La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. $ git merge nueva-rama CONFLICT (content): Merge conflict in hola.txt Automatic merge failed; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m \"Arreglado el conflicto en el merge\" $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama main ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : $ git checkout -b experiment # hacemos cambios $ git commit -m \"Cambios en experiment\" $ git checkout main # hacemos cambios $ git commit -a -m \"Cambios en main\" $ git checkout experiment $ git rebase main First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama main ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. \u00a1Cuidado! No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama main y tener una historia lineal: $ git checkout main $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : $ git rebase main CONFLICT (content): Merge conflict in <some-file> # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use \"git reset HEAD <some-file>...\" to unstage) # (use \"git add/rm <some-file>...\" as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add <some-file> $ git rebase --continue Nota Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: $ git log --graph --oneline Borrar una rama: $ git branch -d nueva-rama Deleted branch nueva-rama (was c241d7b) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: $ git branch -D rama Subir una rama al repositorio remoto: $ git push -u origin <rama> Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) $ git fetch $ git checkout -b <rama> origin/<rama> Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) $ git remote show origin Subir todas las ramas y etiquetas: $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: $ git push origin --delete <branchName>","title":"2. Ramas"},{"location":"01-intro-spring-boot/comandos-git.html#3-modificar-la-historia","text":"Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: $ git commit --amend [--m \"Nuevo mensaje\"] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: $ git checkout <hash> (o tag, por ejemplo v2.0) You are in 'detached HEAD' state. # Ahora est\u00e1s en un detached HEAD $ git branch * (HEAD detached at 594b606) main $ git checkout -b v2.0.1 Switched to a new branch 'v2.0.1' $ git branch main * v2.0.1 $ git checkout main Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) $ git reset --hard <hash>","title":"3. Modificar la historia"},{"location":"01-intro-spring-boot/comandos-git.html#4-mas-informacion","text":"Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"4. M\u00e1s informaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html","text":"Introducci\u00f3n a Spring Boot \u00b6 Vamos a trabajar con la versi\u00f3n 2.4.8 de Spring Boot. Se puede consultar toda la documentaci\u00f3n oficial sobre esta versi\u00f3n en este enlace . 1. Aplicaci\u00f3n ejemplo \u00b6 Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr . En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp . En el enunciado de la pr\u00e1ctica se encuentran las instrucciones para crear un repositorio GitHub y descargarla en tu ordenador local. La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona. 2. Ejecuci\u00f3n de aplicaciones Spring Boot \u00b6 Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper , como es el caso de la aplicaci\u00f3n ejemplo. Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a mvn si tenemos instalado Maven o a ./mvnw para usar Maven Wrapper: $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito 3. Desarrollo y ejecuci\u00f3n con IntelliJ \u00b6 Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para importar un proyecto Spring Boot en IntelliJ basta con importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File > New > Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ importa el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc: 4. Conceptos de Spring Boot \u00b6 Estructura de la aplicaci\u00f3n \u00b6 Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.ua.mads </groupId> <artifactId> demoapp </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> demoapp </name> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.1.16.RELEASE </version> </parent> <properties> <java.version> 1.8 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-thymeleaf </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties spring.application.name = demoapp Controladores \u00b6 Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoController.java : package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { private final SaludoService service ; @Autowired public SaludoController ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8 Content-Length: 8 Date: Mon, 02 Sep 2019 14:59:04 GMT Hola Ana Clases de Servicio \u00b6 Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return \"Hola \" + nombre ; } } Inyecci\u00f3n de dependencias en Spring \u00b6 Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. En este caso lo hacemos anotando el constructor. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable service que se pasa como par\u00e1metro al constructor. Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection . Alcance de los objetos inyectados \u00b6 Por defecto el alcance ( scope ) de todas las anotaciones de Spring ( @service , @controller , @component , etc.) es un Singleton . Existe una \u00fanica instancia de ese objeto que es la que se inyecta en las variables. Al estar funcionando en una aplicaci\u00f3n web, el singleton que hace de controlador recibir\u00e1 m\u00faltiples peticiones concurrentemente. Cada petici\u00f3n ir\u00e1 en su propio hilo de Java, por lo que m\u00faltiples hilos podr\u00e1n estar ejecutando el mismo c\u00f3digo del controlador. Por ello hay que tener cuidado en no definir variables de instancia mutables (con estado) dentro del controlador, porque podr\u00edan producirse errores debidos a condiciones de carrera (un hilo modifica la misma variable que otro est\u00e1 leyendo). Es conveniente que todos los beans (controladores, servicios, etc.) sean objetos sin estado. Tambi\u00e9n es posible definir otros alcances, como @RequestScope o @SessionScope . En el primer caso se crea una instancia nueva del objeto para cada petici\u00f3n HTTP y en el segundo se crea una instancia nueva en cada sesi\u00f3n HTTP. Puedes encontrar m\u00e1s informaci\u00f3n y ejemplos en este enlace . Plantillas Thymeleaf \u00b6 Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < h1 th:text = \"'Saludo: ' + ${mensaje}\" > </ h1 > </ html > El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { private final SaludoService service ; @Autowired public SaludoControllerPlantilla ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludoplantilla/{nombre}\" ) public String saludo ( @PathVariable ( value = \"nombre\" ) String nombre , Model model ) { // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa // en la plantilla model . addAttribute ( \"mensaje\" , service . saluda ( nombre )); // Se llama a la plantilla 'saludo.html' return \"saludo\" ; } } Tests \u00b6 En Spring Boot 2.4 se usa JUnit 5 como librer\u00eda de tests. En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: $ mvn test O tambi\u00e9n, usando el comando de Maven Wrapper: $ .mvnw test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no. Tests sobre clases de servicio \u00b6 Podemos realizar pruebas sobre la capa de servicio, obteniendo una instancia del servicio mediante inyecci\u00f3n de dependencias. En el siguiente ejemplo se muestra c\u00f3mo se prueba el m\u00e9todo de servicio saluda . Fichero src/test/java/demoapp/ServiceTest.java package demoapp ; import demoapp.service.SaludoService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import static org.assertj.core.api.Assertions.assertThat ; @SpringBootTest public class ServiceTest { @Autowired SaludoService saludo ; @Test public void contexLoads () throws Exception { assertThat ( saludo ). isNotNull (); } @Test public void serviceSaludo () throws Exception { assertThat ( saludo . saluda ( \"Domingo\" )). isEqualTo ( \"Hola Domingo\" ); } } Tests sobre capa web \u00b6 Es posible realizar tests sobre la capa de presentaci\u00f3n sin lanzar realmente el servidor web ni ejecutar realmente las peticiones HTTP. Se obtiene por inyecci\u00f3n de dependencias un mock de la clase MockMvc y se usan m\u00e9todos como perform(get(\"/\")) . En el primer test del ejemplo siguiente se comprueba que una petici\u00f3n GET a la URL / devuelve un c\u00f3digo HTTP OK (200) y una p\u00e1gina HTML con la cadena esperada. En este test lo \u00fanico que se moquea es el servidor web, y se ejecuta el c\u00f3digo real del servicio, del controlador y de la plantilla. Se utilizan los m\u00e9todos andDo y andExpect de la propia librer\u00eda de testeo de Spring Framework y el m\u00e9todo conteainsString de la librer\u00eda de testeo Hamcrest . Tambi\u00e9n es posible realizar un test \u00fanicamente del controlador y la plantilla de presentaci\u00f3n, moqueando el servicio. Se muestra en el segundo test del ejemplo. Fichero src/test/demoapp/WebMockTest.java package demoapp ; import demoapp.service.SaludoService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.mock.mockito.MockBean ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.mockito.Mockito.when ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @SpringBootTest @AutoConfigureMockMvc public class WebMockTest { @Autowired private MockMvc mockMvc ; @Test public void shouldReturnDefaultMessage () throws Exception { this . mockMvc . perform ( get ( \"/\" )) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hello World\" ))); } // Podemos tambi\u00e9n mockear el servicio @MockBean private SaludoService service ; @Test public void greetingShouldReturnMessageFromService () throws Exception { // Y especificar lo que debe devolver una llamada a uno de sus m\u00e9todos when ( service . saluda ( \"Domingo\" )). thenReturn ( \"Hola Mock Domingo\" ); this . mockMvc . perform ( get ( \"/saludo/Domingo\" )) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hola Mock Domingo\" ))); } } Tests sobre la aplicaci\u00f3n en funcionamiento \u00b6 Por \u00faltimo, tambi\u00e9n podemos realizar tests sobre la aplicaci\u00f3n funcionando completamente, realizando una petici\u00f3n al servidor web y comprobando que se devuelve lo esperado. Estos tests son los m\u00e1s costosos porque conllevan levantar el servidor web y realizar completamente el procesamiento de la petici\u00f3n. Fichero src/test/java/demoapp/HttpRequestTest package demoapp ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.web.server.LocalServerPort ; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment ; import static org.assertj.core.api.Assertions.assertThat ; @SpringBootTest ( webEnvironment = WebEnvironment . RANDOM_PORT ) public class HttpRequestTest { @Autowired private TestRestTemplate restTemplate ; @Test public void greetingShouldReturnDefaultMessage () throws Exception { String body = restTemplate . getForObject ( \"/\" , String . class ); assertThat ( body . contains ( \"Hello World\" )); } } 5. Referencias \u00b6 Puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . En concreto, hemos usado las siguientes referencias para construir esta primera aplicaci\u00f3n ejemplo: Getting Started Guide Building an Application with Spring Boot Getting Started Guide Serving Web Content with Spring MVC Spring Boot Reference Guide 2.4.8 ( HTML , PDF )","title":"Introducci\u00f3n a Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#introduccion-a-spring-boot","text":"Vamos a trabajar con la versi\u00f3n 2.4.8 de Spring Boot. Se puede consultar toda la documentaci\u00f3n oficial sobre esta versi\u00f3n en este enlace .","title":"Introducci\u00f3n a Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#1-aplicacion-ejemplo","text":"Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr . En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp . En el enunciado de la pr\u00e1ctica se encuentran las instrucciones para crear un repositorio GitHub y descargarla en tu ordenador local. La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona.","title":"1. Aplicaci\u00f3n ejemplo"},{"location":"01-intro-spring-boot/intro-spring-boot.html#2-ejecucion-de-aplicaciones-spring-boot","text":"Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper , como es el caso de la aplicaci\u00f3n ejemplo. Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a mvn si tenemos instalado Maven o a ./mvnw para usar Maven Wrapper: $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito","title":"2. Ejecuci\u00f3n de aplicaciones Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#3-desarrollo-y-ejecucion-con-intellij","text":"Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para importar un proyecto Spring Boot en IntelliJ basta con importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File > New > Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ importa el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:","title":"3. Desarrollo y ejecuci\u00f3n con IntelliJ"},{"location":"01-intro-spring-boot/intro-spring-boot.html#4-conceptos-de-spring-boot","text":"","title":"4. Conceptos de Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#estructura-de-la-aplicacion","text":"Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.ua.mads </groupId> <artifactId> demoapp </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> demoapp </name> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.1.16.RELEASE </version> </parent> <properties> <java.version> 1.8 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-thymeleaf </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties spring.application.name = demoapp","title":"Estructura de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html#controladores","text":"Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoController.java : package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { private final SaludoService service ; @Autowired public SaludoController ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8 Content-Length: 8 Date: Mon, 02 Sep 2019 14:59:04 GMT Hola Ana","title":"Controladores"},{"location":"01-intro-spring-boot/intro-spring-boot.html#clases-de-servicio","text":"Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return \"Hola \" + nombre ; } }","title":"Clases de Servicio"},{"location":"01-intro-spring-boot/intro-spring-boot.html#inyeccion-de-dependencias-en-spring","text":"Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. En este caso lo hacemos anotando el constructor. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable service que se pasa como par\u00e1metro al constructor. Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection .","title":"Inyecci\u00f3n de dependencias en Spring"},{"location":"01-intro-spring-boot/intro-spring-boot.html#plantillas-thymeleaf","text":"Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < h1 th:text = \"'Saludo: ' + ${mensaje}\" > </ h1 > </ html > El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { private final SaludoService service ; @Autowired public SaludoControllerPlantilla ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludoplantilla/{nombre}\" ) public String saludo ( @PathVariable ( value = \"nombre\" ) String nombre , Model model ) { // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa // en la plantilla model . addAttribute ( \"mensaje\" , service . saluda ( nombre )); // Se llama a la plantilla 'saludo.html' return \"saludo\" ; } }","title":"Plantillas Thymeleaf"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests","text":"En Spring Boot 2.4 se usa JUnit 5 como librer\u00eda de tests. En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: $ mvn test O tambi\u00e9n, usando el comando de Maven Wrapper: $ .mvnw test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no.","title":"Tests"},{"location":"01-intro-spring-boot/intro-spring-boot.html#5-referencias","text":"Puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . En concreto, hemos usado las siguientes referencias para construir esta primera aplicaci\u00f3n ejemplo: Getting Started Guide Building an Application with Spring Boot Getting Started Guide Serving Web Content with Spring MVC Spring Boot Reference Guide 2.4.8 ( HTML , PDF )","title":"5. Referencias"},{"location":"01-intro-spring-boot/practica1.html","text":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n con Spring Boot \u00b6 En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot, Git y Docker. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub. Crear una aplicaci\u00f3n desplegable usando Docker Desplegar la aplicaci\u00f3n en el servidor de la asignatura. 1. Instalaci\u00f3n de software \u00b6 Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior IntelliJ Ultimate Nota del profesor sobre en el sistema operativo en el que realizar la pr\u00e1ctica Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones, ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica. Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Instalaci\u00f3n b\u00e1sica \u00b6 Linux \u00b6 Para instalar el software en Linux. Instalar Git y Java: $ sudo apt install git $ sudo apt install default-jdk Instalar IntelliJ Ultimate macOS \u00b6 Git y Java vienen instalados con el sistema operativo. Instalar IntelliJ Ultimate Windows \u00b6 Es recomendable instalar git for Windows , que adem\u00e1s de Git instala Git BASH, un terminal Bash integrado en Windows. Adem\u00e1s, hay que instalar Java e IntelliJ Ultimate . Despu\u00e9s de la instalaci\u00f3n b\u00e1sica \u00b6 Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: $ git --version $ java -version (imprime la versi\u00f3n de Java) Configuraci\u00f3n del prompt para que aparezca la rama de Git \u00b6 Bash Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero $HOME/.bashrc (linux y Git Bash Windows) o $HOME/.bash_profile (macOS con shell bash ) : parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/' } export PS1=\"\\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \" Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed . Zsh Si trabajas con el shell zsh que viene por defecto en MacOS, debes a\u00f1adir en el fichero .zshrc lo siguiente: parse_git_branch() { git branch 2> /dev/null | sed -n -e 's/^\\* \\(.*\\)/ [\\1]/p' } setopt PROMPT_SUBST export PROMPT='%1~%F{green}$(parse_git_branch)%f %% ' 2. Creaci\u00f3n del repositorio GitHub con la pr\u00e1ctica \u00b6 Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings > Profile y actualizando el campo Name . Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring Boot Demo App . Se crear\u00e1 autom\u00e1ticamente el repositorio springboot-demo-app-<usuario> en la organizaci\u00f3n mads-ua-21-22 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp ). Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-21-22 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub: El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n mads-ua-21-22 y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-21-22 . 3. Aplicaci\u00f3n Demo de Spring Boot \u00b6 Haremos una primera pr\u00e1ctica sencilla en la que primero pondremos en marcha y publicaremos una aplicaci\u00f3n inicial en Spring Boot y despu\u00e9s a\u00f1adiremos alguna funcionalidad. En el documento Introducci\u00f3n a Spring Boot se explica c\u00f3mo ejecutar una aplicaci\u00f3n Spring Boot y c\u00f3mo lanzar sus tests. Tambi\u00e9n se proporciona una introducci\u00f3n a los distintos componentes de la aplicaci\u00f3n. Debes leerlo y aprender el funcionamiento b\u00e1sico de este framework . Construcci\u00f3n y ejecuci\u00f3n de la aplicaci\u00f3n \u00b6 Una vez le\u00eddo el documento Introducci\u00f3n a Spring Boot deber\u00e1s descargar la aplicaci\u00f3n demo-spring-boot que tienes en el repositorio creado en el punto 2 anterior y comprobar que funciona correctamente. Debes hacer lo siguiente: Descarga en tu ordenador el repositorio creado en GitHub en el punto 2, usando el comando git clone : $ git clone springboot-demo-app-<usuario> Importa la aplicaci\u00f3n en IntelliJ, tal y como se explica en el documento Introducci\u00f3n a Spring Boot . Prueba que se pasan todos los tests usando el comando Maven desde el terminal ( .mvnw ) y utilizando el panel de proyecto en IntelliJ. Ejecuta la aplicaci\u00f3n desde l\u00ednea de comando y desde IntelliJ. Haz alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n, cambiando el mensaje de saludo para incluir tu nombre. Comprueba que los tests pasan (modif\u00edcalos si no es as\u00ed) y que la aplicaci\u00f3n funciona correctamente. Dockerizaci\u00f3n de la aplicaci\u00f3n \u00b6 Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Las m\u00e1quinas Docker son muy eficientes porque comparten los servicios del sistema operativo en el que se ejecutan, utilizando menos recursos que las m\u00e1quinas virtuales tradicionales. Docker proporciona un sistema muy sencillo de distribuci\u00f3n y puesta en producci\u00f3n de software, ya que las m\u00e1quinas Docker pueden ser distribuidas usando repositorios (como Docker Hub ) y ejecutadas en cualquier ordenador que tenga instalado el Docker Engine . La tecnolog\u00eda es muy popular y se usa en gran cantidad de empresas de desarrollo para simplificar la ejecuci\u00f3n en en m\u00faltiples entornos y para que los contenedores (m\u00e1quinas Docker en ejecuci\u00f3n) se pueden configurar y combinar o ejecutar en clusters usando herramientas como Kubernetes . En nuestro caso, vamos a construir una m\u00e1quina Docker basada en la aplicaci\u00f3n demo. Posteriormente, la publicaremos en Docker Hub y la desplegaremos en un host para ponerla en producci\u00f3n. Instala Docker Desktop . Los usuarios de Linux deb\u00e9is seguir las instrucciones de esta p\u00e1gina para instalar Docker Engine. Usaremos la l\u00ednea de comando para lanzar los comandos Docker. La aplicaci\u00f3n Docker Desktop permite usar una interfaz de usuario para interactuar con im\u00e1genes y contenedores, pero no proporciona ninguna funcionalidad que no est\u00e9 disponible en la l\u00ednea de comando. Una vez instalado puedes probar el tutorial r\u00e1pido (2 minutos) desde Docker Desktop para comprobar que todo funciona correctamente. Tambi\u00e9n puedes desde el terminal comprobar la versi\u00f3n de Docker instalada: $ docker version Crea una cuenta de usuario en Docker Hub . De esta forma tendr\u00e1s un repositorio en el que podr\u00e1s subir las im\u00e1genes de las m\u00e1quinas Docker que construyas. Deber\u00e1s dar un nombre de usuario que ser\u00e1 el que utilizar\u00e1s para publicar estas im\u00e1genes. Crea un fichero llamado Dockerfile (sin extensi\u00f3n) en el directorio ra\u00edz de la aplicaci\u00f3n con el siguiente contenido: Fichero ./Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] El fichero Dockerfile consiste en un conjunto secuencial de instrucciones con las que se construye la m\u00e1quina Docker: FROM : este comando indica la m\u00e1quina base sobre la que se van a ejecutar el resto de comandos. En nuestro caso una m\u00e1quina de la organizaci\u00f3n openjdk que contiene la distribuci\u00f3n 8 del Java Development Kit (JDK) y que est\u00e1 basada en una distribuci\u00f3n linux Alpine. El primer paso de la construcci\u00f3n de nuestra m\u00e1quina Docker consiste por tanto en descargar esta m\u00e1quina openjdk:8-jdk-alpine y usarla como m\u00e1quina base. COPY : este comando indica que se debe copiar un fichero o conjunto de ficheros de la m\u00e1quina host (el directorio en el que estamos) en la m\u00e1quina base. En este caso se copia el fichero JAR que constituye nuestra aplicaci\u00f3n que est\u00e1 situado en el directorio ./target y se copia en la m\u00e1quina Docker con el nombre app.jar . ENTRYPOINT : este comando indica el comando a ejecutar cuando se pone en marcha la m\u00e1quina Docker. En este caso se lanza la aplicaci\u00f3n ( app.jar ) con el comando java -jar . El modificador -Djava.security.egd hace que se inicialice el generador de n\u00fameros aleatorios de Java usando el fichero del sistema /dev/urandom en lugar del fichero por defecto /dev/random . Es necesario para resolver un bug que aparece al ejecutar el contenedor en un servidor alojado DigitalOcean (el servidor de la asignatura, en el que pondr\u00e1s la aplicaci\u00f3n en producci\u00f3n, usa ese servicio). Aseg\u00farate de que en el directorio ra\u00edz de la aplicaci\u00f3n est\u00e1 el fichero JAR resultado de la compilaci\u00f3n: $ ls -l ./target/*.jar ./target/demoapp-0.0.1-SNAPSHOT.jar Tal y como se explica en la introducci\u00f3n a Spring Boot , el fichero .jar es el ejecutable Java de la aplicaci\u00f3n, que se crea cuando con el objetivo package de Maven: $ ./mvnw package Ya puedes construir la m\u00e1quina Docker con el siguiente comando, desde el directorio ra\u00edz de la aplicaci\u00f3n (en el que debe estar el fichero Dockerfile anterior): $ docker build -t <usuario-docker>/spring-boot-demoapp . Comprueba que la imagen se ha creado correctamente. Debe aparecer en el Docker Desktop y con el comando docker image ls : $ docker image ls REPOSITORY TAG domingogallardo/spring-boot-demoapp latest Pon en marcha un la imagen con la aplicaci\u00f3n: $ docker run -p 8080:8080 <usuario-docker>/spring-boot-demoapp El comando docker run pone en marcha la imagen indicada, creando lo que se denomina un contenedor Docker . Es similar a una m\u00e1quina virtual en ejecuci\u00f3n. El par\u00e1metro -p 8080:8080 indica que el puerto interno 8080 del contenedor se va a mapear en el puerto 8080 del host . De esta forma podremos conectarnos desde el host a la aplicaci\u00f3n Spring Boot en funcionamiento. Ver\u00e1s que en la consola aparecen los mensajes de salida de la aplicaci\u00f3n Spring Boot que se ejecuta en el contenedor. Prueba a abrir un navegador y conectarte a la URL localhost:8080 . Deber\u00e1s ver el mensaje de saludo de la aplicaci\u00f3n ejecut\u00e1ndose en el contendor. Haciendo ctrl+c puedes parar el contenedor. El efecto es similar a suspender una m\u00e1quina virtual. Puedes ver el identificador del contenedor con el comando: $ docker container ls -a CONTAINER ID IMAGE NAMES 5bd9d0b055a9 domingogallardo/spring-boot-demoapp inspiring_feynman Puedes usar tanto el ID del contenedor ( 5bd9d0b055a9 ) como su nombre ( inspiring_feynman ) para identificarlo. Estando parado, puedes volver a poner en marcha el contenedor haciendo: $ docker container start <identificador> O borrarlo definitivamente con $ docker container rm <identificador> Otros comandos \u00fatiles de Docker son: docker run -d : lanza el contendor en modo background . docker run --rm : lanza el contenedor de forma que al pararlo se borra autom\u00e1ticamente. docker container stop <identificador> : para el contenedor indicado. docker container logs <identificador> : muestra los logs del contenedor indicado. En la aplicaci\u00f3n Docker Engine podemos realizar tambi\u00e9n muchos de estos comandos interactuando directamente con la interfaz. Pru\u00e9balo. Ahora que has comprobado que el fichero Dockerfile funciona correctamente debes a\u00f1adirlo a git y subirlo al respositorio GitHub: $ git status $ git add . $ git status $ git commit -m \"A\u00f1adido Dockerfile\" $ git push Vamos a terminar publicando la imagen en tu cuenta de Docker Hub. Ve a Docker Hub y log\u00e9ate. Crea un repositorio con el nombre spring-boot-demoapp . En ese repositorio vas a subir la imagen con el mismo nombre. En un repositorio Docker puedes mantener m\u00faltiples versiones de una misma imagen, usando tags . Una vez creado el repositorio puedes publicar la imagen en \u00e9l loge\u00e1ndote desde la l\u00ednea de comando (introduce tu usuario y contrase\u00f1a de Docker Hub) y con el comando docker push : $ docker login $ docker push <usuario-docker>/spring-boot-demoapp Ver\u00e1s que autom\u00e1ticamente se asigna la etiqueta latest (etiqueta por defecto) a la imagen y que \u00e9sta se sube al repositorio. Podr\u00edas asignar una etiqueta espec\u00edfica a la imagen con el comando docker tag . Por ejemplo, si quisi\u00e9ramos fijar esta imagen con la versi\u00f3n 1.0 podr\u00edamos hacerlo con el siguiente comando: $ docker tag <usario-docker>/spring-boot-demoapp <usuario-docker>/spring-boot-demoapp:1.0 Comprueba en la p\u00e1gina web del repositorio que se ha subido. El repositorio es p\u00fablico y cualquiera puede descargar la imagen haciendo: $ docker pull <usuario-docker>/spring-boot-demoapp Al no indicar la etiqueta, se descargar\u00eda la imagen etiquetada con latest . Si quisi\u00e9ramos descargar una versi\u00f3n concreta habr\u00eda que especificar la etiqueta: $ docker pull <usuario-docker>/spring-boot-demoapp:1.0 Puesta en producci\u00f3n de la aplicaci\u00f3n \u00b6 Por \u00faltimo deber\u00e1s poner en producci\u00f3n la aplicaci\u00f3n, conect\u00e1ndote al servidor linux de la asignatura y poniendo all\u00ed en marcha la aplicaci\u00f3n. Consulta en el foro de Moodle la direcci\u00f3n IP del servidor linux de la asignatura y tu usuario. Con\u00e9ctate al servidor con tu usuario y cambia tu contrase\u00f1a. Por ejemplo, si tu usuario es alu02 y la direcci\u00f3n IP del servidor es 161.35.65.197 : $ ssh alu02@161.35.65.197 $ passwd 3. Comprueba si alguien m\u00e1s est\u00e1 utilizando el servidor: $ who alu02 pts/1 2021-08-11 07:01 (80.29.50.137) Si alg\u00fan otro compa\u00f1ero est\u00e1 usando el servidor puede ser posible que se ralentice o que ya el puerto 8080 ya est\u00e9 ocupado por la aplicaci\u00f3n del compa\u00f1ero. En este \u00faltimo caso puedes usar un puerto diferente para poner la aplicaci\u00f3n en producci\u00f3n. Descarga tu imagen de la aplicaci\u00f3n y ponla en funcionamiento: $ docker pull <usuario-docker>/spring-boot-demoapp $ docker run --rm --name spring-boot-alu02 -p 8080:8080 <usuario-docker>/spring-boot-demoapp El indicador --rm hace que cuando se pare el contenedor autom\u00e1ticamente se borre. De esta forma evitamos tener que borrarlo a mano despu\u00e9s. El indicador --name define el nombre del contenedor. Ponemos nuestro nombre, para poder identificar qui\u00e9nes han creado cada contenedor. En el caso en que otro compa\u00f1ero tenga la aplicaci\u00f3n en marcha en ese puerto aparecer\u00e1 el siguiente mensaje de error: docker: Error response from daemon: driver failed programming ... Bind for 0.0.0.0:8080 failed: port is already allocated. En ese caso puedes usar otro puerto. El primer puerto es el que se refiere al host y el segundo a la aplicaci\u00f3n corriendo en el contenedor. Por ejemplo, puedes usar el puerto 8081 : $ docker run --rm --name spring-boot-alu02 -p 8081:8080 <usuario-docker>/spring-boot-demoapp Comprueba que la aplicaci\u00f3n funciona correctamente conect\u00e1ndote desde tu navegador al servidor linux de la asignatura y al puerto correctamente: http://161.35.65.197:8080 . \u00a1Enhorabuena, ya tienes tu aplicaci\u00f3n en producci\u00f3n!. Puedes llamar a cualquier amigo para que se conecte a esa URL y la pruebe. Importante Para entregar la pr\u00e1ctica deber\u00e1s ponerla en producci\u00f3n en el servidor de la asignatura y el profesor comprobar\u00e1 que funciona correctamente. Lo haremos en el horario de clase de pr\u00e1cticas. Si en alg\u00fan momento tenemos problemas de espacio en el disco duro, podemos borrar la imagen y el contenedor: $ docker container ls -a $ docker container rm spring-boot-alu02 $ docker image ls -a $ docker image rm <nombre-imagen> o <image-id> $ exit No guardar ficheros en el servidor de la asignatura El servidor de la asignatura tiene una capacidad limitada de disco duro y debemos tener cuidado de no sobrepasarla entre todos. Por ello, no debes guardar ning\u00fan fichero ajeno a la asignatura en este servidor. 4. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n \u00b6 En el documento Introducci\u00f3n a Spring Boot se comenta el c\u00f3digo fuente de la aplicaci\u00f3n Spring Boot con la que estamos trabajando. L\u00e9elo despacio, revisando tambi\u00e9n el c\u00f3digo fuente, para entender los aspectos b\u00e1sicos (controladores, servicios, inyecci\u00f3n de dependencias, plantillas, tests) del funcionamiento de Spring Boot. En el siguiente documento se explica c\u00f3mo usar los formularios en Spring Boot: Handling Form Submission Lee tambi\u00e9n el siguiente documento, en el que se explica c\u00f3mo usar la validaci\u00f3n de los campos de un formulario de entrada. Validating Form Input El c\u00f3digo que hay en el ejemplo anterior es algo distinto al que estamos usando en clase. Por ejemplo, la forma de definir los controllers. Es mejor que uses como ejemplo de validaci\u00f3n el c\u00f3digo que hay en el repositorio domingogallardo/spring-boot-validate . Ver\u00e1s tambi\u00e9n ah\u00ed varios ejemplos de tests en los que se realiza una petici\u00f3n POST pasando par\u00e1metros y se obtiene informaci\u00f3n del modelo resultante, llamando al m\u00e9todo model() . El siguiente es un ejemplo de uno de los tests: @Test public void checkPersonInfoWhenNameTooShortThenFailure () throws Exception { mockMvc . perform ( post ( \"/\" ) . param ( \"name\" , \"R\" ) . param ( \"age\" , \"20\" )) . andExpect ( model (). hasErrors ()); } Debemos a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n que realice lo siguiente: Leer datos de un formulario usando Thymeleaf y realizar alguna validaci\u00f3n . Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Incluir al menos 2 tests: 1 de la capa de servicio 1 de la capa de presentaci\u00f3n usando MockMvc. En la p\u00e1gina principal de la aplicaci\u00f3n debe aparecer tu nombre y apellidos. Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra: Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma. N\u00famero par: lee un n\u00famero y comprueba si es par Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado. Cuando compruebes que los tests funcionan correctamente y que la aplicaci\u00f3n funciona bien en local, debes crear la m\u00e1quina Docker con la etiqueta final y probar que funciona bien en producci\u00f3n en el servidor de la asignatura. 5. Comandos Git \u00b6 Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en el documento Resumen de comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura. 6. Entrega \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada el martes 21 de septiembre. El mi\u00e9rcoles 22 de septiembre el profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de pr\u00e1cticas. Para realizar la entrega debes hacer lo siguiente: Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits a GitHub conforme se van realizando. Actualizar el fichero README.md con la URL del repositorio Docker Hub donde se ha subido la m\u00e1quina Docker final. A\u00f1adir una p\u00e1gina de documentaci\u00f3n doc/practica1.md en la que se explique la funcionalidad y el c\u00f3digo a\u00f1adido. Incluir en la documentaci\u00f3n la URL de los repositorios en GitHub y en Docker Hub. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho ./mvnw clean para eliminar los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de toda la semana y no dejar todo para el \u00faltimo d\u00eda). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Enunciado de la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#practica-1-primera-aplicacion-con-spring-boot","text":"En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot, Git y Docker. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub. Crear una aplicaci\u00f3n desplegable usando Docker Desplegar la aplicaci\u00f3n en el servidor de la asignatura.","title":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n con Spring Boot"},{"location":"01-intro-spring-boot/practica1.html#1-instalacion-de-software","text":"Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior IntelliJ Ultimate Nota del profesor sobre en el sistema operativo en el que realizar la pr\u00e1ctica Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones, ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica. Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.","title":"1. Instalaci\u00f3n de software"},{"location":"01-intro-spring-boot/practica1.html#instalacion-basica","text":"","title":"Instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica1.html#despues-de-la-instalacion-basica","text":"Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: $ git --version $ java -version (imprime la versi\u00f3n de Java)","title":"Despu\u00e9s de la instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica1.html#2-creacion-del-repositorio-github-con-la-practica","text":"Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings > Profile y actualizando el campo Name . Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring Boot Demo App . Se crear\u00e1 autom\u00e1ticamente el repositorio springboot-demo-app-<usuario> en la organizaci\u00f3n mads-ua-21-22 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp ). Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-21-22 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub: El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n mads-ua-21-22 y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-21-22 .","title":"2. Creaci\u00f3n del repositorio GitHub con la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#3-aplicacion-demo-de-spring-boot","text":"Haremos una primera pr\u00e1ctica sencilla en la que primero pondremos en marcha y publicaremos una aplicaci\u00f3n inicial en Spring Boot y despu\u00e9s a\u00f1adiremos alguna funcionalidad. En el documento Introducci\u00f3n a Spring Boot se explica c\u00f3mo ejecutar una aplicaci\u00f3n Spring Boot y c\u00f3mo lanzar sus tests. Tambi\u00e9n se proporciona una introducci\u00f3n a los distintos componentes de la aplicaci\u00f3n. Debes leerlo y aprender el funcionamiento b\u00e1sico de este framework .","title":"3. Aplicaci\u00f3n Demo de Spring Boot"},{"location":"01-intro-spring-boot/practica1.html#construccion-y-ejecucion-de-la-aplicacion","text":"Una vez le\u00eddo el documento Introducci\u00f3n a Spring Boot deber\u00e1s descargar la aplicaci\u00f3n demo-spring-boot que tienes en el repositorio creado en el punto 2 anterior y comprobar que funciona correctamente. Debes hacer lo siguiente: Descarga en tu ordenador el repositorio creado en GitHub en el punto 2, usando el comando git clone : $ git clone springboot-demo-app-<usuario> Importa la aplicaci\u00f3n en IntelliJ, tal y como se explica en el documento Introducci\u00f3n a Spring Boot . Prueba que se pasan todos los tests usando el comando Maven desde el terminal ( .mvnw ) y utilizando el panel de proyecto en IntelliJ. Ejecuta la aplicaci\u00f3n desde l\u00ednea de comando y desde IntelliJ. Haz alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n, cambiando el mensaje de saludo para incluir tu nombre. Comprueba que los tests pasan (modif\u00edcalos si no es as\u00ed) y que la aplicaci\u00f3n funciona correctamente.","title":"Construcci\u00f3n y ejecuci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#dockerizacion-de-la-aplicacion","text":"Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Las m\u00e1quinas Docker son muy eficientes porque comparten los servicios del sistema operativo en el que se ejecutan, utilizando menos recursos que las m\u00e1quinas virtuales tradicionales. Docker proporciona un sistema muy sencillo de distribuci\u00f3n y puesta en producci\u00f3n de software, ya que las m\u00e1quinas Docker pueden ser distribuidas usando repositorios (como Docker Hub ) y ejecutadas en cualquier ordenador que tenga instalado el Docker Engine . La tecnolog\u00eda es muy popular y se usa en gran cantidad de empresas de desarrollo para simplificar la ejecuci\u00f3n en en m\u00faltiples entornos y para que los contenedores (m\u00e1quinas Docker en ejecuci\u00f3n) se pueden configurar y combinar o ejecutar en clusters usando herramientas como Kubernetes . En nuestro caso, vamos a construir una m\u00e1quina Docker basada en la aplicaci\u00f3n demo. Posteriormente, la publicaremos en Docker Hub y la desplegaremos en un host para ponerla en producci\u00f3n. Instala Docker Desktop . Los usuarios de Linux deb\u00e9is seguir las instrucciones de esta p\u00e1gina para instalar Docker Engine. Usaremos la l\u00ednea de comando para lanzar los comandos Docker. La aplicaci\u00f3n Docker Desktop permite usar una interfaz de usuario para interactuar con im\u00e1genes y contenedores, pero no proporciona ninguna funcionalidad que no est\u00e9 disponible en la l\u00ednea de comando. Una vez instalado puedes probar el tutorial r\u00e1pido (2 minutos) desde Docker Desktop para comprobar que todo funciona correctamente. Tambi\u00e9n puedes desde el terminal comprobar la versi\u00f3n de Docker instalada: $ docker version Crea una cuenta de usuario en Docker Hub . De esta forma tendr\u00e1s un repositorio en el que podr\u00e1s subir las im\u00e1genes de las m\u00e1quinas Docker que construyas. Deber\u00e1s dar un nombre de usuario que ser\u00e1 el que utilizar\u00e1s para publicar estas im\u00e1genes. Crea un fichero llamado Dockerfile (sin extensi\u00f3n) en el directorio ra\u00edz de la aplicaci\u00f3n con el siguiente contenido: Fichero ./Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] El fichero Dockerfile consiste en un conjunto secuencial de instrucciones con las que se construye la m\u00e1quina Docker: FROM : este comando indica la m\u00e1quina base sobre la que se van a ejecutar el resto de comandos. En nuestro caso una m\u00e1quina de la organizaci\u00f3n openjdk que contiene la distribuci\u00f3n 8 del Java Development Kit (JDK) y que est\u00e1 basada en una distribuci\u00f3n linux Alpine. El primer paso de la construcci\u00f3n de nuestra m\u00e1quina Docker consiste por tanto en descargar esta m\u00e1quina openjdk:8-jdk-alpine y usarla como m\u00e1quina base. COPY : este comando indica que se debe copiar un fichero o conjunto de ficheros de la m\u00e1quina host (el directorio en el que estamos) en la m\u00e1quina base. En este caso se copia el fichero JAR que constituye nuestra aplicaci\u00f3n que est\u00e1 situado en el directorio ./target y se copia en la m\u00e1quina Docker con el nombre app.jar . ENTRYPOINT : este comando indica el comando a ejecutar cuando se pone en marcha la m\u00e1quina Docker. En este caso se lanza la aplicaci\u00f3n ( app.jar ) con el comando java -jar . El modificador -Djava.security.egd hace que se inicialice el generador de n\u00fameros aleatorios de Java usando el fichero del sistema /dev/urandom en lugar del fichero por defecto /dev/random . Es necesario para resolver un bug que aparece al ejecutar el contenedor en un servidor alojado DigitalOcean (el servidor de la asignatura, en el que pondr\u00e1s la aplicaci\u00f3n en producci\u00f3n, usa ese servicio). Aseg\u00farate de que en el directorio ra\u00edz de la aplicaci\u00f3n est\u00e1 el fichero JAR resultado de la compilaci\u00f3n: $ ls -l ./target/*.jar ./target/demoapp-0.0.1-SNAPSHOT.jar Tal y como se explica en la introducci\u00f3n a Spring Boot , el fichero .jar es el ejecutable Java de la aplicaci\u00f3n, que se crea cuando con el objetivo package de Maven: $ ./mvnw package Ya puedes construir la m\u00e1quina Docker con el siguiente comando, desde el directorio ra\u00edz de la aplicaci\u00f3n (en el que debe estar el fichero Dockerfile anterior): $ docker build -t <usuario-docker>/spring-boot-demoapp . Comprueba que la imagen se ha creado correctamente. Debe aparecer en el Docker Desktop y con el comando docker image ls : $ docker image ls REPOSITORY TAG domingogallardo/spring-boot-demoapp latest Pon en marcha un la imagen con la aplicaci\u00f3n: $ docker run -p 8080:8080 <usuario-docker>/spring-boot-demoapp El comando docker run pone en marcha la imagen indicada, creando lo que se denomina un contenedor Docker . Es similar a una m\u00e1quina virtual en ejecuci\u00f3n. El par\u00e1metro -p 8080:8080 indica que el puerto interno 8080 del contenedor se va a mapear en el puerto 8080 del host . De esta forma podremos conectarnos desde el host a la aplicaci\u00f3n Spring Boot en funcionamiento. Ver\u00e1s que en la consola aparecen los mensajes de salida de la aplicaci\u00f3n Spring Boot que se ejecuta en el contenedor. Prueba a abrir un navegador y conectarte a la URL localhost:8080 . Deber\u00e1s ver el mensaje de saludo de la aplicaci\u00f3n ejecut\u00e1ndose en el contendor. Haciendo ctrl+c puedes parar el contenedor. El efecto es similar a suspender una m\u00e1quina virtual. Puedes ver el identificador del contenedor con el comando: $ docker container ls -a CONTAINER ID IMAGE NAMES 5bd9d0b055a9 domingogallardo/spring-boot-demoapp inspiring_feynman Puedes usar tanto el ID del contenedor ( 5bd9d0b055a9 ) como su nombre ( inspiring_feynman ) para identificarlo. Estando parado, puedes volver a poner en marcha el contenedor haciendo: $ docker container start <identificador> O borrarlo definitivamente con $ docker container rm <identificador> Otros comandos \u00fatiles de Docker son: docker run -d : lanza el contendor en modo background . docker run --rm : lanza el contenedor de forma que al pararlo se borra autom\u00e1ticamente. docker container stop <identificador> : para el contenedor indicado. docker container logs <identificador> : muestra los logs del contenedor indicado. En la aplicaci\u00f3n Docker Engine podemos realizar tambi\u00e9n muchos de estos comandos interactuando directamente con la interfaz. Pru\u00e9balo. Ahora que has comprobado que el fichero Dockerfile funciona correctamente debes a\u00f1adirlo a git y subirlo al respositorio GitHub: $ git status $ git add . $ git status $ git commit -m \"A\u00f1adido Dockerfile\" $ git push Vamos a terminar publicando la imagen en tu cuenta de Docker Hub. Ve a Docker Hub y log\u00e9ate. Crea un repositorio con el nombre spring-boot-demoapp . En ese repositorio vas a subir la imagen con el mismo nombre. En un repositorio Docker puedes mantener m\u00faltiples versiones de una misma imagen, usando tags . Una vez creado el repositorio puedes publicar la imagen en \u00e9l loge\u00e1ndote desde la l\u00ednea de comando (introduce tu usuario y contrase\u00f1a de Docker Hub) y con el comando docker push : $ docker login $ docker push <usuario-docker>/spring-boot-demoapp Ver\u00e1s que autom\u00e1ticamente se asigna la etiqueta latest (etiqueta por defecto) a la imagen y que \u00e9sta se sube al repositorio. Podr\u00edas asignar una etiqueta espec\u00edfica a la imagen con el comando docker tag . Por ejemplo, si quisi\u00e9ramos fijar esta imagen con la versi\u00f3n 1.0 podr\u00edamos hacerlo con el siguiente comando: $ docker tag <usario-docker>/spring-boot-demoapp <usuario-docker>/spring-boot-demoapp:1.0 Comprueba en la p\u00e1gina web del repositorio que se ha subido. El repositorio es p\u00fablico y cualquiera puede descargar la imagen haciendo: $ docker pull <usuario-docker>/spring-boot-demoapp Al no indicar la etiqueta, se descargar\u00eda la imagen etiquetada con latest . Si quisi\u00e9ramos descargar una versi\u00f3n concreta habr\u00eda que especificar la etiqueta: $ docker pull <usuario-docker>/spring-boot-demoapp:1.0","title":"Dockerizaci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#puesta-en-produccion-de-la-aplicacion","text":"Por \u00faltimo deber\u00e1s poner en producci\u00f3n la aplicaci\u00f3n, conect\u00e1ndote al servidor linux de la asignatura y poniendo all\u00ed en marcha la aplicaci\u00f3n. Consulta en el foro de Moodle la direcci\u00f3n IP del servidor linux de la asignatura y tu usuario. Con\u00e9ctate al servidor con tu usuario y cambia tu contrase\u00f1a. Por ejemplo, si tu usuario es alu02 y la direcci\u00f3n IP del servidor es 161.35.65.197 : $ ssh alu02@161.35.65.197 $ passwd 3. Comprueba si alguien m\u00e1s est\u00e1 utilizando el servidor: $ who alu02 pts/1 2021-08-11 07:01 (80.29.50.137) Si alg\u00fan otro compa\u00f1ero est\u00e1 usando el servidor puede ser posible que se ralentice o que ya el puerto 8080 ya est\u00e9 ocupado por la aplicaci\u00f3n del compa\u00f1ero. En este \u00faltimo caso puedes usar un puerto diferente para poner la aplicaci\u00f3n en producci\u00f3n. Descarga tu imagen de la aplicaci\u00f3n y ponla en funcionamiento: $ docker pull <usuario-docker>/spring-boot-demoapp $ docker run --rm --name spring-boot-alu02 -p 8080:8080 <usuario-docker>/spring-boot-demoapp El indicador --rm hace que cuando se pare el contenedor autom\u00e1ticamente se borre. De esta forma evitamos tener que borrarlo a mano despu\u00e9s. El indicador --name define el nombre del contenedor. Ponemos nuestro nombre, para poder identificar qui\u00e9nes han creado cada contenedor. En el caso en que otro compa\u00f1ero tenga la aplicaci\u00f3n en marcha en ese puerto aparecer\u00e1 el siguiente mensaje de error: docker: Error response from daemon: driver failed programming ... Bind for 0.0.0.0:8080 failed: port is already allocated. En ese caso puedes usar otro puerto. El primer puerto es el que se refiere al host y el segundo a la aplicaci\u00f3n corriendo en el contenedor. Por ejemplo, puedes usar el puerto 8081 : $ docker run --rm --name spring-boot-alu02 -p 8081:8080 <usuario-docker>/spring-boot-demoapp Comprueba que la aplicaci\u00f3n funciona correctamente conect\u00e1ndote desde tu navegador al servidor linux de la asignatura y al puerto correctamente: http://161.35.65.197:8080 . \u00a1Enhorabuena, ya tienes tu aplicaci\u00f3n en producci\u00f3n!. Puedes llamar a cualquier amigo para que se conecte a esa URL y la pruebe. Importante Para entregar la pr\u00e1ctica deber\u00e1s ponerla en producci\u00f3n en el servidor de la asignatura y el profesor comprobar\u00e1 que funciona correctamente. Lo haremos en el horario de clase de pr\u00e1cticas. Si en alg\u00fan momento tenemos problemas de espacio en el disco duro, podemos borrar la imagen y el contenedor: $ docker container ls -a $ docker container rm spring-boot-alu02 $ docker image ls -a $ docker image rm <nombre-imagen> o <image-id> $ exit No guardar ficheros en el servidor de la asignatura El servidor de la asignatura tiene una capacidad limitada de disco duro y debemos tener cuidado de no sobrepasarla entre todos. Por ello, no debes guardar ning\u00fan fichero ajeno a la asignatura en este servidor.","title":"Puesta en producci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#4-anadimos-alguna-funcionalidad-sencilla-a-la-aplicacion","text":"En el documento Introducci\u00f3n a Spring Boot se comenta el c\u00f3digo fuente de la aplicaci\u00f3n Spring Boot con la que estamos trabajando. L\u00e9elo despacio, revisando tambi\u00e9n el c\u00f3digo fuente, para entender los aspectos b\u00e1sicos (controladores, servicios, inyecci\u00f3n de dependencias, plantillas, tests) del funcionamiento de Spring Boot. En el siguiente documento se explica c\u00f3mo usar los formularios en Spring Boot: Handling Form Submission Lee tambi\u00e9n el siguiente documento, en el que se explica c\u00f3mo usar la validaci\u00f3n de los campos de un formulario de entrada. Validating Form Input El c\u00f3digo que hay en el ejemplo anterior es algo distinto al que estamos usando en clase. Por ejemplo, la forma de definir los controllers. Es mejor que uses como ejemplo de validaci\u00f3n el c\u00f3digo que hay en el repositorio domingogallardo/spring-boot-validate . Ver\u00e1s tambi\u00e9n ah\u00ed varios ejemplos de tests en los que se realiza una petici\u00f3n POST pasando par\u00e1metros y se obtiene informaci\u00f3n del modelo resultante, llamando al m\u00e9todo model() . El siguiente es un ejemplo de uno de los tests: @Test public void checkPersonInfoWhenNameTooShortThenFailure () throws Exception { mockMvc . perform ( post ( \"/\" ) . param ( \"name\" , \"R\" ) . param ( \"age\" , \"20\" )) . andExpect ( model (). hasErrors ()); } Debemos a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n que realice lo siguiente: Leer datos de un formulario usando Thymeleaf y realizar alguna validaci\u00f3n . Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Incluir al menos 2 tests: 1 de la capa de servicio 1 de la capa de presentaci\u00f3n usando MockMvc. En la p\u00e1gina principal de la aplicaci\u00f3n debe aparecer tu nombre y apellidos. Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra: Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma. N\u00famero par: lee un n\u00famero y comprueba si es par Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado. Cuando compruebes que los tests funcionan correctamente y que la aplicaci\u00f3n funciona bien en local, debes crear la m\u00e1quina Docker con la etiqueta final y probar que funciona bien en producci\u00f3n en el servidor de la asignatura.","title":"4. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#5-comandos-git","text":"Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en el documento Resumen de comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura.","title":"5. Comandos Git"},{"location":"01-intro-spring-boot/practica1.html#6-entrega","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada el martes 21 de septiembre. El mi\u00e9rcoles 22 de septiembre el profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de pr\u00e1cticas. Para realizar la entrega debes hacer lo siguiente: Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits a GitHub conforme se van realizando. Actualizar el fichero README.md con la URL del repositorio Docker Hub donde se ha subido la m\u00e1quina Docker final. A\u00f1adir una p\u00e1gina de documentaci\u00f3n doc/practica1.md en la que se explique la funcionalidad y el c\u00f3digo a\u00f1adido. Incluir en la documentaci\u00f3n la URL de los repositorios en GitHub y en Docker Hub. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho ./mvnw clean para eliminar los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de toda la semana y no dejar todo para el \u00faltimo d\u00eda). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"6. Entrega"},{"location":"02-todolist/practica2.html","text":"Pr\u00e1ctica 2: Aplicaci\u00f3n ToDoList \u00b6 1. Objetivos \u00b6 En pr\u00e1ctica 2 vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . Esta parte tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando los tableros del proyecto (en Trello y en GitHub). Al igual que en la pr\u00e1ctica 1 usaremos GitHub Classroom para crear un repositorio individual con el que realizar\u00e1s la pr\u00e1ctica. El proyecto base ser\u00e1 la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . En este repositorio se ha seguido una metodolog\u00eda similar a la que vamos a utilizar en este pr\u00e1ctica y puedes examinarlo para ver distintos elementos: Issues cerrados Pull Requests mezclados Tablero de issues Tablero Trello de historias de usuario Debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework. 2. Aplicaci\u00f3n inicial \u00b6 La aplicaci\u00f3n con la que vamos a trabajar es una t\u00edpica aplicaci\u00f3n ToDo que sirve para gestionar tareas pendientes. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es mads-todolist . 3. Metodolog\u00eda de desarrollo \u00b6 En cuanto a la metodolog\u00eda de desarrollo, en esta pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues, labels, milestones, etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java. Git \u00b6 Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto. Flujo de trabajo \u00b6 Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request. Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama main haciendo un pull request . Cuando se mezcle el PR en main el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub). Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Importante Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Note Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack o Confluence . Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias. 4. La aplicaci\u00f3n ToDoList \u00b6 La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 1. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo y prueba. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos. Configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : spring . application . name = mads - todolist spring . datasource . url = jdbc : h2 : mem : dev spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = update logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - dev . sql spring . datasource . initialization - mode = always Se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2). El par\u00e1metro spring.datasource.data define el fichero que contiene los datos iniciales que se van a cargar en la base de datos al arrancar la aplicaci\u00f3n. En este caso se trata del fichero datos-dev.sql : Fichero /src/main/resources/datos-dev.sql : /* Populate tables */ INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Base de datos H2 en memoria En esta pr\u00e1ctica vamos a trabajar \u00fanicamente con la base de datos en memoria. Esto significa que los datos que introduzcamos van a estar presentes mientras que la aplicaci\u00f3n est\u00e9 funcionando. Cuando matemos la aplicaci\u00f3n y la volvamos a reiniciar s\u00f3lo estar\u00e1n los datos iniciales, los datos que se cargan del fichero datos-dev.sql . En la pr\u00e1ctica 3 utilizaremos una base de datos real, que deberemos gestionar tambi\u00e9n en producci\u00f3n. En concreto, se tratar\u00e1 de una base de datos PostgresSQL. En el fichero de configuraci\u00f3n tambi\u00e9n se define la caracter\u00edstica de JPA spring.jpa.hibernate.ddl-auto que define c\u00f3mo se debe inicializar el esquema de datos de la aplicaci\u00f3n cuando haya un cambio en el c\u00f3digo fuente que define las entidades. En este caso tenemos un valor de update para indicar que se el esquema de datos debe actualizarse. En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n. Otras configuraciones \u00b6 Es posible definir otras configuraciones e indicar en el comando de ejecuci\u00f3n de la aplicaci\u00f3n Spring Boot qu\u00e9 fichero de configuraci\u00f3n usar. Lo veremos en la pr\u00e1ctica 3. En esta pr\u00e1ctica se define otra configuraci\u00f3n en el directorio de test, que es la que se carga cuando se lanzan los tests: Fichero src/test/resources/application.properties : spring . datasource . url = jdbc : h2 : mem : test spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = create logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - test . sql spring . datasource . initialization - mode = always La diferencia con el fichero de configuraci\u00f3n de desarrollo es el nombre de la fuente de datos, el modo del spring.jpa.hibernate.ddl-auto , que es create y el fichero de datos iniciales que se carga al ejecutar los tests. Gesti\u00f3n de persistencia con JPA \u00b6 Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate 5.3.17. Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades. Definici\u00f3n del modelo de datos \u00b6 El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario que se lista a continuaci\u00f3n define la tabla usuarios en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia @GeneratedValue(strategy = GenerationType.IDENTITY) que define una columna que se autoincrementa en cada operaci\u00f3n de inserci\u00f3n de un nuevo registro en la tabla. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario (en nuestro caso el correo electronico), los getters y setters de todas las propiedades (necesario para JPA) y los m\u00e9todos equals y hashCode para comparar usuarios. Los m\u00e9todos equals y hashCode son necesarios para buscar instancias de la entidad en colecciones y JPA los usa para no incluir instancias repetidas en los resultados de las queries. El m\u00e9todo equals proporcionado no es el que genera IntelliJ por defecto, sino que hay que considerar si la instancia ha sido ya vinculada a la base de datos o no. En el caso en que la instancia ya est\u00e9 vinculada a la base de datos, tendr\u00e1 una clave primaria asignada y \u00e9sta ser\u00e1 la que se usar\u00e1 para comparar. En el caso en que la instancia no est\u00e9 vinculada (se acaba de crear o la estamos usando para alguna parte de la l\u00f3gica de negocio y no se va a persistir) se comparan los atributos obligatorios (en este caso el correo electr\u00f3nico). Fichero src/main/java/madstodolist/model/Usuario.java : package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.Date ; import java.util.List ; import java.util.Objects ; @Entity @Table ( name = \"usuarios\" ) public class Usuario implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String email ; private String nombre ; private String password ; @Column ( name = \"fecha_nacimiento\" ) @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = \"usuario\" , fetch = FetchType . EAGER ) List < Tarea > tareas = new ArrayList < Tarea > (); // Constructor vac\u00edo necesario para JPA/Hibernate. // Lo hacemos privado para que no se pueda usar desde el c\u00f3digo de la aplicaci\u00f3n. Para crear un // usuario en la aplicaci\u00f3n habr\u00e1 que llamar al constructor p\u00fablico. Hibernate s\u00ed que lo puede usar, a pesar // de ser privado. private Usuario () {} // Constructor p\u00fablico con los atributos obligatorios. En este caso el correo electr\u00f3nico. public Usuario ( String email ) { this . email = email ; } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getNombre () { return nombre ; } public void setNombre ( String nombre ) { this . nombre = nombre ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public Date getFechaNacimiento () { return fechaNacimiento ; } public void setFechaNacimiento ( Date fechaNacimiento ) { this . fechaNacimiento = fechaNacimiento ; } public List < Tarea > getTareas () { return tareas ; } public void setTareas ( List < Tarea > tareas ) { this . tareas = tareas ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Usuario usuario = ( Usuario ) o ; if ( id != null && usuario . id != null ) // Si tenemos los ID, comparamos por ID return Objects . equals ( id , usuario . id ); // sino comparamos por campos obligatorios return email . equals ( usuario . email ); } @Override public int hashCode () { // Generamos un hash basado en los campos obligatorios return Objects . hash ( email ); } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La definici\u00f3n de Tarea es la siguiente: Fichero src/main/java/madstodolist/model/Tarea.java : package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.Objects ; @Entity @Table ( name = \"tareas\" ) public class Tarea implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String titulo ; @NotNull // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = \"usuario_id\" ) private Usuario usuario ; // Constructor vac\u00edo necesario para JPA/Hibernate. // Lo hacemos privado para que no se pueda usar desde el c\u00f3digo de la aplicaci\u00f3n. Para crear un // usuario en la aplicaci\u00f3n habr\u00e1 que llamar al constructor p\u00fablico. Hibernate s\u00ed que lo puede usar, a pesar // de ser privado. private Tarea () {} // Al crear una tarea la asociamos autom\u00e1ticamente a un // usuario. Actualizamos por tanto la lista de tareas del // usuario. public Tarea ( Usuario usuario , String titulo ) { this . usuario = usuario ; this . titulo = titulo ; usuario . getTareas (). add ( this ); } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getTitulo () { return titulo ; } public void setTitulo ( String titulo ) { this . titulo = titulo ; } public Usuario getUsuario () { return usuario ; } public void setUsuario ( Usuario usuario ) { this . usuario = usuario ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Tarea tarea = ( Tarea ) o ; return titulo . equals ( tarea . titulo ) && usuario . equals ( tarea . usuario ); } @Override public int hashCode () { return Objects . hash ( titulo , usuario ); } } Recuperaci\u00f3n eager y lazy de las colecciones \u00b6 Como hemos visto anteriormente, en la aplicaci\u00f3n se define la relaci\u00f3n uno-a-muchos entre usuarios y tareas: un usuario tiene muchas tareas. Por defecto, todas las relaciones a-muchos en JPA se definen de tipo LAZY . La caracter\u00edstica de los atributos marcados como lazy en JPA es que no se traen a memoria cuando se recupera la entidad, sino cuando se consultan expl\u00edcitamente accediendo al atributo. Para que se traigan a memoria la conexi\u00f3n con la base de datos debe estar abierta . Si ya se ha cerrado esa conexi\u00f3n (por ejemplo, se ha cerrado la transacci\u00f3n en el m\u00e9todo de servicio y se quiere acceder a la una lista de tareas de un usuario devuelto por el propio m\u00e9todo estando en el controller) se producir\u00e1 un error. Frente a la recuperaci\u00f3n lazy de colecciones, tambi\u00e9n existe la posibilidad de definir una colecci\u00f3n como de tipo EAGER . En este caso JPA se traer\u00e1 siempre a memoria todos los elementos. Es el caso de la relaci\u00f3n entre un usuario y sus tareas. En general, no es conveniente definir una relaci\u00f3n como eager porque puede provocar problemas de rendimiento en el caso en que haya muchos elementos relacionados. Pero si no hay muchos datos en la relaci\u00f3n y los vamos a usar con frecuencia, s\u00ed que es aconsejable usar el tipo EAGER para facilitar el manejo de la entidad. El c\u00f3digo queda como hemos visto anteriormente: @Entity public class Usuario { ... // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = \"usuario\" , fetch = FetchType . EAGER ) List < Tarea > tareas = new ArrayList < Tarea > (); ... } @Entity public class Tarea { ... // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = \"usuario_id\" ) private Usuario usuario ; ... } Clases Repository \u00b6 Spring define la clase gen\u00e9rica CrudRepository que contienen m\u00e9todos por defecto para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. public interface CrudRepository < T , ID extends Serializable > extends Repository < T , ID > { < S extends T > S save ( S entity ); Optional < T > findById ( ID primaryKey ); Iterable < T > findAll (); long count (); void delete ( T entity ); boolean existsById ( ID primaryKey ); // \u2026 more functionality omitted. } Para usar estos m\u00e9todos con nuestras entidades basta con definir interfaces que extienden esta clase gen\u00e9rica. Por ejemplo, la interfaz TareaRepository : Fichero src/main/java/madstodolist/model/TareaRepository.java : package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; public interface TareaRepository extends CrudRepository < Tarea , Long > {} Una vez definida la interfaz, ya podemos inyectar una instancia de repository y usarla en las clases de servicio. Por ejemplo, mostramos el m\u00e9todo de servicio que modifica el t\u00edtulo de una tarea: @Service public class TareaService { private UsuarioRepository usuarioRepository ; private TareaRepository tareaRepository ; @Autowired public TareaService ( UsuarioRepository usuarioRepository , TareaRepository tareaRepository ) { this . usuarioRepository = usuarioRepository ; this . tareaRepository = tareaRepository ; } ... @Transactional public Tarea modificaTarea ( Long idTarea , String nuevoTitulo ) { Tarea tarea = tareaRepository . findById ( idTarea ). orElse ( null ); if ( tarea == null ) { throw new TareaServiceException ( \"No existe tarea con id \" + idTarea ); } tarea . setTitulo ( nuevoTitulo ); tareaRepository . save ( tarea ); return tarea ; } ... } La anotaci\u00f3n @Transactional hace que las acciones sobre la base de datos se ejecuten de forma transaccional. Se abre la transacci\u00f3n al del m\u00e9todo y se cierra al final. Si sucede alguna excepci\u00f3n durante su ejecuci\u00f3n la transacci\u00f3n se deshace. En el cuerpo del m\u00e9todo se llama al m\u00e9todo findById del repositorio que realiza una b\u00fasqueda en la base de datos y al m\u00e9todo save que actualiza el valor de la entidad. La interfaz UsuarioRepository es similar. Fichero src/main/java/madstodolist/model/UsuarioRepository.java : package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; import java.util.Optional ; public interface UsuarioRepository extends CrudRepository < Usuario , Long > { Optional < Usuario > findByEmail ( String s ); } La diferencia es que se a\u00f1ade un m\u00e9todo findByEmail que hace que Spring construya autom\u00e1ticamente una consulta sobre la base de datos. Al usar como nombre del m\u00e9todo el nombre de la propiedad de la entidad ( email ), Spring puede generar autom\u00e1ticamente la consulta. Puedes consultar una lista completa de las traducciones de nombres de m\u00e9todos a consultas a la base de datos en este enlace de la documentaci\u00f3n de Spring Boot. Tambi\u00e9n es posible definir expl\u00edcitamente en el Repository la consulta a realizar a la base de datos utilizando la anotaci\u00f3n @Query . Puedes encontrar varios ejemplos en este enlace . Servicios \u00b6 La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Fichero src/main/java/madstodolist/service/UsuarioService.java : npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } private UsuarioRepository usuarioRepository ; @Autowired public UsuarioService ( UsuarioRepository usuarioRepository ) { this . usuarioRepository = usuarioRepository ; } @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional < Usuario > usuario = usuarioRepository . findByEmail ( eMail ); if ( ! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if ( ! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional < Usuario > usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( \"El usuario \" + usuario . getEmail () + \" ya est\u00e1 registrado\" ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( \"El usuario no tiene email\" ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( \"El usuario no tiene password\" ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Controllers \u00b6 Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : package madstodolist.controller ; import madstodolist.authentication.ManagerUserSesion ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import org.springframework.web.servlet.mvc.support.RedirectAttributes ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSesion managerUserSesion ; @GetMapping ( \"/login\" ) public String loginForm ( Model model ) { model . addAttribute ( \"loginData\" , new LoginData ()); return \"formLogin\" ; } @PostMapping ( \"/login\" ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , RedirectAttributes flash , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSesion . logearUsuario ( session , usuario . getId ()); return \"redirect:/usuarios/\" + usuario . getId () + \"/tareas\" ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( \"error\" , \"No existe usuario\" ); return \"formLogin\" ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( \"error\" , \"Contrase\u00f1a incorrecta\" ); return \"formLogin\" ; } return \"formLogin\" ; } @GetMapping ( \"/registro\" ) public String registroForm ( Model model ) { model . addAttribute ( \"registroData\" , new RegistroData ()); return \"formRegistro\" ; } @PostMapping ( \"/registro\" ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return \"registroForm\" ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( \"registroData\" , registroData ); model . addAttribute ( \"error\" , \"El usuario \" + registroData . geteMail () + \" ya existe\" ); return \"formRegistro\" ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return \"redirect:/login\" ; } @GetMapping ( \"/logout\" ) public String logout ( HttpSession session ) { session . setAttribute ( \"idUsuarioLogeado\" , null ); return \"redirect:/login\" ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Peticiones y rutas \u00b6 Las rutas que se definen en los controllers para realizar las acciones de la aplicaci\u00f3n son: LoginController GET /login : devuelve el formulario de login POST /login : realiza el login GET /registro : devuelve el formulario de registro POST /registro : realiza el registro GET /logout : realiza la salida del usuario de la aplicaci\u00f3n TareaController GET /usuarios/{id}/tareas/nueva : devuelve el formulario para a\u00f1adir una tarea al usuario con identificador {id} POST /usuarios/{id}/tareas/nueva : a\u00f1ade una tarea nueva a un usuario GET /usuarios/{id}/tareas : devuelve el listado de tareas de un usuario GET /tareas/{id}/editar\" : devuelve el formulario para editar una tarea POST /tareas/{id}/editar : a\u00f1ade una tarea modificada DELETE /tareas/{id} : realiza el borrado de una tarea Vistas \u00b6 Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:fragment = \"head (titulo)\" > < meta charset = \"UTF-8\" /> < title th:text = \"${titulo}\" ></ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" > </ head > < div th:fragment = \"javascript\" > < script th:src = \"@{/js/jquery.min.js}\" ></ script > < script th:src = \"@{/js/popper.min.js}\" ></ script > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > </ div > /html> Vemos que las vistas usan el framework CSS Bootstrap (en concreto, la versi\u00f3n Bootstrap 4.6 ) y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n. Fichero src/main/resources/templates/listaTareas.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"row mt-3\" > < div class = \"col\" > < h2 th:text = \"'Listado de tareas de ' + ${usuario.nombre}\" ></ h2 > </ div > </ div > < div class = \"row mt-3\" > < div class = \"col\" > < table class = \"table table-striped\" > < thead > < tr > < th > Id </ th > < th > Tarea </ th > < th > Acci\u00f3n </ th > </ tr > </ thead > < tbody > < tr th:each = \"tarea: ${tareas}\" > < td th:text = \"${tarea.id}\" ></ td > < td th:text = \"${tarea.titulo}\" ></ td > < td >< a class = \"btn btn-primary btn-xs\" th:href = \"@{/tareas/{id}/editar(id=${tarea.id})}\" /> editar </ a > < a class = \"btn btn-danger btn-xs\" href = \"#\" onmouseover = \"\" style = \"cursor: pointer;\" th:onclick = \"'del(\\'/tareas/' + ${tarea.id} + '\\')'\" > borrar </ a > </ td > </ tr > </ tbody > </ table > < p >< a class = \"btn btn-primary\" th:href = \"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\" > Nueva tarea </ a > < a class = \"btn btn-link\" href = \"/logout\" > Salir </ a ></ p > </ div > </ div > < div class = \"row mt-2\" > < div class = \"col\" > < div class = \"alert alert-success alert-dismissible fade show\" role = \"alert\" th:if = \"${!#strings.isEmpty(mensaje)}\" > < span th:text = \"${mensaje}\" ></ span > < button type = \"button\" class = \"close\" data-dismiss = \"alert\" aria-label = \"Close\" > < span aria-hidden = \"true\" > &times; </ span > </ button > </ div > </ div > </ div > </ div > </ div > < div th:replace = \"fragments::javascript\" /> <!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --> < script type = \"text/javascript\" > function del ( urlBorrar ) { if ( confirm ( '\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?' )) { $ . ajax ({ url : urlBorrar , type : 'DELETE' , success : function ( results ) { //refresh the page location . reload (); } }); } } </ script > </ body > </ html > La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea. Autenticaci\u00f3n y control de acceso \u00b6 En la aplicaci\u00f3n se realiza una autenticaci\u00f3n y un control de acceso muy sencillo usando la sesi\u00f3n HTTP. Esta sesi\u00f3n se implementa en Spring Boot con una cookie que se pasa desde el navegador hasta el servidor en cada petici\u00f3n. El manejo de la sesi\u00f3n es muy sencillo: es un diccionario en el que podemos a\u00f1adir datos. En el servidor podemos obtener los datos de la sesi\u00f3n consultando el diccionario. La implementaci\u00f3n de la autenticaci\u00f3n y del control de acceso se realiza con en la clase ManagerUserSesion : Fichero src/main/java/madstodolist/authentication/ManagerUserSesion.java : package madstodolist.authentication ; import org.springframework.stereotype.Component ; import javax.servlet.http.HttpSession ; @Component public class ManagerUserSesion { // A\u00f1adimos el id de usuario en la sesi\u00f3n HTTP para hacer // una autorizaci\u00f3n sencilla. En los m\u00e9todos de controllers // comprobamos si el id del usuario logeado coincide con el obtenido // desde la URL public void logearUsuario ( HttpSession session , Long idUsuario ) { session . setAttribute ( \"idUsuarioLogeado\" , idUsuario ); } // Si el usuario no est\u00e1 logeado se lanza una excepci\u00f3n public void comprobarUsuarioLogeado ( HttpSession session , Long idUsuario ) { Long idUsuarioLogeado = ( Long ) session . getAttribute ( \"idUsuarioLogeado\" ); if ( ! idUsuario . equals ( idUsuarioLogeado )) throw new UsuarioNoLogeadoException (); } } Se implementa como un componente Spring con la anotaci\u00f3n @Component , lo inyectamos en los controllers y lo mockeamos en los tests de los controllers. Pruebas manuales y autom\u00e1ticas \u00b6 Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/datos-dev.sql : INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Para los tests autom\u00e1ticos se cargan los datos definidos en el fichero datos-tests.sql . Fichero src/test/resources/datos-test.sql : INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'UsuarioEjemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : En los tests sobre repository se debe usar la anotaci\u00f3n @Transactional para definir el contexto transaccional en el que se realiza la llamada a las acciones sobre la base de datos. Por ejemplo: @Test @Transactional ( readOnly = true ) public void unUsuarioTieneUnaListaDeTareas () { // GIVEN // En el application.properties se cargan los datos de // prueba del fichero datos-test.sql Usuario usuario = usuarioRepository . findById ( 1L ). orElse ( null ); // WHEN Set < Tarea > tareas = usuario . getTareas (); // THEN assertThat ( tareas ). isNotEmpty (); } Tambi\u00e9n se realizan tests sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Hay que ser cuidadoso al hacer pruebas que afectan a la base de datos, porque podemos insertar o modificar datos que se comprueban en otros tests. Tenemos que tener cuidado en que cada test sea independiente de los dem\u00e1s. En Spring Boot una forma muy sencilla de asegurase de que un test no afecta a los dem\u00e1s es a\u00f1adir la anotaci\u00f3n @Transactional en los tests que modifican la base de datos. Spring Boot abre una transacci\u00f3n y al terminar el test la transacci\u00f3n se deshace y los datos de la base de datos quedan como estaban al principio. Por ejemplo: @Test @Transactional public void testNuevaTareaUsuario () { // GIVEN // En el application.properties se cargan los datos de prueba // del fichero datos-test.sql // WHEN Tarea tarea = tareaService . nuevaTareaUsuario ( 1L , \"Pr\u00e1ctica 1 de MADS\" ); // THEN Usuario usuario = usuarioService . findByEmail ( \"user@ua\" ); assertThat ( usuario . getTareas ()). contains ( tarea ); } Y tambi\u00e9n realizamos tests sobre los controllers: UsuarioWebTest.java TareaWebTest.java En los tests sobre los controllers se comprueba que el resultado de realizar un GET o un POST sobre los endpoints correspondientes devuelven un HTML que contiene alguna cadena que coincide con lo esperado. En estos tests tambi\u00e9n es posible usar los datos de la base de datos datos-test.sql o mockear los servicios para que devuelvan los datos que nos interesan. Por ejemplo, en el siguiente test se comprueba que cuando se hace un POST a la URL de login con un usuario registrado, se obtiene una redirecci\u00f3n a URL de la lista de tareas de ese usuario. @Test public void servicioLoginUsuarioOK () throws Exception { // GIVEN // Datos cargados de datos-test.sql this . mockMvc . perform ( post ( \"/login\" ) . param ( \"eMail\" , \"user@ua\" ) . param ( \"password\" , \"123\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( \"/usuarios/1/tareas\" )); } En el siguiente ejemplo, se mockea el ServicioTareas para comprobar que se ha llamada al m\u00e9todo nuevaTareaUsuario al hacer el POST que a\u00f1ade una tarea. Esto se hace al final del test con el m\u00e9todo verify . Tambi\u00e9n se mockea ManagerUserSesion para que no se lance la excepci\u00f3n de usuario no logeado. Y UsuarioService para trabajar con el mock en lugar de con el m\u00e9todo real y evitar que se tenga que llamar a la base de datos (de esta forma se acelera el test). @RunWith ( SpringRunner . class ) @SpringBootTest @AutoConfigureMockMvc public class TareaWebTest { @Autowired private MockMvc mockMvc ; @MockBean private UsuarioService usuarioService ; @MockBean private TareaService tareaService ; // Al mocker el managerUserSession, no lanza la excepci\u00f3n cuando // se intenta comprobar si un usuario est\u00e1 logeado @MockBean private ManagerUserSesion managerUserSesion ; @Test public void postNuevaTareaDevuelveRedirectYA\u00f1adeTarea () throws Exception { Usuario usuario = new Usuario ( \"Usuario\" ); usuario . setId ( 1L ); when ( usuarioService . findById ( 1L )). thenReturn ( usuario ); this . mockMvc . perform ( post ( \"/usuarios/1/tareas/nueva\" ) . param ( \"titulo\" , \"Estudiar examen MADS\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( \"/usuarios/1/tareas\" )); // Verificamos que se ha a\u00f1adido el m\u00e9todo para // a\u00f1adir una tarea con los par\u00e1metros correctos verify ( tareaService ). nuevaTareaUsuario ( 1L , \"Estudiar examen MADS\" ); } } 5. Antes de empezar la pr\u00e1ctica \u00b6 Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente tu repositorio mads-todolist-<usuario> en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la primera parte de la pr\u00e1ctica es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-21-22 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas. Descarga el proyecto y comprueba que se compila y ejecuta correctamente: $ git clone https://github.com/mads-ua/mads-todolist-<usuario>.git $ cd mads-todolist-<usuario> $ ./mvnw spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: Crea un tablero Trello p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial . 6. Desarrollo de la pr\u00e1ctica \u00b6 En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features: P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0. Versi\u00f3n 1.0.1 \u00b6 La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de . Tablero Trello \u00b6 Utilizaremos el tablero Trello para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una tarjeta para cada caracter\u00edstica. Cada caracter\u00edstica deber\u00e1 tener un n\u00famero y un t\u00edtulo. A\u00f1ade la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de : Cuando empecemos a trabajar en la historia de usuario moveremos la tarjeta a En marcha y cuando la hayamos terminado de testear e integrar en la rama principal la moveremos a Terminadas . Tablero de GitHub \u00b6 Configura el tablero de GitHub, poniendo como nombre ToDoList y seleccionando como plantilla Automated kanban . Elimina las tarjetas en la columna To do y a\u00f1ade la columna In pull request entre In progress y Done . En las columnas deber\u00e1n aparecer los issues del proyecto (y los PRs estar\u00e1n enlazados en ellos). GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. A continuaci\u00f3n mostramos la configuraci\u00f3n que usaremos: Deberemos mover manualmente las tarjetas en alg\u00fan caso, porque GitHub no podr\u00e1 detectar las condiciones. En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : moveremos a esta columna el issue abramos un PR y lo enlacemos con el issue. Manual. GitHub lo coloca autom\u00e1ticamente en esta columna. implementado por el pull request manualmente. Columna Done : pull requests cerrados. GitHub lo detecta autom\u00e1ticamente. Issues \u00b6 A\u00f1ade las etiquetas que vamos a usar inicialmente. Crea el primer issue, correspondiente a la feature a desarrollar P\u00e1gina Acerca de . Crea el milestone 1.0.1. y a\u00f1ade el issue a \u00e9l. A\u00f1ade el issue al proyecto (desde la p\u00e1gina del issue) y autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To do . Desarrollo \u00b6 Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama main . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y abriendo un terminal para trabajar con Git: En el terminal escribimos los comandos para crear la rama en la que desarrollaremos la feature y subirla: (main) $ git checkout -b acerca-de (acerca-de) $ git push -u origin acerca-de Primer commit \u00b6 Hacemos un primer commit. Cambia en pom.xml el nombre del proyecto ( artifactId ) a mads-todolist-<tu-nombre> y la versi\u00f3n a 1.0.1-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.1 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: (acerca-de) $ git status (comprobamos los ficheros que han cambiado) On branch acerca-de Your branch is up to date with 'origin/acerca-de'. Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: README.md modified: pom.xml no changes added to commit (use \"git add\" and/or \"git commit -a\") (acerca-de) $ git add . (acerca-de) $ git status (comprobamos que est\u00e1 listo para a\u00f1adirse en el commit) (acerca-de) $ git commit -m \"Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.1\" On branch acerca-de Your branch is up to date with 'origin/acerca-de'. Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: README.md modified: pom.xml (acerca-de) $ git push Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Segundo commit \u00b6 En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Acci\u00f3n en controller Vista A\u00f1ade los siguientes ficheros: Controller main/java/madstodolist/controller/HomeController.java package madstodolist.controller ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.GetMapping ; @Controller public class HomeController { @GetMapping ( \"/about\" ) public String about ( Model model ) { return \"about\" ; } } Vista main/resources/templates/about.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Acerca de')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"container-fluid\" > < h1 > ToDoList </ h1 > < ul > < li > Desarrollada por TU NOMBRE </ li > < li > Versi\u00f3n 1.0.1 (en desarrollo) </ li > < li > Fecha de release: pendiente de release </ li > </ ul > </ div > </ div > < div th:replace = \"fragments::javascript\" /> </ body > </ html > Prueba la p\u00e1gina accediendo a la url http://localhost:8080/about . A\u00f1ade un test que automatiza la comprobaci\u00f3n de que la URL /about debe devolver el nombre de la aplicaci\u00f3n. Test test/java/madstodolist/AcercaDeWebTest.java : package madstodolist ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; @SpringBootTest @AutoConfigureMockMvc public class AcercaDeWebTest { @Autowired private MockMvc mockMvc ; @Test public void getAboutDevuelveNombreAplicacion () throws Exception { this . mockMvc . perform ( get ( \"/about\" )) . andExpect ( content (). string ( containsString ( \"ToDoList\" ))); } } Puedes lanzar el test pulsando en IntelliJ con el bot\u00f3n derecho en el fichero (en el panel del proyecto) y seleccionando la opci\u00f3n Run AcercaDeWebTest . Puedes lanzar tambi\u00e9n todos los tests en el terminal para comprobar que no se ha roto nada. (acerca-de) $ ./mvnw test ... [INFO] [INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 21.879 s Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : (acerca-de) $ git add . (acerca-de) $ git status (comprueba que se han a\u00f1adido los ficheros) (acerca-de) $ git commit -m \"A\u00f1adida vista y controller 'about'\" (acerca-de) $ git push Tercer commit \u00b6 En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero formLogin.html : <a class=\"btn btn-link\" href=\"/registro\">Ir a registro</a> + <a class=\"btn btn-link\" href=\"/about\">Acerca de</a> </div> </form> Prueba que funciona correctamente, prueba los tests, haz el commit y s\u00fabelo a GitHub: (acerca-de) $ git status (acerca-de) $ git add . (acerca-de) $ git commit -m \"A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login'\" (acerca-de) $ git push Pull request \u00b6 Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( main ). Creaci\u00f3n del pull request \u00b6 Accede en GitHub a la rama acerca-de y comprueba que se han subido todos los cambios pulsando Compare . Aparecer\u00e1 la siguiente p\u00e1gina, con la informaci\u00f3n de los cambios que introducen todos los commits de la rama: Pulsa despu\u00e9s el bot\u00f3n Create pull request para crear el pull request. Escribe como t\u00edtulo del PR: A\u00f1adida p\u00e1gina 'Acerca de' y En el comentario escribe: Closes #1 Ver\u00e1s que al escribir #1 aparecer\u00e1 el nombre del issue. Si escribes s\u00f3lo # ver\u00e1s una lista de los \u00faltimos issues. De esta forma estamos enlazando el PR con el issue. Cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue. Tambi\u00e9n podremos acceder desde el issue al PR enlazado. Pulsa en el bot\u00f3n para crear el pull request. Debe quedar la siguiente pantalla en la que informa del PR reci\u00e9n creado: En el proyecto mueve la tarjeta con el issue a la columna In Pull Request . Ver\u00e1s que se ha a\u00f1adido en la parte inferior de la tarjeta un desplegable con la informaci\u00f3n sobre el PR enlazado. En este momento los compa\u00f1eros del equipo podr\u00edan revisar el pull request y el c\u00f3digo que se va a introducir. En la propia p\u00e1gina del pull request es posible conversar y realizar comentarios que puede aclarar el autor del PR. Y tambi\u00e9n es posible subir nuevos commits con modificaciones o ampliaciones correspondientes a las sugerencias indicadas. Haremos esto en futuras pr\u00e1cticas. Podemos ver que GitHub informa de que no hay conflictos con la rama main y que es posible hacer el merge en GitHub. Antes de pulsar el bot\u00f3n para realizar el merge, lanzamos en local (estando en la rama) para comprobar que no se ha roto nada y que los tests que se han a\u00f1adido pasan correctamente (en este caso no hemos a\u00f1adido ninguno). (acerca-de) $ ./mvnw test ... [INFO] [INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 21.879 s Veremos en la pr\u00f3xima pr\u00e1ctica c\u00f3mo configurar GitHub para que esta comprobaci\u00f3n se haga de forma autom\u00e1tica en GitHub. Pulsa el bot\u00f3n de Merge pull request (con la opci\u00f3n por defecto Create a merge commit ) y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Este merge lo has hecho en GitHub. Debes por \u00faltimo integrarlo en tu repositorio local. En el terminal: (acerca-de) $ git checkout main (main) $ git pull (bajamos los cambios) (main) $ git branch -d acerca-de (borramos la rama) (main) $ git remote prune origin (borramos referencias a rama remota) (main) $ git log --oneline --graph --all * 9527ae2 (HEAD -> main, origin/main, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login' | * 3fdfb83 A\u00f1adida ruta, vista y controller 'about' | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request. De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. El issue ligado al PR se habr\u00e1 cerrado autom\u00e1ticamente y en el tablero de proyecto debe haber cambiado la tarjeta a la columna Done . Actualizamos tablero Trello \u00b6 Actualizamos el tablero Trello moviendo la historia de usuario a la columna Terminadas . Release 1.0.1 \u00b6 Vamos a ver por \u00faltimo c\u00f3mo crear un release y poner en producci\u00f3n la aplicaci\u00f3n. Lo vamos a hacer ahora como ejemplo, creando el release 1.0.1 y tendr\u00e1s que hacerlo al final de la pr\u00e1ctica, creando el release 1.1.0. Para hacer el release haremos un commit directamente sobre la rama main (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release, cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros pom.xml y about.html Fichero pom.xml : <groupId>es.ua.mads</groupId> <artifactId>mads-todolist-dgallardo</artifactId> - <version>1.0.1-SNAPSHOT</version> + <version>1.0.1</version> Fichero about.html : <h1>ToDo List</h1> <ul> <h1>ToDo List</h1> <ul> <li>Desarrollada por Domingo Gallardo</li> - <li>Versi\u00f3n 1.0.1 (en desarrollo)</li> - <li>Fecha de release: pendiente de release</li> + <li>Versi\u00f3n 1.0.1</li> + <li>Fecha de release: 17/9/2018</li> </ul> } A\u00f1adimos el commit y lo subimos a GitHub (main) $ git add . (main) $ git commit -m \"Cambio de versi\u00f3n a 1.0.1\" (main) $ git push Y creamos la versi\u00f3n 1.0.1 en GitHub pulsando en el enlace Create a new release en la p\u00e1gina principal: Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. El resultado ser\u00e1: Puesta en producci\u00f3n \u00b6 Debes por \u00faltimo poner en producci\u00f3n la nueva versi\u00f3n, igual que hicimos en la pr\u00e1ctica 1, creando una imagen Docker, subi\u00e9ndola a Docker Hub y poni\u00e9ndola en ejecuci\u00f3n en el servidor de la asignatura. Para crear la imagen Docker: $ docker build -t <usuario-docker>/mads-todolist . Sube la m\u00e1quina a Docker Hub (autom\u00e1ticamente se etiquetara como latest ). Y etiqueta la m\u00e1quina docker con la versi\u00f3n 1.0.1 y s\u00fabela tambi\u00e9n. $ docker push <usuario-docker>/mads-todolist Using default tag: latest $ docker tag <usuario-docker>/mads-todolist <usuario-docker>/mads-todolist:1.0.1 $ docker push <usuario-docker>/mads-todolist:1.0.1 Con\u00e9ctate al servidor de la asignatura, descarga en \u00e9l la m\u00e1quina Docker y pon en producci\u00f3n la aplicaci\u00f3n. Comprueba que todo funciona correctamente y despu\u00e9s para y borra el contenedor y la imagen. En clase de pr\u00e1cticas deber\u00e1s hacer lo mismo y el profesor revisar\u00e1 que la aplicaci\u00f3n en producci\u00f3n funciona correctamente. Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0) \u00b6 El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. En alguna de las caracter\u00edsticas deber\u00e1s tambi\u00e9n realizar alg\u00fan test de la vista. Barra de men\u00fa \u00b6 La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login, registro y acerca de . La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar . de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n <nombre usuario> : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login. Listado de usuarios \u00b6 Si se introduce la URL /usuarios aparecer\u00e1 un listado de los usuarios registrados (identificador y correo electr\u00f3nico). Descripci\u00f3n de usuario \u00b6 En la lista de usuarios habr\u00e1 un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un usuario aparecer\u00e1n todos sus datos, menos la contrase\u00f1a. La ruta para obtener la descripci\u00f3n de un usuario ser\u00e1 /usuarios/:id . Usuario administrador (opcional) \u00b6 Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador acceder\u00e1 directamente a la lista de usuarios. Protecci\u00f3n de listado de usuario y descripci\u00f3n de usuario (opcional) \u00b6 Proteger las p\u00e1ginas con el listado de usuarios y la descripci\u00f3n de usuario para que s\u00f3lo las pueda consultar el administrador. En el caso en que un usuario no administrador intente acceder a esas p\u00e1ginas, devolver un c\u00f3digo de error HTTP \"No autorizado\" y un mensaje indicando que no se tiene suficiente permiso (de forma similar a como se gestionan los accesos a las p\u00e1ginas de tareas sin estar logeado). Bloqueo de usuarios por usuario administrador (opcional) \u00b6 A\u00f1adir en el listado de usuarios un bot\u00f3n para que el administrador pueda bloquear o habilitar el acceso a cada uno de los usuarios. Si el usuario tiene bloqueado el acceso cuando intente logearse aparecer\u00e1 un mensaje de error indic\u00e1ndoselo. 7. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n /doc/practica2.md en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica . Puedes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente . Por ejemplo, la documentaci\u00f3n podr\u00eda contener: Listado de nuevas clases y m\u00e9todos implementados. Listado de plantillas thyemeleaf a\u00f1adidas. Tests implementados. Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades implementadas. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 19 de octubre. El profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Correcto funcionamiento. Documentaci\u00f3n.","title":"Pr\u00e1ctica 2"},{"location":"02-todolist/practica2.html#practica-2-aplicacion-todolist","text":"","title":"Pr\u00e1ctica 2: Aplicaci\u00f3n ToDoList"},{"location":"02-todolist/practica2.html#1-objetivos","text":"En pr\u00e1ctica 2 vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . Esta parte tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando los tableros del proyecto (en Trello y en GitHub). Al igual que en la pr\u00e1ctica 1 usaremos GitHub Classroom para crear un repositorio individual con el que realizar\u00e1s la pr\u00e1ctica. El proyecto base ser\u00e1 la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . En este repositorio se ha seguido una metodolog\u00eda similar a la que vamos a utilizar en este pr\u00e1ctica y puedes examinarlo para ver distintos elementos: Issues cerrados Pull Requests mezclados Tablero de issues Tablero Trello de historias de usuario Debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework.","title":"1. Objetivos"},{"location":"02-todolist/practica2.html#2-aplicacion-inicial","text":"La aplicaci\u00f3n con la que vamos a trabajar es una t\u00edpica aplicaci\u00f3n ToDo que sirve para gestionar tareas pendientes. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es mads-todolist .","title":"2. Aplicaci\u00f3n inicial"},{"location":"02-todolist/practica2.html#3-metodologia-de-desarrollo","text":"En cuanto a la metodolog\u00eda de desarrollo, en esta pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues, labels, milestones, etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java.","title":"3. Metodolog\u00eda de desarrollo"},{"location":"02-todolist/practica2.html#git","text":"Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto.","title":"Git"},{"location":"02-todolist/practica2.html#flujo-de-trabajo","text":"Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request. Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama main haciendo un pull request . Cuando se mezcle el PR en main el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub). Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Importante Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Note Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack o Confluence . Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias.","title":"Flujo de trabajo"},{"location":"02-todolist/practica2.html#4-la-aplicacion-todolist","text":"La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 1. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo y prueba. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos.","title":"4. La aplicaci\u00f3n ToDoList"},{"location":"02-todolist/practica2.html#configuracion-de-la-aplicacion","text":"Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : spring . application . name = mads - todolist spring . datasource . url = jdbc : h2 : mem : dev spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = update logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - dev . sql spring . datasource . initialization - mode = always Se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2). El par\u00e1metro spring.datasource.data define el fichero que contiene los datos iniciales que se van a cargar en la base de datos al arrancar la aplicaci\u00f3n. En este caso se trata del fichero datos-dev.sql : Fichero /src/main/resources/datos-dev.sql : /* Populate tables */ INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Base de datos H2 en memoria En esta pr\u00e1ctica vamos a trabajar \u00fanicamente con la base de datos en memoria. Esto significa que los datos que introduzcamos van a estar presentes mientras que la aplicaci\u00f3n est\u00e9 funcionando. Cuando matemos la aplicaci\u00f3n y la volvamos a reiniciar s\u00f3lo estar\u00e1n los datos iniciales, los datos que se cargan del fichero datos-dev.sql . En la pr\u00e1ctica 3 utilizaremos una base de datos real, que deberemos gestionar tambi\u00e9n en producci\u00f3n. En concreto, se tratar\u00e1 de una base de datos PostgresSQL. En el fichero de configuraci\u00f3n tambi\u00e9n se define la caracter\u00edstica de JPA spring.jpa.hibernate.ddl-auto que define c\u00f3mo se debe inicializar el esquema de datos de la aplicaci\u00f3n cuando haya un cambio en el c\u00f3digo fuente que define las entidades. En este caso tenemos un valor de update para indicar que se el esquema de datos debe actualizarse. En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"02-todolist/practica2.html#gestion-de-persistencia-con-jpa","text":"Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate 5.3.17. Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades.","title":"Gesti\u00f3n de persistencia con JPA"},{"location":"02-todolist/practica2.html#servicios","text":"La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Fichero src/main/java/madstodolist/service/UsuarioService.java : npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } private UsuarioRepository usuarioRepository ; @Autowired public UsuarioService ( UsuarioRepository usuarioRepository ) { this . usuarioRepository = usuarioRepository ; } @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional < Usuario > usuario = usuarioRepository . findByEmail ( eMail ); if ( ! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if ( ! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional < Usuario > usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( \"El usuario \" + usuario . getEmail () + \" ya est\u00e1 registrado\" ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( \"El usuario no tiene email\" ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( \"El usuario no tiene password\" ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas.","title":"Servicios"},{"location":"02-todolist/practica2.html#controllers","text":"Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : package madstodolist.controller ; import madstodolist.authentication.ManagerUserSesion ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import org.springframework.web.servlet.mvc.support.RedirectAttributes ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSesion managerUserSesion ; @GetMapping ( \"/login\" ) public String loginForm ( Model model ) { model . addAttribute ( \"loginData\" , new LoginData ()); return \"formLogin\" ; } @PostMapping ( \"/login\" ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , RedirectAttributes flash , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSesion . logearUsuario ( session , usuario . getId ()); return \"redirect:/usuarios/\" + usuario . getId () + \"/tareas\" ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( \"error\" , \"No existe usuario\" ); return \"formLogin\" ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( \"error\" , \"Contrase\u00f1a incorrecta\" ); return \"formLogin\" ; } return \"formLogin\" ; } @GetMapping ( \"/registro\" ) public String registroForm ( Model model ) { model . addAttribute ( \"registroData\" , new RegistroData ()); return \"formRegistro\" ; } @PostMapping ( \"/registro\" ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return \"registroForm\" ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( \"registroData\" , registroData ); model . addAttribute ( \"error\" , \"El usuario \" + registroData . geteMail () + \" ya existe\" ); return \"formRegistro\" ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return \"redirect:/login\" ; } @GetMapping ( \"/logout\" ) public String logout ( HttpSession session ) { session . setAttribute ( \"idUsuarioLogeado\" , null ); return \"redirect:/login\" ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } }","title":"Controllers"},{"location":"02-todolist/practica2.html#vistas","text":"Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:fragment = \"head (titulo)\" > < meta charset = \"UTF-8\" /> < title th:text = \"${titulo}\" ></ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" > </ head > < div th:fragment = \"javascript\" > < script th:src = \"@{/js/jquery.min.js}\" ></ script > < script th:src = \"@{/js/popper.min.js}\" ></ script > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > </ div > /html> Vemos que las vistas usan el framework CSS Bootstrap (en concreto, la versi\u00f3n Bootstrap 4.6 ) y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n. Fichero src/main/resources/templates/listaTareas.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"row mt-3\" > < div class = \"col\" > < h2 th:text = \"'Listado de tareas de ' + ${usuario.nombre}\" ></ h2 > </ div > </ div > < div class = \"row mt-3\" > < div class = \"col\" > < table class = \"table table-striped\" > < thead > < tr > < th > Id </ th > < th > Tarea </ th > < th > Acci\u00f3n </ th > </ tr > </ thead > < tbody > < tr th:each = \"tarea: ${tareas}\" > < td th:text = \"${tarea.id}\" ></ td > < td th:text = \"${tarea.titulo}\" ></ td > < td >< a class = \"btn btn-primary btn-xs\" th:href = \"@{/tareas/{id}/editar(id=${tarea.id})}\" /> editar </ a > < a class = \"btn btn-danger btn-xs\" href = \"#\" onmouseover = \"\" style = \"cursor: pointer;\" th:onclick = \"'del(\\'/tareas/' + ${tarea.id} + '\\')'\" > borrar </ a > </ td > </ tr > </ tbody > </ table > < p >< a class = \"btn btn-primary\" th:href = \"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\" > Nueva tarea </ a > < a class = \"btn btn-link\" href = \"/logout\" > Salir </ a ></ p > </ div > </ div > < div class = \"row mt-2\" > < div class = \"col\" > < div class = \"alert alert-success alert-dismissible fade show\" role = \"alert\" th:if = \"${!#strings.isEmpty(mensaje)}\" > < span th:text = \"${mensaje}\" ></ span > < button type = \"button\" class = \"close\" data-dismiss = \"alert\" aria-label = \"Close\" > < span aria-hidden = \"true\" > &times; </ span > </ button > </ div > </ div > </ div > </ div > </ div > < div th:replace = \"fragments::javascript\" /> <!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --> < script type = \"text/javascript\" > function del ( urlBorrar ) { if ( confirm ( '\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?' )) { $ . ajax ({ url : urlBorrar , type : 'DELETE' , success : function ( results ) { //refresh the page location . reload (); } }); } } </ script > </ body > </ html > La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea.","title":"Vistas"},{"location":"02-todolist/practica2.html#pruebas-manuales-y-automaticas","text":"Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/datos-dev.sql : INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Para los tests autom\u00e1ticos se cargan los datos definidos en el fichero datos-tests.sql . Fichero src/test/resources/datos-test.sql : INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'UsuarioEjemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : En los tests sobre repository se debe usar la anotaci\u00f3n @Transactional para definir el contexto transaccional en el que se realiza la llamada a las acciones sobre la base de datos. Por ejemplo: @Test @Transactional ( readOnly = true ) public void unUsuarioTieneUnaListaDeTareas () { // GIVEN // En el application.properties se cargan los datos de // prueba del fichero datos-test.sql Usuario usuario = usuarioRepository . findById ( 1L ). orElse ( null ); // WHEN Set < Tarea > tareas = usuario . getTareas (); // THEN assertThat ( tareas ). isNotEmpty (); } Tambi\u00e9n se realizan tests sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Hay que ser cuidadoso al hacer pruebas que afectan a la base de datos, porque podemos insertar o modificar datos que se comprueban en otros tests. Tenemos que tener cuidado en que cada test sea independiente de los dem\u00e1s. En Spring Boot una forma muy sencilla de asegurase de que un test no afecta a los dem\u00e1s es a\u00f1adir la anotaci\u00f3n @Transactional en los tests que modifican la base de datos. Spring Boot abre una transacci\u00f3n y al terminar el test la transacci\u00f3n se deshace y los datos de la base de datos quedan como estaban al principio. Por ejemplo: @Test @Transactional public void testNuevaTareaUsuario () { // GIVEN // En el application.properties se cargan los datos de prueba // del fichero datos-test.sql // WHEN Tarea tarea = tareaService . nuevaTareaUsuario ( 1L , \"Pr\u00e1ctica 1 de MADS\" ); // THEN Usuario usuario = usuarioService . findByEmail ( \"user@ua\" ); assertThat ( usuario . getTareas ()). contains ( tarea ); } Y tambi\u00e9n realizamos tests sobre los controllers: UsuarioWebTest.java TareaWebTest.java En los tests sobre los controllers se comprueba que el resultado de realizar un GET o un POST sobre los endpoints correspondientes devuelven un HTML que contiene alguna cadena que coincide con lo esperado. En estos tests tambi\u00e9n es posible usar los datos de la base de datos datos-test.sql o mockear los servicios para que devuelvan los datos que nos interesan. Por ejemplo, en el siguiente test se comprueba que cuando se hace un POST a la URL de login con un usuario registrado, se obtiene una redirecci\u00f3n a URL de la lista de tareas de ese usuario. @Test public void servicioLoginUsuarioOK () throws Exception { // GIVEN // Datos cargados de datos-test.sql this . mockMvc . perform ( post ( \"/login\" ) . param ( \"eMail\" , \"user@ua\" ) . param ( \"password\" , \"123\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( \"/usuarios/1/tareas\" )); } En el siguiente ejemplo, se mockea el ServicioTareas para comprobar que se ha llamada al m\u00e9todo nuevaTareaUsuario al hacer el POST que a\u00f1ade una tarea. Esto se hace al final del test con el m\u00e9todo verify . Tambi\u00e9n se mockea ManagerUserSesion para que no se lance la excepci\u00f3n de usuario no logeado. Y UsuarioService para trabajar con el mock en lugar de con el m\u00e9todo real y evitar que se tenga que llamar a la base de datos (de esta forma se acelera el test). @RunWith ( SpringRunner . class ) @SpringBootTest @AutoConfigureMockMvc public class TareaWebTest { @Autowired private MockMvc mockMvc ; @MockBean private UsuarioService usuarioService ; @MockBean private TareaService tareaService ; // Al mocker el managerUserSession, no lanza la excepci\u00f3n cuando // se intenta comprobar si un usuario est\u00e1 logeado @MockBean private ManagerUserSesion managerUserSesion ; @Test public void postNuevaTareaDevuelveRedirectYA\u00f1adeTarea () throws Exception { Usuario usuario = new Usuario ( \"Usuario\" ); usuario . setId ( 1L ); when ( usuarioService . findById ( 1L )). thenReturn ( usuario ); this . mockMvc . perform ( post ( \"/usuarios/1/tareas/nueva\" ) . param ( \"titulo\" , \"Estudiar examen MADS\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( \"/usuarios/1/tareas\" )); // Verificamos que se ha a\u00f1adido el m\u00e9todo para // a\u00f1adir una tarea con los par\u00e1metros correctos verify ( tareaService ). nuevaTareaUsuario ( 1L , \"Estudiar examen MADS\" ); } }","title":"Pruebas manuales y autom\u00e1ticas"},{"location":"02-todolist/practica2.html#5-antes-de-empezar-la-practica","text":"Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente tu repositorio mads-todolist-<usuario> en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la primera parte de la pr\u00e1ctica es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-21-22 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas. Descarga el proyecto y comprueba que se compila y ejecuta correctamente: $ git clone https://github.com/mads-ua/mads-todolist-<usuario>.git $ cd mads-todolist-<usuario> $ ./mvnw spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: Crea un tablero Trello p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial .","title":"5. Antes de empezar la pr\u00e1ctica"},{"location":"02-todolist/practica2.html#6-desarrollo-de-la-practica","text":"En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features: P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.","title":"6. Desarrollo de la pr\u00e1ctica"},{"location":"02-todolist/practica2.html#version-101","text":"La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de .","title":"Versi\u00f3n 1.0.1"},{"location":"02-todolist/practica2.html#resto-de-la-practica-version-110","text":"El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. En alguna de las caracter\u00edsticas deber\u00e1s tambi\u00e9n realizar alg\u00fan test de la vista.","title":"Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0)"},{"location":"02-todolist/practica2.html#7-documentacion-entrega-y-evaluacion","text":"Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n /doc/practica2.md en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica . Puedes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente . Por ejemplo, la documentaci\u00f3n podr\u00eda contener: Listado de nuevas clases y m\u00e9todos implementados. Listado de plantillas thyemeleaf a\u00f1adidas. Tests implementados. Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades implementadas. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 19 de octubre. El profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Correcto funcionamiento. Documentaci\u00f3n.","title":"7. Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html","text":"Pr\u00e1ctica 3: Integraci\u00f3n con GitHub Actions y TDD \u00b6 En esta pr\u00e1ctica 3 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua usando las actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request . Despu\u00e9s definiremos una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests sobre la base de datos PostgreSQL . A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 9 de noviembre. 1. Desarrollo de la release 1.2.0 \u00b6 En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release . Pasos a seguir \u00b6 Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en main es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega. 2. Integraci\u00f3n continua con GitHub Actions \u00b6 GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions , Introduction to GitHub Actions y Building and testing Java with Maven . En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con main . Tests en los pull requests \u00b6 Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo ( workflows ) definidos en el directorio .github/workflows . GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main. El fichero de configuraci\u00f3n \u00b6 Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio .github/workflows . El fichero con el flujo de trabajo inicial lo llamaremos tests.yml : Fichero .github/workflows/tests.yml name: Tests on: push jobs: # El nombre del job es launch-test launch-tests: runs-on: ubuntu-latest # Todos los pasos se ejecutan en el contenedor openjda:8-jdk-alpine container: openjdk:8-jdk-alpine steps: # Hacemos un checkout del c\u00f3digo del repositorio - uses: actions/checkout@v2 # Y lanzamos los tests - name: Launch tests with Maven run: ./mvnw test Puntos interesantes a destacar: El nombre del flujo de trabajo es Tests . El nombre del job es launch-tests . Con la palabra clave on se define el evento que causa que se lance el flujo de trabajo. Es en cualquier commit subido a GitHub (push). En jobs se definen los trabajos en paralelo a realizar por el flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno. En runs-on se define la m\u00e1quina base sobre la que se van a ejecutar los siguientes pasos del flujo. En container se especifica el contenedor Docker que se va a usar para ejecutar los pasos del flujo de trabajo. En uses: actions/checkout@v2 se especifica que se obtenga la versi\u00f3n 2 de la acci\u00f3n llamada actions/checkout . Esta acci\u00f3n se descarga el repositorio en la m\u00e1quina especificada anteriormente y lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n. Por \u00faltimo, con el comando run: ./mvnw test se indica que el flujo de trabajo debe lanzar este comando, que es el que lanza los tests. Los nombres Tests y launch-tests son nombres arbitrarios que indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos sirven para localizar los distintos pasos. Builds en Actions \u00b6 En la pesta\u00f1a Actions de GitHub tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado. En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n. Pasos a seguir \u00b6 Crea un issue llamado Integraci\u00f3n continua con GitHub Actions . Abre una rama integracion-continua-actions , s\u00fabela a GitHub y abre un pull request. A\u00f1ade el fichero .github/workflows/tests.yml . Haz un commit y s\u00fabelo a GitHub. Comprueba que se pasan los tests y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build falla. Vuelve a realizar los cambios para corregirlos, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request , mezcl\u00e1ndolo con main . Se volver\u00e1n a lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. $ (integracion-continua-actions) git checkout main $ (main) git pull $ (main) git branch -d integracion-continua-actions $ (main) git remote prune origin 3. Configuraci\u00f3n de la aplicaci\u00f3n para usar una BD Postgres \u00b6 Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos Postgres en producci\u00f3n. Adem\u00e1s, te habr\u00e1s dado cuenta de que es muy engorroso probar la aplicaci\u00f3n con la base de datos de memoria. Tienes que volver a introducir todos los datos de prueba cada vez que paramos y ponemos en marcha la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a ver c\u00f3mo configurar la aplicaci\u00f3n para poder trabajar con una base datos Postgres, tanto en su ejecuci\u00f3n como en los tests. Para configurar la aplicaci\u00f3n vamos a utilizar los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos Postgres. La configuraci\u00f3n de tests con base de datos Postgres la utilizaremos para ejecutar los tests de integraci\u00f3n sobre la base de datos Postgres en el proceso de integraci\u00f3n continua de GitHub Actions. Para lanzar un servidor de base de datos Postgres usaremos Docker, de forma que no tendremos que realizar ninguna instalaci\u00f3n en nuestro ordenador. Ficheros de configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-postgres.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con Postgres. Estos ficheros de configuraci\u00f3n adicionales se cargan despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en application.properties . Cambios en los sentencias SQL de los datos iniciales \u00b6 Es posible que tengas que hacer alg\u00fan cambio en las sentencias SQL del fichero datos-test.sql para adaptarlas a la nueva base de datos Postgres. No ser\u00e1 necesario hacerlo en el fichero con datos iniciales datos-dev.sql porque cuando trabajemos la con base de datos real no vamos a cargar estos datos iniciales. Por ejemplo, un cambio que deber\u00e1s hacer ser\u00e1 eliminar las claves primarias de todos los registros, de forma que sea Postgres quien autogenere esas claves primarias. Por ejemplo, en el fichero datos-tests.sql en lugar de: INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); las nuevas sentencias deben ser: INSERT INTO usuarios ( email , nombre , password , fecha_nacimiento ) VALUES ( 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Lavar coche' , '1' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Renovar DNI' , '1' ); Si no se hace esto surgen problemas en los tests, porque Postgres no actualiza el \u00edndice de clave primaria y los nuevos registros que se crean en algunos tests entran en conflicto con claves primarias id\u00e9nticas ya existentes. Pasos a seguir \u00b6 Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con Postgres . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. $ (main) git checkout -b perfiles $ (perfiles) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.datasource.initialization-mode=never Este va a ser el perfil que activemos para utilizar la conexi\u00f3n con la BD Postgres. En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos mads , su usuario ( mads ) y contrase\u00f1a ( mads ) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.PostgreSQL9Dialect ). La propiedad spring.datasource.initialization-mode=never indica que no se debe cargar ning\u00fan fichero de datos inicial. Por esto, el fichero datos-dev.sql no se va a cargar en la base de datos, deber\u00e1s registrar un usuario inicial para poder probar la aplicaci\u00f3n. La ventaja es que al trabajar con la base de datos real todos los datos van a quedar grabados aunque se pare la aplicaci\u00f3n. Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero en src/test/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads_test spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect En este perfil la conexi\u00f3n se hace con una base de datos diferente: mads_test , para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. Recuerda que en el perfil por defecto resources/application.properties se define el valor de spring.jpa.hibernate.ddl-auto como create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver postgresql:42.2.22 . Tambi\u00e9n a\u00f1ade las l\u00edneas para poder especificar perfiles desde l\u00ednea de comando. La variable profiles se definir\u00e1 desde l\u00ednea de comando cuando se llame a Maven: Fichero pom.xml : <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.postgresql </groupId> <artifactId> postgresql </artifactId> <version> 42.2.22 </version> </dependency> <dependency> <groupId> org.springframework.boot </groupId> ... <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <profiles> ${profiles} </profiles> </configuration> </plugin> Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor Postgres en el puerto 5432 con el usuario mads , la contrase\u00f1a mads y la base de datos mads . Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: docker run -d -p 5432:5432 --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Docker se descarga la imagen postgres:13 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 5432 (no debe estar ocupado) y sobre la base de datos mads . Le da como nombre postgres-develop . Puedes ejecutar los siguientes comandos de Docker: $ docker container ls -a (comprueba todos los contenedores en marcha) $ docker container stop <nombre o id de contenedor> (para un contenedor) $ docker container start <nombre o id de contenedor> (pone en marcha un contenedor) $ docker container logs <mombre o id de contenedor> (muestra logs del contenedor) $ docker container rm nombre o id de contenedor> (elimina un contenedor) Arranca la aplicaci\u00f3n con el siguiente comando: ./mvnw spring-boot:run -D profiles=postgres Se activar\u00e1 el perfil postgres y se cargar\u00e1n las preferencias de src/main/resource/application.properties y src/main/resource/application-postgres.properties . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos utilizando por ejemplo el panel Database de IntelliJ : Tambi\u00e9n podemos arrancar la aplicaci\u00f3n con el perfil de postgres lanzando directamente el fichero JAR de la siguiente forma: $ ./mvnw package $ java -Dspring.profiles.active=postgres -jar target/*.jar Para lanzar la aplicaci\u00f3n desde IntelliJ trabajando con el nuevo perfil podemos seleccionar la opci\u00f3n Edit Configurations... del men\u00fa de configuraciones, duplicar la configuraci\u00f3n Application , renombr\u00e1ndola por Application Postgres y a\u00f1adir en el campo Active profiles el nombre del perfil nuevo que acabamos de crear postgres . Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop : $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e posgres:13 ... postgres-develop $ docker container stop postgres-develop Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker. Vamos ahora a preparar los tests para que se puedan lanzar con Postgres. Ser\u00e1n tests de integraci\u00f3n que trabajar\u00e1n con la base de datos real y, por tanto, su ejecuci\u00f3n ser\u00e1 m\u00e1s lenta que cuando los lanzamos con la base de datos de memoria H2. Modifica el fichero de datos datos-test.sql para eliminar la creaci\u00f3n expl\u00edcita de las claves primarias y que sea el propio Postgres el que las asigne: INSERT INTO usuarios ( email , nombre , password , fecha_nacimiento ) VALUES ( 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Lavar coche' , '1' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Renovar DNI' , '1' ); Lanzamos ahora otro contenedor con la base de datos de test ( mads_test ): docker run -d -p 5432:5432 --name postgres-test -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads_test postgres:13 Y lanzamos los tests usando el perfil postgres con la base de datos Postgres con el siguiente comando: ./mvnw -D spring.profiles.active=postgres test Nos conectamos con el panel Database de IntelliJ a la base de datos mads_test y comprobamos que los datos que hay en la base de datos corresponden con los introducidos en el fichero datos-test.sql que se cargan antes de ejecutar los tests. Podemos lanzar tambi\u00e9n los tests desde IntelliJ editando la configuraci\u00f3n de lanzamiento de test y a\u00f1adiendo la variable de entorno spring.profiles.active=postgres . Podr\u00edamos, por ejemplo, llamar a esta configuraci\u00f3n Tests con Postgres . Dado que las configuraciones de test y de ejecuci\u00f3n utilizan distintas bases de datos, debemos tener en funcionamiento la base de datos correspondiente a lo que queremos hacer en cada momento. Esto es muy f\u00e1cil usando los contenedores de Docker. Por ejemplo, podemos parar el contenedor Postgres con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: $ docker container ls -a $ docker container stop postgres-test $ docker container start postgres-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en main : $ (perfiles) git add . $ (perfiles) git commit -m \"A\u00f1adidos perfiles para trabajar con Postgres\" $ (perfiles) git push // Mezclamos el Pull Request en GitHub $ (perfiles) git checkout main $ (main) git pull $ (main) git branch -d perfiles $ (main) git remote prune origin 4. Tests de integraci\u00f3n en GitHub Actions \u00b6 Vamos a modificar la configuraci\u00f3n de GitHub Actions para conseguir un sistema de integraci\u00f3n continua que ejecute los tests de integraci\u00f3n usando la base de datos real Postgres. La ejecuci\u00f3n de los tests usando la base de datos de memoria H2 ser\u00e1 responsabilidad del desarrollador y se har\u00e1 en el entorno de trabajo local, tal y como se ha hecho desde la primera pr\u00e1ctica. Tests del desarrollador vs. tests de integraci\u00f3n \u00b6 Podemos considerar los tests que usan la base de datos real como tests de integraci\u00f3n y los tests que usan la base de datos en memoria como tests del desarrollador . No usamos el nombre de tests unitarios de forma consciente, para evitar conflictos con la nomenclatura. Cuando hablamos de tests del desarrollador nos referimos a tests que van a ejecutar continuamente los desarrolladores en su equipo local cuando est\u00e1n trabajando con la aplicaci\u00f3n y a\u00f1adiendo funcionalidades. Son tests r\u00e1pidos, que se pueden lanzar desde el propio IDE, y que deben ser ejecutados antes de cada commit. Frente a estos tests, los tests de integraci\u00f3n necesitan una configuraci\u00f3n adicional (poner en marcha la base de datos de test en nuestro caso) y se ejecutan menos frecuentemente. Vamos a actualizar GitHub Actions para que se lancen all\u00ed los tests usando la base de datos Postgres. De esta forma nosotros lanzaremos en local los tests que usan la BD de memoria y los tests de integraci\u00f3n se lanzar\u00e1n en GitHub cada vez que vaya a mezclarse un pull request. Acci\u00f3n para lanzar los tests con la BD postgres \u00b6 Para lanzar los tests de integraci\u00f3n en GitHub debemos modificar el fichero de configuraci\u00f3n del flujo de trabajo para que lance un contenedor de Postgres y despu\u00e9s se ejecuten los tests sobre ese contenedor. Para tener m\u00e1s flexibilidad en la configuraci\u00f3n de la conexi\u00f3n con Postgres vamos a modificar el perfil de Spring Boot, a\u00f1adiendo unas variables con unos valores por defecto que se pueden modificar definiendo su valor en variables de entorno con el mismo nombre. En concreto, definimos las variables POSTGRES_HOST , POSTGRES_PORT , DB_USER y DB_PASSWD . Fichero src/test/resources/application-postgres.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads_test spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect Ya podemos modificar el fichero del flujo de trabajo de la acci\u00f3n: Fichero .github/workflows/tests.yml : name: Integration tests on: push jobs: container-job: runs-on: ubuntu-latest container: openjdk:8-jdk-alpine services: # Etiqueta usada para acceder al contenedor del servicio postgres: # Imagen Docker Hub image: postgres:13 # Variables para arrancar Postgres env: POSTGRES_USER: mads POSTGRES_PASSWORD: mads POSTGRES_DB: mads_test # Definimos chequeos para esperar hasta que postgres ya ha comenzado options: >- --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5 steps: - uses: actions/checkout@v2 - name: Launch tests with Maven run: ./mvnw test -D spring.profiles.active=postgres env: POSTGRES_HOST: postgres Vemos que en la \u00faltima l\u00ednea se actualiza el par\u00e1metro POSTGRES_HOST usado por el perfil postgres para que la conexi\u00f3n se realice con el host postgres que es el que nombre que se ha definido en el servicio. Pasos a seguir \u00b6 Crea un nuevo issue llamado Tests de integraci\u00f3n en GitHub Actions . Crea la rama integracion-gh-actions . $ git checkout -b integracion-gh-actions $ git push -u origin integracion-gh-actions Modifica el fichero del perfil postgres de test tal y como se indica anteriormente, para usar variables de configuraci\u00f3n que puedan ser definidas mediante variables de entorno. Comprueba que siguen funcionando los tests lanzados sobre la base de datos usando los valores por defecto de las variables de entorno. // Nos aseguramos de que la base de datos que est\u00e1 en marcha // es la de test $ docker container ls CONTAINER ID IMAGE PORTS NAMES 411d8f2ea46c postgres:13 0.0.0.0:5432->5432/tcp postgres-test ./mvnw -D spring.profiles.active=postgres test Comprueba que podemos modificar los par\u00e1metros definidos en las variables de entorno. Por ejemplo, si se cambia el nombre del host de la conexi\u00f3n con la base de datos los tests deben de fallar: $ ./mvnw -D spring.profiles.active=postgres -D POSTGRES_HOST=postgres test // Aparecer\u00e1n errores debidos a que no se puede conectar con el // host postgres: org.postgresql.util.PSQLException: El intento de conexi\u00f3n fall\u00f3. ... Caused by: java.net.UnknownHostException: postgres Crea un commit, s\u00fabelo a GitHub y crea el Pull Request $ git add . $ git commit -m \"A\u00f1adidas variables al perfil de test postgres\" $ git push Modifica el fichero del flujo de trabajo de la acci\u00f3n de GitHub, tal y como se indica anteriormente. Haz un commit, s\u00fabelo a GitHub y comprueba que los tests pasan correctamente y se lanzan all\u00ed usando la base de datos postgres. Una vez comprobado que funcionan los tests de integraci\u00f3n en GitHub, mezclamos el pull request y lo descargamos a local. Comprobamos que tambi\u00e9n se lanzan los tests en el commit de merge en GitHub. Con esto ya tenemos completado un sistema de integraci\u00f3n continua y GitHub se encargar\u00e1 de ejecutar todos los tests en un modo de integraci\u00f3n, usando la base de datos Postgres. 5. TDD \u00b6 En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta. 008 Listado de equipos \u00b6 La descripci\u00f3n de la historia de usuario es la siguiente: Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el enlace del nombre del equipo nos iremos a una p\u00e1gina con un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de dentro a fuera (desde el repository hasta el controller). Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional. Pasos a seguir \u00b6 Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea dos issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo. Primer commit - Test y c\u00f3digo Entidad Equipo \u00b6 El primer test es para crear la entidad Equipo . Por ahora s\u00f3lo creamos la clase Java, sin las anotaciones JPA. Un equipo Fichero src/test/java/madstodolist/EquipoTest.java : package madstodolist ; // imports @SpringBootTest public class EquipoTest { @Test public void crearEquipo () { Equipo equipo = new Equipo ( \"Proyecto P1\" ); assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); } } Escribe el c\u00f3digo necesario para que pase el test. No debes escribir c\u00f3digo de m\u00e1s, s\u00f3lo el c\u00f3digo m\u00ednimo para que el test pase . Haz un commit que contenga el test y el c\u00f3digo y s\u00fabelo a la rama remota. Segundo test - Entidad en base de datos \u00b6 Con el segundo test queremos conseguir que funcione JPA con la entidad Equipo y que podamos usar una tabla de equipos en la base de datos, en la que podamos guardar entidades equipo . Para comprobar que la entidad se ha guardado correctamente, comprobaremos se ha actualizando su identificador. Lo hacemos a\u00f1adiendo el siguiente test: @Autowired private EquipoRepository equipoRepository ; @Test @Transactional public void grabarEquipo () { // GIVEN Equipo equipo = new Equipo ( \"Proyecto P1\" ); // WHEN equipoRepository . save ( equipo ); // THEN assertThat ( equipo . getId ()). isNotNull (); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Tercer test - Definici\u00f3n de igualdad entre equipos \u00b6 Ahora que hemos introducido el id del equipo escribimos un test para comprobar que dos equipos son iguales. Debes escribir el c\u00f3digo de los m\u00e9todos equals y hashCode (necesario este \u00faltimo para que funcione correctamente la comprobaci\u00f3n de igualdades en las colecciones). Hacemos los tests para que el equals funcione de la siguiente forma: Si alguno de los dos equipos no tiene id (es null ), entonces se deben comparar sus nombres. Ahora bien, si los dos equipos tienen id , entonces se deben comparar esos id \". Puedes guiarte por la implementaci\u00f3n de equals y hashCode en Usuario . @Test public void comprobarIgualdadEquipos () { // GIVEN // Creamos tres equipos sin id, s\u00f3lo con el nombre Equipo equipo1 = new Equipo ( \"Proyecto P1\" ); Equipo equipo2 = new Equipo ( \"Proyecto P2\" ); Equipo equipo3 = new Equipo ( \"Proyecto P2\" ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isNotEqualTo ( equipo2 ); assertThat ( equipo2 ). isEqualTo ( equipo3 ); // WHEN // A\u00f1adimos identificadores y comprobamos igualdad por identificadores equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isEqualTo ( equipo2 ); assertThat ( equipo2 ). isNotEqualTo ( equipo3 ); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Cuarto test - Buscar equipo en base de datos \u00b6 Escribimos ahora un test para recuperar equipos por su identificador de la base de datos. A\u00f1adimos un equipo a la tabla en el fichero datos-test.sql para poder comprobar que funciona correctamente. A\u00f1adimos en el fichero src/test/java/resources/datos-test.sql : INSERT INTO tareas (titulo, usuario_id) VALUES('Renovar DNI', '1'); + INSERT INTO equipos (nombre) VALUES('Proyecto P1'); Test: @Test public void comprobarRecuperarEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo ). isNotNull (); assertThat ( equipo . getId ()). isEqualTo ( 1L ); assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); } Comprueba el test y si es necesario escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Quinto test - Relaci\u00f3n muchos-a-muchos entre equipos y usuarios \u00b6 Vamos ahora a dise\u00f1ar un test que introduzca la relaci\u00f3n entre equipos y usuarios. Debe ser una relaci\u00f3n muchos-a-muchos: un equipo contiene muchos usuarios y un usuario puede pertenecer a 0, 1 o muchos equipos. Para definir la relaci\u00f3n, JPA utiliza una tabla (la llamamos equipo_usuario ) en la que cada fila va a representar una relaci\u00f3n de un usuario con un equipo. Las columnas definen las claves ajenas que contienen el identificador de equipo y el del usuario. Para definir el test, creamos una relaci\u00f3n en la base de datos de prueba, en la que definimos que el equipo 1 tiene como usuario al usuario 1: INSERT INTO tareas (titulo, usuario_id) VALUES('Renovar DNI', '1'); INSERT INTO equipos (nombre) VALUES('1', 'Proyecto P1'); + INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES('1', '1'); Y comprobamos que se el usuario y equipo devuelto por cada clase repository tienen actualizada esa relaci\u00f3n: @Autowired private UsuarioRepository usuarioRepository ; @Test @Transactional public void comprobarRelacionBaseDatos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); Usuario usuario = usuarioRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo . getUsuarios ()). hasSize ( 1 ); assertThat ( equipo . getUsuarios ()). contains ( usuario ); assertThat ( usuario . getEquipos ()). hasSize ( 1 ); assertThat ( usuario . getEquipos ()). contains ( equipo ); } Para que este test funcione hay que crear la relaci\u00f3n muchos-a-muchos entre equipos y usuarios. Es necesario definir la anotaci\u00f3n @ManyToMany para indicar a JPA c\u00f3mo construir las tablas en la base de datos. En Equipo.java definimos la tabla en la que se va a guardar la relaci\u00f3n, e indicamos el papel de cada una de sus dos columnas. Tambi\u00e9n creamos el getter para obtener los usuarios. Fichero src/main/java/madstodolist/model/Equipo.java : + private String nombre; + // Declaramos el tipo de recuperaci\u00f3n como LAZY. + // No har\u00eda falta porque es el tipo por defecto en una + // relaci\u00f3n a muchos. + // Al recuperar un equipo NO SE RECUPERA AUTOM\u00c1TICAMENTE + // la lista de usuarios. S\u00f3lo se recupera cuando se accede al + // atributo 'usuarios'; entonces se genera una query en la + // BD que devuelve todos los usuarios del equipo y rellena el + // atributo. + + @ManyToMany(fetch = FetchType.LAZY) + @JoinTable(name = \"equipo_usuario\", + joinColumns = { @JoinColumn(name = \"fk_equipo\") }, + inverseJoinColumns = {@JoinColumn(name = \"fk_usuario\")}) + Set<Usuario> usuarios = new HashSet<>(); ... public void setId(Long id) { this.id = id; } + public Set<Usuario> getUsuarios() { + return usuarios; + } En el fichero Usuario.java definimos la parte inversa de la relaci\u00f3n. El mappedBy indica que la especificaci\u00f3n de la tabla join est\u00e1 en el otro lado de la relaci\u00f3n. Fichero src/main/java/madstodolist/model/Usuario.java : @OneToMany(mappedBy = \"usuario\", fetch = FetchType.EAGER) Set<Tarea> tareas = new HashSet<>(); + @ManyToMany(mappedBy = \"usuarios\") + Set<Equipo> equipos = new HashSet<>(); ... + public Set<Equipo> getEquipos() { + return equipos; + } Comprueba el test, haz un commit en la rama y s\u00fabelo a GitHub. Sexto test - listado de equipos \u00b6 Ya por fin tenemos todo lo necesario para definir un test para obtener una lista de equipos en el repository : Actualizamos la base de datos de prueba con otro equipo: INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES('1', '1'); + INSERT INTO equipos (nombre) VALUES('Proyecto A1'); Y a\u00f1adimos el test. Queremos que el tipo devuelto por el repository sea List . @Test public void comprobarFindAll () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List < Equipo > equipos = equipoRepository . findAll (); // THEN assertThat ( equipos ). hasSize ( 2 ); } La soluci\u00f3n consiste en a\u00f1adir el m\u00e9todo findAll en la interfaz p EquipoRepository , definiendo el tipo devuelto como List . Spring Boot se encarga de construir autom\u00e1ticamente la implementaci\u00f3n de este m\u00e9todo. Fichero EquipoRepository.java : + import java.util.List; public interface EquipoRepository extends CrudRepository<Equipo, Long> { + public List<Equipo> findAll(); } S\u00e9ptimo test - M\u00e9todo de servicio para el listado de equipos \u00b6 \u00a1Y por fin llegamos a la capa de servicio! Creamos el test que nos obliga a codificar en esa capa el m\u00e9todo que lista todos los equipos existentes. Lo llamamos findAllOrderedByName() para indicar que queremos que el resultado sea una lista ordenada por los nombres de los equipos. Fichero src/test/java/madstodolist/EquipoServiceTest.java : package madstodolist ; // imports @SpringBootTest public class EquipoServiceTest { @Autowired EquipoService equipoService ; @Test public void obtenerListadoEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List < Equipo > equipos = equipoService . findAllOrderedByName (); // THEN assertThat ( equipos ). hasSize ( 2 ); assertThat ( equipos . get ( 0 ). getNombre ()). isEqualTo ( \"Proyecto A1\" ); assertThat ( equipos . get ( 1 ). getNombre ()). isEqualTo ( \"Proyecto P1\" ); } } Escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Octavo test - M\u00e9todo de servicio para recuperar un equipo \u00b6 Vamos a centrar este test en la forma de traer a memoria los objetos que participan en la relaci\u00f3n USUARIO-EQUIPO . En JPA hay dos formas de definir una relaci\u00f3n a-muchos: EAGER : Si una relaci\u00f3n a-muchos es EAGER , cuando la clase repository devuelve un objeto (ya sea al recuperarlo individualmente, o en una consulta en la que se recupera una colecci\u00f3n), se obtienen tambi\u00e9n de la base de datos todos los objetos con los que est\u00e1 relacionado. Por ejemplo, en la pr\u00e1ctica tenemos definida de esta forma la relaci\u00f3n entre usuarios y tareas. LAZY : Si una relaci\u00f3n a-muchos es LAZY , cuando la clase repository devuelve un objeto, no recupera de la base de datos los objetos relacionados. S\u00f3lo lo hace cuando se accede a la colecci\u00f3n que contiene la relaci\u00f3n. Entonces es cuando se realiza la consulta a la base de datos y se traen estos objetos a memoria. Si estos objetos tienen otras relaciones se traer\u00e1n a memoria o no dependiendo de si son EAGER o LAZY . Para que funcione la recuperaci\u00f3n perezosa debe estar abierta la conexi\u00f3n con la base de datos en el momento en que se accede a la colecci\u00f3n. Para ello es muy importante la etiqueta @Transactional . Cuando ponemos esta etiqueta en los m\u00e9todos de las clases de servicio se garantiza que todo el m\u00e9todo se realiza en una \u00fanica transacci\u00f3n. Por ello, al finalizar el m\u00e9todo se cerrar\u00e1 la conexi\u00f3n con la base de datos y el objeto que se devolver\u00e1 al controller estar\u00e1 desconectado de la base de datos , por lo que la recuperaci\u00f3n perezosa no funcionar\u00e1 en el controller . En el caso de la relaci\u00f3n USUARIO-EQUIPO vamos a definir el siguiente dise\u00f1o: La relaci\u00f3n entre un usuario y sus equipos ser\u00e1 EAGER . Cuando recuperemos un usuario, recuperaremos tambi\u00e9n la informaci\u00f3n de todos los equipos en los que participa. La relaci\u00f3n entre un equipo y sus usuarios ser\u00e1 LAZY . Esto es muy importante. Si no lo hici\u00e9ramos as\u00ed \u00a1podr\u00edamos f\u00e1cilmente traernos a memoria toda la base de datos!. Un equipo recuperar\u00eda todos sus usuarios, que tambi\u00e9n pueden estar en otros equipos, que a su vez tambi\u00e9n se traer\u00edan a memoria. Vamos entonces a definir un test que sirve para crear el m\u00e9todo de servicio que recupera un equipo y que se asegura de que la relaci\u00f3n entre equipos y usuarios es LAZY . Fichero src/test/java/madstodolist/EquipoServiceTest.java : @Test public void obtenerEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoService . findById ( 1L ); // THEN assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); // Comprobamos que la relaci\u00f3n con Usuarios es lazy: al // intentar acceder a la colecci\u00f3n de usuarios se debe lanzar una // excepci\u00f3n de tipo LazyInitializationException. assertThatThrownBy (() -> { equipo . getUsuarios (). size (); }). isInstanceOf ( LazyInitializationException . class ); } Comprueba si hay que modificar el c\u00f3digo, haz un commit y s\u00fabelo a GitHub. Noveno test - comprobaci\u00f3n de recuperaci\u00f3n eager de equipos \u00b6 Hacemos ahora un test para que un usuario recupere de forma eager sus equipos: Fichero src/test/java/madstodolist/EquipoServiceTest.java : @Test public void comprobarRelacionUsuarioEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Usuario usuario = usuarioService . findById ( 1L ); // THEN assertThat ( usuario . getEquipos ()). hasSize ( 1 ); } Modifica el c\u00f3digo para que el test pase, haz un commit y s\u00fabelo a GitHub. D\u00e9cimo test - M\u00e9todo de servicio para obtener los usuarios de un equipo \u00b6 El \u00faltimo test que sirve para definir el m\u00e9todo de servicio usuariosEquipo(Long idEquipo) que devuelve la lista de usuarios de un equipo. Despu\u00e9s de comprobar que la lista que se devuelve es correcta, volvemos a comprobar que la relaci\u00f3n entre usuarios y equipos es EAGER , esto es, que desde un usuario se puede obtener la lista de equipos a los que pertenece. @Test public void obtenerUsuariosEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List < Usuario > usuarios = equipoService . usuariosEquipo ( 1L ); // THEN assertThat ( usuarios ). hasSize ( 1 ); assertThat ( usuarios . get ( 0 ). getEmail ()). isEqualTo ( \"user@ua\" ); // Comprobamos que la relaci\u00f3n entre usuarios y equipos es eager // Primero comprobamos que la colecci\u00f3n de equipos tiene 1 elemento assertThat ( usuarios . get ( 0 ). getEquipos ()). hasSize ( 1 ); // Y despu\u00e9s que el elemento es el equipo Proyecto P1 assertThat ( usuarios . get ( 0 ). getEquipos (). stream (). findFirst (). get (). getNombre ()). isEqualTo ( \"Proyecto P1\" ); } } Escribe el c\u00f3digo necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Cierre del issue \u00b6 Cuando hayas terminado todos los ciclos de TDD anteriores habr\u00e1s terminado el issue y testeado e implementado los m\u00e9todos necesarios para la clase de servicio que gestiona el listado de equipos y usuarios de esos equipos. Crea un pull request que cierre el issue , comprueba que GitHub Actions pasa correctamente los tests e int\u00e9gralo en main en GitHub. Baja los cambios al repositorio local. Vista y controller listado de equipos \u00b6 Abre un nuevo issue para implementar el controller y las vistas que permitan listar los equipos y consultar sus miembros (por ejemplo, pulsando en un enlace en el nombre del equipo o con un bot\u00f3n en el listado). Realiza el desarrollo del issue usando varios commits en los que a\u00f1adas las funcionalidades poco a poco. No hace falta que hagas TDD, pero a\u00f1ade al menos un test por cada m\u00e9todo del controller. Resto de historias de usuario \u00b6 Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. Importante detalle de implementaci\u00f3n En una relaci\u00f3n muchos-a-muchos como la que existe entre Usuario y Equipo cuando se a\u00f1ade un usuario a un equipo hay que actualizar ambos lados de la relaci\u00f3n, porque JPA/Hibernate no lo hace autom\u00e1ticamente. Hay que a\u00f1adir el usuario a la colecci\u00f3n de usuarios del equipo y tambi\u00e9n a\u00f1adir el equipo a la colecci\u00f3n de equipos del usuario. Lo mismo habr\u00eda que hacer cuando se elimina un usuario de un equipo. 010 Gesti\u00f3n de equipos (opcional) : Como administrador cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Pasos a seguir \u00b6 Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica. 6. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e1s a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica3.md en la que, al igual que en la pr\u00e1ctica anterior, debes realizar una breve documentaci\u00f3n t\u00e9cnica de lo implementado en las historias de usuario 009 y 010. En la documentaci\u00f3n debes incluir tambi\u00e9n una captura de pantalla en la que se muestren las tablas de la base de datos de desarrollo Postgres en la versi\u00f3n final de la aplicaci\u00f3n. Puedes mostrar, por ejempo, una pantalla con el panel Database de IntelliJ o la herramienta que hayas utilizado. Basta solo con una captura de la base de datos de desarrollo, no hace falta mostrar la base de datos de test. Por ejemplo, puedes incluir en la documentaci\u00f3n lo siguiente. Los puntos 2 en adelante son sobre las historias de usuario 009 y 010 . Pantalla de la base de datos Postgres. Rutas (endpoints) definidas para las acciones y, para cada endpoint o grupo de endpoints, explicaci\u00f3n sobre: Clases y m\u00e9todos Plantillas thymeleaf Tests Explicaci\u00f3n de algunos fragmentos de c\u00f3digo fuente que consideres interesante en las nuevas funcionalidades implementadas. Intenta que el documento tenga un formato limpio y se pueda leer f\u00e1cilmente. Para eso utiliza los bloques de c\u00f3digo de Markdown. Puedes mirar como ejemplo el c\u00f3digo Markdown de estas pr\u00e1cticas. Por ejemplo, el c\u00f3digo Markdown de la introducci\u00f3n a Spring Boot se puede ver pulsando el bot\u00f3n Raw . Ver\u00e1s el texto Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de entrega es el martes 10 de noviembre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"Pr\u00e1ctica 3"},{"location":"03-pruebas-tdd/integration-tdd.html#practica-3-integracion-con-github-actions-y-tdd","text":"En esta pr\u00e1ctica 3 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua usando las actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request . Despu\u00e9s definiremos una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests sobre la base de datos PostgreSQL . A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 9 de noviembre.","title":"Pr\u00e1ctica 3: Integraci\u00f3n con GitHub Actions y TDD"},{"location":"03-pruebas-tdd/integration-tdd.html#1-desarrollo-de-la-release-120","text":"En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release .","title":"1. Desarrollo de la release 1.2.0"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir","text":"Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en main es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#2-integracion-continua-con-github-actions","text":"GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions , Introduction to GitHub Actions y Building and testing Java with Maven . En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con main .","title":"2. Integraci\u00f3n continua con GitHub Actions"},{"location":"03-pruebas-tdd/integration-tdd.html#tests-en-los-pull-requests","text":"Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo ( workflows ) definidos en el directorio .github/workflows . GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main.","title":"Tests en los pull requests"},{"location":"03-pruebas-tdd/integration-tdd.html#el-fichero-de-configuracion","text":"Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio .github/workflows . El fichero con el flujo de trabajo inicial lo llamaremos tests.yml : Fichero .github/workflows/tests.yml name: Tests on: push jobs: # El nombre del job es launch-test launch-tests: runs-on: ubuntu-latest # Todos los pasos se ejecutan en el contenedor openjda:8-jdk-alpine container: openjdk:8-jdk-alpine steps: # Hacemos un checkout del c\u00f3digo del repositorio - uses: actions/checkout@v2 # Y lanzamos los tests - name: Launch tests with Maven run: ./mvnw test Puntos interesantes a destacar: El nombre del flujo de trabajo es Tests . El nombre del job es launch-tests . Con la palabra clave on se define el evento que causa que se lance el flujo de trabajo. Es en cualquier commit subido a GitHub (push). En jobs se definen los trabajos en paralelo a realizar por el flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno. En runs-on se define la m\u00e1quina base sobre la que se van a ejecutar los siguientes pasos del flujo. En container se especifica el contenedor Docker que se va a usar para ejecutar los pasos del flujo de trabajo. En uses: actions/checkout@v2 se especifica que se obtenga la versi\u00f3n 2 de la acci\u00f3n llamada actions/checkout . Esta acci\u00f3n se descarga el repositorio en la m\u00e1quina especificada anteriormente y lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n. Por \u00faltimo, con el comando run: ./mvnw test se indica que el flujo de trabajo debe lanzar este comando, que es el que lanza los tests. Los nombres Tests y launch-tests son nombres arbitrarios que indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos sirven para localizar los distintos pasos.","title":"El fichero de configuraci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html#builds-en-actions","text":"En la pesta\u00f1a Actions de GitHub tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado. En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n.","title":"Builds en Actions"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_1","text":"Crea un issue llamado Integraci\u00f3n continua con GitHub Actions . Abre una rama integracion-continua-actions , s\u00fabela a GitHub y abre un pull request. A\u00f1ade el fichero .github/workflows/tests.yml . Haz un commit y s\u00fabelo a GitHub. Comprueba que se pasan los tests y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build falla. Vuelve a realizar los cambios para corregirlos, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request , mezcl\u00e1ndolo con main . Se volver\u00e1n a lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. $ (integracion-continua-actions) git checkout main $ (main) git pull $ (main) git branch -d integracion-continua-actions $ (main) git remote prune origin","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#3-configuracion-de-la-aplicacion-para-usar-una-bd-postgres","text":"Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos Postgres en producci\u00f3n. Adem\u00e1s, te habr\u00e1s dado cuenta de que es muy engorroso probar la aplicaci\u00f3n con la base de datos de memoria. Tienes que volver a introducir todos los datos de prueba cada vez que paramos y ponemos en marcha la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a ver c\u00f3mo configurar la aplicaci\u00f3n para poder trabajar con una base datos Postgres, tanto en su ejecuci\u00f3n como en los tests. Para configurar la aplicaci\u00f3n vamos a utilizar los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos Postgres. La configuraci\u00f3n de tests con base de datos Postgres la utilizaremos para ejecutar los tests de integraci\u00f3n sobre la base de datos Postgres en el proceso de integraci\u00f3n continua de GitHub Actions. Para lanzar un servidor de base de datos Postgres usaremos Docker, de forma que no tendremos que realizar ninguna instalaci\u00f3n en nuestro ordenador.","title":"3. Configuraci\u00f3n de la aplicaci\u00f3n para usar una BD Postgres"},{"location":"03-pruebas-tdd/integration-tdd.html#ficheros-de-configuracion-de-la-aplicacion","text":"Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-postgres.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con Postgres. Estos ficheros de configuraci\u00f3n adicionales se cargan despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en application.properties .","title":"Ficheros de configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html#cambios-en-los-sentencias-sql-de-los-datos-iniciales","text":"Es posible que tengas que hacer alg\u00fan cambio en las sentencias SQL del fichero datos-test.sql para adaptarlas a la nueva base de datos Postgres. No ser\u00e1 necesario hacerlo en el fichero con datos iniciales datos-dev.sql porque cuando trabajemos la con base de datos real no vamos a cargar estos datos iniciales. Por ejemplo, un cambio que deber\u00e1s hacer ser\u00e1 eliminar las claves primarias de todos los registros, de forma que sea Postgres quien autogenere esas claves primarias. Por ejemplo, en el fichero datos-tests.sql en lugar de: INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); las nuevas sentencias deben ser: INSERT INTO usuarios ( email , nombre , password , fecha_nacimiento ) VALUES ( 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Lavar coche' , '1' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Renovar DNI' , '1' ); Si no se hace esto surgen problemas en los tests, porque Postgres no actualiza el \u00edndice de clave primaria y los nuevos registros que se crean en algunos tests entran en conflicto con claves primarias id\u00e9nticas ya existentes.","title":"Cambios en los sentencias SQL de los datos iniciales"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_2","text":"Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con Postgres . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. $ (main) git checkout -b perfiles $ (perfiles) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.datasource.initialization-mode=never Este va a ser el perfil que activemos para utilizar la conexi\u00f3n con la BD Postgres. En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos mads , su usuario ( mads ) y contrase\u00f1a ( mads ) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.PostgreSQL9Dialect ). La propiedad spring.datasource.initialization-mode=never indica que no se debe cargar ning\u00fan fichero de datos inicial. Por esto, el fichero datos-dev.sql no se va a cargar en la base de datos, deber\u00e1s registrar un usuario inicial para poder probar la aplicaci\u00f3n. La ventaja es que al trabajar con la base de datos real todos los datos van a quedar grabados aunque se pare la aplicaci\u00f3n. Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero en src/test/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads_test spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect En este perfil la conexi\u00f3n se hace con una base de datos diferente: mads_test , para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. Recuerda que en el perfil por defecto resources/application.properties se define el valor de spring.jpa.hibernate.ddl-auto como create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver postgresql:42.2.22 . Tambi\u00e9n a\u00f1ade las l\u00edneas para poder especificar perfiles desde l\u00ednea de comando. La variable profiles se definir\u00e1 desde l\u00ednea de comando cuando se llame a Maven: Fichero pom.xml : <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.postgresql </groupId> <artifactId> postgresql </artifactId> <version> 42.2.22 </version> </dependency> <dependency> <groupId> org.springframework.boot </groupId> ... <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <profiles> ${profiles} </profiles> </configuration> </plugin> Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor Postgres en el puerto 5432 con el usuario mads , la contrase\u00f1a mads y la base de datos mads . Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: docker run -d -p 5432:5432 --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Docker se descarga la imagen postgres:13 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 5432 (no debe estar ocupado) y sobre la base de datos mads . Le da como nombre postgres-develop . Puedes ejecutar los siguientes comandos de Docker: $ docker container ls -a (comprueba todos los contenedores en marcha) $ docker container stop <nombre o id de contenedor> (para un contenedor) $ docker container start <nombre o id de contenedor> (pone en marcha un contenedor) $ docker container logs <mombre o id de contenedor> (muestra logs del contenedor) $ docker container rm nombre o id de contenedor> (elimina un contenedor) Arranca la aplicaci\u00f3n con el siguiente comando: ./mvnw spring-boot:run -D profiles=postgres Se activar\u00e1 el perfil postgres y se cargar\u00e1n las preferencias de src/main/resource/application.properties y src/main/resource/application-postgres.properties . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos utilizando por ejemplo el panel Database de IntelliJ : Tambi\u00e9n podemos arrancar la aplicaci\u00f3n con el perfil de postgres lanzando directamente el fichero JAR de la siguiente forma: $ ./mvnw package $ java -Dspring.profiles.active=postgres -jar target/*.jar Para lanzar la aplicaci\u00f3n desde IntelliJ trabajando con el nuevo perfil podemos seleccionar la opci\u00f3n Edit Configurations... del men\u00fa de configuraciones, duplicar la configuraci\u00f3n Application , renombr\u00e1ndola por Application Postgres y a\u00f1adir en el campo Active profiles el nombre del perfil nuevo que acabamos de crear postgres . Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop : $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e posgres:13 ... postgres-develop $ docker container stop postgres-develop Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker. Vamos ahora a preparar los tests para que se puedan lanzar con Postgres. Ser\u00e1n tests de integraci\u00f3n que trabajar\u00e1n con la base de datos real y, por tanto, su ejecuci\u00f3n ser\u00e1 m\u00e1s lenta que cuando los lanzamos con la base de datos de memoria H2. Modifica el fichero de datos datos-test.sql para eliminar la creaci\u00f3n expl\u00edcita de las claves primarias y que sea el propio Postgres el que las asigne: INSERT INTO usuarios ( email , nombre , password , fecha_nacimiento ) VALUES ( 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Lavar coche' , '1' ); INSERT INTO tareas ( titulo , usuario_id ) VALUES ( 'Renovar DNI' , '1' ); Lanzamos ahora otro contenedor con la base de datos de test ( mads_test ): docker run -d -p 5432:5432 --name postgres-test -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads_test postgres:13 Y lanzamos los tests usando el perfil postgres con la base de datos Postgres con el siguiente comando: ./mvnw -D spring.profiles.active=postgres test Nos conectamos con el panel Database de IntelliJ a la base de datos mads_test y comprobamos que los datos que hay en la base de datos corresponden con los introducidos en el fichero datos-test.sql que se cargan antes de ejecutar los tests. Podemos lanzar tambi\u00e9n los tests desde IntelliJ editando la configuraci\u00f3n de lanzamiento de test y a\u00f1adiendo la variable de entorno spring.profiles.active=postgres . Podr\u00edamos, por ejemplo, llamar a esta configuraci\u00f3n Tests con Postgres . Dado que las configuraciones de test y de ejecuci\u00f3n utilizan distintas bases de datos, debemos tener en funcionamiento la base de datos correspondiente a lo que queremos hacer en cada momento. Esto es muy f\u00e1cil usando los contenedores de Docker. Por ejemplo, podemos parar el contenedor Postgres con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: $ docker container ls -a $ docker container stop postgres-test $ docker container start postgres-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en main : $ (perfiles) git add . $ (perfiles) git commit -m \"A\u00f1adidos perfiles para trabajar con Postgres\" $ (perfiles) git push // Mezclamos el Pull Request en GitHub $ (perfiles) git checkout main $ (main) git pull $ (main) git branch -d perfiles $ (main) git remote prune origin","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#4-tests-de-integracion-en-github-actions","text":"Vamos a modificar la configuraci\u00f3n de GitHub Actions para conseguir un sistema de integraci\u00f3n continua que ejecute los tests de integraci\u00f3n usando la base de datos real Postgres. La ejecuci\u00f3n de los tests usando la base de datos de memoria H2 ser\u00e1 responsabilidad del desarrollador y se har\u00e1 en el entorno de trabajo local, tal y como se ha hecho desde la primera pr\u00e1ctica.","title":"4. Tests de integraci\u00f3n en GitHub Actions"},{"location":"03-pruebas-tdd/integration-tdd.html#tests-del-desarrollador-vs-tests-de-integracion","text":"Podemos considerar los tests que usan la base de datos real como tests de integraci\u00f3n y los tests que usan la base de datos en memoria como tests del desarrollador . No usamos el nombre de tests unitarios de forma consciente, para evitar conflictos con la nomenclatura. Cuando hablamos de tests del desarrollador nos referimos a tests que van a ejecutar continuamente los desarrolladores en su equipo local cuando est\u00e1n trabajando con la aplicaci\u00f3n y a\u00f1adiendo funcionalidades. Son tests r\u00e1pidos, que se pueden lanzar desde el propio IDE, y que deben ser ejecutados antes de cada commit. Frente a estos tests, los tests de integraci\u00f3n necesitan una configuraci\u00f3n adicional (poner en marcha la base de datos de test en nuestro caso) y se ejecutan menos frecuentemente. Vamos a actualizar GitHub Actions para que se lancen all\u00ed los tests usando la base de datos Postgres. De esta forma nosotros lanzaremos en local los tests que usan la BD de memoria y los tests de integraci\u00f3n se lanzar\u00e1n en GitHub cada vez que vaya a mezclarse un pull request.","title":"Tests del desarrollador vs. tests de integraci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html#accion-para-lanzar-los-tests-con-la-bd-postgres","text":"Para lanzar los tests de integraci\u00f3n en GitHub debemos modificar el fichero de configuraci\u00f3n del flujo de trabajo para que lance un contenedor de Postgres y despu\u00e9s se ejecuten los tests sobre ese contenedor. Para tener m\u00e1s flexibilidad en la configuraci\u00f3n de la conexi\u00f3n con Postgres vamos a modificar el perfil de Spring Boot, a\u00f1adiendo unas variables con unos valores por defecto que se pueden modificar definiendo su valor en variables de entorno con el mismo nombre. En concreto, definimos las variables POSTGRES_HOST , POSTGRES_PORT , DB_USER y DB_PASSWD . Fichero src/test/resources/application-postgres.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads_test spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect Ya podemos modificar el fichero del flujo de trabajo de la acci\u00f3n: Fichero .github/workflows/tests.yml : name: Integration tests on: push jobs: container-job: runs-on: ubuntu-latest container: openjdk:8-jdk-alpine services: # Etiqueta usada para acceder al contenedor del servicio postgres: # Imagen Docker Hub image: postgres:13 # Variables para arrancar Postgres env: POSTGRES_USER: mads POSTGRES_PASSWORD: mads POSTGRES_DB: mads_test # Definimos chequeos para esperar hasta que postgres ya ha comenzado options: >- --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5 steps: - uses: actions/checkout@v2 - name: Launch tests with Maven run: ./mvnw test -D spring.profiles.active=postgres env: POSTGRES_HOST: postgres Vemos que en la \u00faltima l\u00ednea se actualiza el par\u00e1metro POSTGRES_HOST usado por el perfil postgres para que la conexi\u00f3n se realice con el host postgres que es el que nombre que se ha definido en el servicio.","title":"Acci\u00f3n para lanzar los tests con la BD postgres"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_3","text":"Crea un nuevo issue llamado Tests de integraci\u00f3n en GitHub Actions . Crea la rama integracion-gh-actions . $ git checkout -b integracion-gh-actions $ git push -u origin integracion-gh-actions Modifica el fichero del perfil postgres de test tal y como se indica anteriormente, para usar variables de configuraci\u00f3n que puedan ser definidas mediante variables de entorno. Comprueba que siguen funcionando los tests lanzados sobre la base de datos usando los valores por defecto de las variables de entorno. // Nos aseguramos de que la base de datos que est\u00e1 en marcha // es la de test $ docker container ls CONTAINER ID IMAGE PORTS NAMES 411d8f2ea46c postgres:13 0.0.0.0:5432->5432/tcp postgres-test ./mvnw -D spring.profiles.active=postgres test Comprueba que podemos modificar los par\u00e1metros definidos en las variables de entorno. Por ejemplo, si se cambia el nombre del host de la conexi\u00f3n con la base de datos los tests deben de fallar: $ ./mvnw -D spring.profiles.active=postgres -D POSTGRES_HOST=postgres test // Aparecer\u00e1n errores debidos a que no se puede conectar con el // host postgres: org.postgresql.util.PSQLException: El intento de conexi\u00f3n fall\u00f3. ... Caused by: java.net.UnknownHostException: postgres Crea un commit, s\u00fabelo a GitHub y crea el Pull Request $ git add . $ git commit -m \"A\u00f1adidas variables al perfil de test postgres\" $ git push Modifica el fichero del flujo de trabajo de la acci\u00f3n de GitHub, tal y como se indica anteriormente. Haz un commit, s\u00fabelo a GitHub y comprueba que los tests pasan correctamente y se lanzan all\u00ed usando la base de datos postgres. Una vez comprobado que funcionan los tests de integraci\u00f3n en GitHub, mezclamos el pull request y lo descargamos a local. Comprobamos que tambi\u00e9n se lanzan los tests en el commit de merge en GitHub. Con esto ya tenemos completado un sistema de integraci\u00f3n continua y GitHub se encargar\u00e1 de ejecutar todos los tests en un modo de integraci\u00f3n, usando la base de datos Postgres.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#5-tdd","text":"En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta.","title":"5. TDD"},{"location":"03-pruebas-tdd/integration-tdd.html#008-listado-de-equipos","text":"La descripci\u00f3n de la historia de usuario es la siguiente: Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el enlace del nombre del equipo nos iremos a una p\u00e1gina con un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de dentro a fuera (desde el repository hasta el controller). Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional.","title":"008 Listado de equipos"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_4","text":"Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea dos issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#resto-de-historias-de-usuario","text":"Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. Importante detalle de implementaci\u00f3n En una relaci\u00f3n muchos-a-muchos como la que existe entre Usuario y Equipo cuando se a\u00f1ade un usuario a un equipo hay que actualizar ambos lados de la relaci\u00f3n, porque JPA/Hibernate no lo hace autom\u00e1ticamente. Hay que a\u00f1adir el usuario a la colecci\u00f3n de usuarios del equipo y tambi\u00e9n a\u00f1adir el equipo a la colecci\u00f3n de equipos del usuario. Lo mismo habr\u00eda que hacer cuando se elimina un usuario de un equipo. 010 Gesti\u00f3n de equipos (opcional) : Como administrador cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa.","title":"Resto de historias de usuario"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_5","text":"Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#6-documentacion-entrega-y-evaluacion","text":"Deber\u00e1s a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica3.md en la que, al igual que en la pr\u00e1ctica anterior, debes realizar una breve documentaci\u00f3n t\u00e9cnica de lo implementado en las historias de usuario 009 y 010. En la documentaci\u00f3n debes incluir tambi\u00e9n una captura de pantalla en la que se muestren las tablas de la base de datos de desarrollo Postgres en la versi\u00f3n final de la aplicaci\u00f3n. Puedes mostrar, por ejempo, una pantalla con el panel Database de IntelliJ o la herramienta que hayas utilizado. Basta solo con una captura de la base de datos de desarrollo, no hace falta mostrar la base de datos de test. Por ejemplo, puedes incluir en la documentaci\u00f3n lo siguiente. Los puntos 2 en adelante son sobre las historias de usuario 009 y 010 . Pantalla de la base de datos Postgres. Rutas (endpoints) definidas para las acciones y, para cada endpoint o grupo de endpoints, explicaci\u00f3n sobre: Clases y m\u00e9todos Plantillas thymeleaf Tests Explicaci\u00f3n de algunos fragmentos de c\u00f3digo fuente que consideres interesante en las nuevas funcionalidades implementadas. Intenta que el documento tenga un formato limpio y se pueda leer f\u00e1cilmente. Para eso utiliza los bloques de c\u00f3digo de Markdown. Puedes mirar como ejemplo el c\u00f3digo Markdown de estas pr\u00e1cticas. Por ejemplo, el c\u00f3digo Markdown de la introducci\u00f3n a Spring Boot se puede ver pulsando el bot\u00f3n Raw . Ver\u00e1s el texto Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de entrega es el martes 10 de noviembre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"6. Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html","text":"Pr\u00e1ctica 4: Trabajo en equipo con GitFlow y despliegue en producci\u00f3n \u00b6 1. Objetivos y resumen de la pr\u00e1ctica \u00b6 En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub. Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Desplegar la aplicaci\u00f3n usando una base de datos de producci\u00f3n y mantener esta base de datos. Implementar GitFlow: Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow. 2. Formaci\u00f3n de equipos \u00b6 En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas. Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio. Pasos a seguir \u00b6 Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolist--NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 2, el repositorio se crear\u00e1 en la organizaci\u00f3n mads-ua-21-22 . Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo: Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 2 y 3. Escoged el proyecto que vais a usar como punto de partida de estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: $ git remote set-url origin https://github.com/mads-ua-21-22/todolist-NOMBRE-EQUIPO.git $ git push -u origin main Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto (en el fichero POM.xml y en el about.html a todolist-equipo-XX . Haced un commit directamente en main con estos cambios. Comprobad que GitHub Actions sigue funcionando correctamente. 3. Nuevo flujo de trabajo para los issues \u00b6 Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable del desarrollo del issue . Nueva rama con el issue : El responsable seleccionado ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable, trabajando sobre la rama. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al menos uno de los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Deb\u00e9is configurar la opci\u00f3n de GitHub que obliga a que haya un m\u00ednimo de revisores en el pull request. Integraci\u00f3n del pull request : Cuando un miembro da el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios. Comandos Git \u00b6 Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar por primera vez una rama del repositorio remoto y moverse a ella $ git fetch $ git checkout nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas locales conectadas con las remotas (ramas remote tracking ) a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). Estas ramas remote tracking son de solo lectura y no podemos hacer commits en ellas. Para trabajar con ellas hay que crear una rama local conectada a ella (normalmente tendr\u00e1 el mismo nombre, por ejemplo nueva-rama ). En el caso del comando anterior, el comando $ git checkout nueva-rama es equivalente a $ git checkout -b nueva-rama origin/nueva-rama Se est\u00e1 creando una rama local nueva-rama conectada a la rama origin/nueva-rama . Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: $ git checkout nueva-rama $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . El comando git fetch actualiza la rama local conectada con la remote tracking origin/nueva-rama . El comando git pull es equivalente a hacer: $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: (estando en la rama que queremos subir) $ git push Si somos nosotros los que hemos creado la rama, hay que configurarla para que funcione correctamente el git push haciendo: $ git push -u origin nueva-rama Comprobar el estado de las ramas locales: $ git branch -vv Con la opci\u00f3n -a ( git branch -vva ) se muestra tambi\u00e9n el estado de las ramas remote tracking de solo lectura (en rojo, y precedidas con el nombre remotes/ ): $ git branch -vva main dd867ac [origin/main] Colocados esquemas en su directorio * prueba 8d2d093 [origin/prueba] Correcci\u00f3n remotes/origin/HEAD -> origin/main remotes/origin/main dd867ac Colocados esquemas en su directorio remotes/origin/prueba 8d2d093 Correcci\u00f3n Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: $ git fetch --all $ git branch -vva Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que actualiza las ramas remote tracking . Informaci\u00f3n de los repositorios remotos: $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminal: $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama main . Podemos hacer un merge de la rama main en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en main y que necesitamos en nuestra nueva rama: $ git checkout nueva-rama $ git merge main Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y main . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: $ git checkout main $ git pull $ git checkout nueva-rama $ git merge main # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub Pasos a seguir \u00b6 A\u00f1adid el milestone 1.3.0 y etiquetad todos los pr\u00f3ximos issues con \u00e9l. Probad el nuevo flujo de trabajo descrito anteriormente creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en main y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 descargar esa rama y realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en main que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en main . 4. Contenedor con la aplicaci\u00f3n ToDoList \u00b6 Una de las cosas que vamos a hacer en esta pr\u00e1ctica (en el siguiente apartado) es poner en producci\u00f3n en el servidor de la asignatura la aplicaci\u00f3n ToDoList conect\u00e1ndola con la base de datos. En las pr\u00e1cticas 1 y 2 ya hemos construido el contenedor Docker de la aplicaci\u00f3n, con el siguiente fichero Dockerfile: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] Este Dockerfile tiene un problema importante. El comando de ejecuci\u00f3n es fijo y no permite definir ning\u00fan par\u00e1metro de ejecuci\u00f3n. No es posible, por ejemplo, definir el perfil de Postgres, ni definir ning\u00fan par\u00e1metro de configuraci\u00f3n. Debemos cambiarlo de la siguiente forma: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] De esta forma podremos llamar al comando docker a\u00f1adiendo al final par\u00e1metros que se van a pasar al comando java. La forma de a\u00f1adir variables de entorno a ese comando java es precedi\u00e9ndolos con dos guiones -- . Por ejemplo: $ docker run --rm <usuario>/mads-todolist-equipoXX --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Vamos a probarlo, creando y subiendo la nueva imagen a DockerHub y despleg\u00e1ndola en el servidor de la asignatura. Pasos a seguir \u00b6 Deb\u00e9is hacer lo siguiente: Creamos un issue llamado Configuraci\u00f3n imagen docker y trabajamos en la rama imagen-docker . Cambiad el fichero Dockerfile de la aplicaci\u00f3n tal y como se indica en el listado anterior: Fichero Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] Cread la nueva imagen Docker con el nombre mads-todolist-equipoXX y la etiqueta 1.3.0-snapshot . El usuario puede ser cualquier miembro del equipo, no es necesario que sea el autor del proyecto original. $ ./mvnw package $ docker build -t <usuario-docker>/mads-todolist-equipoXX:1.3.0-snapshot . Probad que funcionan correctamente los par\u00e1metros de configuraci\u00f3n en la imagen Docker. Una forma sencilla de hacerlo es comprobar que se puede definir el perfil de Postgres y modificar alguno de sus par\u00e1metros. Deber\u00e1 aparecer un mensaje de error de que no se puede conectar con la base de datos (lo que est\u00e1 bien, porque significa que s\u00ed que se ha cargado el perfil). $ docker run --rm <usuario>/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Subid, por \u00faltimo, la imagen a Docker Hub: $ docker login $ docker push <usuario-docker>/mads-todolist-equipoXX 5. Despliegue en producci\u00f3n con BD \u00b6 Vamos a ver c\u00f3mo ejecutar en producci\u00f3n el contenedor con la aplicaci\u00f3n de forma que se conecte con una base de datos postgres. En las pr\u00e1cticas 1 y 2 vimos c\u00f3mo construir una versi\u00f3n en forma de contenedor de nuestra aplicaci\u00f3n Spring Boot y en la pr\u00e1ctica 3 vimos como usar un contenedor de Postgres para definir un servicio de base de datos con el que conectar la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a definir la configuraci\u00f3n en producci\u00f3n definitiva de nuestra aplicaci\u00f3n. Veremos c\u00f3mo poner en marcha dos contenedores y conectarlos entre si. En nuestro caso un contenedor tendr\u00e1 la base de datos postgres y el otro la aplicaci\u00f3n Spring Boot. La imagen anterior muestra los dos contenedores conectados por una red. Desde el contenedor con la aplicaci\u00f3n se acceder\u00e1 a la direcci\u00f3n postgres:5432 para conectarse con la base de datos. Veremos los comandos de docker para definir una red y para lanzar el contenedor de base de datos en esa direcci\u00f3n de la red. El contenedor de base de datos montar\u00e1 el directorio actual del host en el directorio /mi-host del contenedor. De esta forma, cualquier fichero que coloquemos en ese directorio del contenedor ser\u00e1 visible en el directorio actual del host (y viceversa). Usaremos este directorio para guardar datos de la base de datos, como copias de seguridad o ficheros de migraci\u00f3n. El contenedor de base de datos implementar\u00e1 la base de datos en producci\u00f3n. Base de datos de producci\u00f3n La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir tambi\u00e9n un flujo de trabajo para actualizar la base de datos de producci\u00f3n con los cambios del modelo de datos introducidos por la nuevas funcionalidades (nuevas tablas y nuevas relaciones). Pasos a seguir \u00b6 Veamos paso a paso c\u00f3mo crear la configuraci\u00f3n anterior. En muchos casos tendremos que usar el nombre de nuestro equipo. En los ejemplos hemos usado equipo01 . Deb\u00e9is cambiarlo por el nombre de vuestro equipo. Nos conectamos al servidor de la asignatura con uno de los usuarios del equipo. La direcci\u00f3n IP est\u00e1 en un mensaje enviado al foro de la asignatura. $ ssh alu02@<direccion-IP> Creamos una red gestionada por Docker: $ docker network create network-equipo01 Lanzamos el contenedor con la base de datos usando la red creada anteriormente y con el nombre db-equipo01 . Definimos el nombre del host creado en el contenedor como postgres con el modificador --network-alias . $ docker run -d --network network-equipo01 --network-alias postgres -v ${PWD}:/mi-host --name db-equipo01 -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 El modificador -v permite montar el directorio actual en el directorio /mi-host del contenedor. Vamos a probar que funciona correctamente. Nos conectamos al contenedor lanzando un bash interactivo. Estando en el contenedor creamos un fichero en el directorio /mi-host , salimos del contenedor y comprobamos que est\u00e1 en el directorio actual $ docker exec -it db-equipo01 bash root@e470db191dc6:/# cd /mi-host root@e470db191dc6:/mi-host# echo \"Hola\" > prueba.txt root@e470db191dc6:/mi-host# exit $ ls prueba.txt $ more prueba.txt Hola Con esto ya tenemos configurado y en marcha el contenedor con la base de datos Postgres. Esta va a ser nuestra base de datos de producci\u00f3n. Vamos ahora a poner en marcha la aplicaci\u00f3n. Descargamos la \u00faltima versi\u00f3n de nuestra aplicaci\u00f3n y lanzamos el contenedor usando la red definida anteriormente. Los modificadores --spring.profiles.active y --POSTGRES_HOST permiten pasar al contenedor esas variables del entorno. $ docker pull <usuario>/mads-todolist-equipo01:1.3.0-snapshot $ docker run --rm --name spring-boot-equipo01 --network network-equipo01 -p8080:8080 <usuario>/mads-todolist-equipo01:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=postgres \u00a1\u00a1\u00a1Enhorabuena!!! \u00a1Ya tenemos la aplicaci\u00f3n en producci\u00f3n trabajando con la base de datos! Podremos conectarnos a la aplicaci\u00f3n usando la direcci\u00f3n IP del servidor de la asignatura y el puerto 8080. Probamos la aplicaci\u00f3n y creamos alg\u00fan usuario de prueba. Por \u00faltimo paramos el contenedor y lo volvemos a arrancar para comprobar que los datos son persistentes. Para comprobar que la base de datos est\u00e1 funcionando correctamente podemos conectarnos al contenedor y examinar la base de datos mads y alguna de sus tablas: $ docker exec -it db-equipo01 bash # psql -U mads -W mads (nos pedir\u00e1 la contrase\u00f1a: mads) # \\l (lista las bases de datos) # \\dt (lista las tablas) # SELECT * FROM usuarios; La base de datos se mantendr\u00e1 mientras que no borremos el contenedor. Podemos pararlo y volver a ponerlo en marcha y seguiremos conservando los datos: $ docker stop db-equipo01 $ docker start db-equipo01 6. Perfil de producci\u00f3n y mantenimiento de la base de datos de producci\u00f3n \u00b6 Perfil de producci\u00f3n \u00b6 Una vez que vamos a trabajar en producci\u00f3n con una base de datos, esta base de datos ser\u00e1 un elemento clave de la aplicaci\u00f3n. No debemos, bajo ning\u00fan concepto, perder datos que se hayan introducido en ella, ya que son datos de nuestros usuarios y clientes. Es imprescindible para ello cambiar el modo con el que la aplicaci\u00f3n construye las tablas de la base de datos. Sabemos que nuestra aplicaci\u00f3n est\u00e1 trabajando con JPA/Hibernate y que las tablas de la base de datos se construyen de forma autom\u00e1tica. Si hay alg\u00fan cambio en las entidades (se a\u00f1ade alg\u00fan atributo o alguna nueva entidad) Spring Boot actualiza las tablas de la base de datos de forma autom\u00e1tica cuando se lanza la aplicaci\u00f3n. Esto es razonable si estamos trabajando en un entorno de desarrollo, pero est\u00e1 totalmente desaconsejado en un entorno de producci\u00f3n. El par\u00e1metro spring.jpa.hibernate.ddl-auto es el que determina el funcionamiento de la actualizaci\u00f3n de las tablas de la base de datos. Su valor puede ser: CREATE : El esquema de datos se crea de nuevo cada vez que se lanza la aplicaci\u00f3n. Una vez creado, se a\u00f1aden los datos definidos en el fichero spring.datasource.data si el spring.datasource.initialization-mode tiene como valor always . Esta es la forma de funcionar de los tests. UPDATE : El esquema de datos de la base de datos se actualiza autom\u00e1ticamente cuando hay un cambio en las entidades de la aplicaci\u00f3n. As\u00ed es como tenemos configurado el perfil por defecto de nuestra aplicaci\u00f3n. Si estamos trabajando con la base de datos Postgres, se actualizar\u00e1 el esquema de datos. Pero esto no es recomendable para producci\u00f3n, porque no tenemos control de las instrucciones de actualizaci\u00f3n y pueden resultar en alguna p\u00e9rdida de datos. VALIDATE : El esquema de datos de la base de datos se valida con respecto al esquema de datos definido por las entidades JPA. Si hay alguna diferencia, salta una excepci\u00f3n. Este es el valor que hay que usar cuando lanzamos la aplicaci\u00f3n en producci\u00f3n. Vamos a definir en la aplicaci\u00f3n un nuevo perfil de ejecuci\u00f3n, llamado postgres-prod , en el que pondremos el valor del par\u00e1metro spring.jpa.hibernate.ddl-auto a VALIDATE . Y ser\u00e1 este el perfil que usaremos para lanzar la aplicaci\u00f3n en el servidor de producci\u00f3n. Mantenimiento de la base de datos de producci\u00f3n \u00b6 En una aplicaci\u00f3n en producci\u00f3n se deben configurar pol\u00edticas estrictas de realizaci\u00f3n de copias de seguridad y de integridad de los datos. Tambi\u00e9n en la gesti\u00f3n de las versiones y en la actualizaci\u00f3n del esquema de datos. Esto \u00faltimo se denomina una migraci\u00f3n de la base de datos y representa un elemento fundamental del mantenimiento en producci\u00f3n de una aplicaci\u00f3n, sobre todo cuando estamos trabajando de una forma \u00e1gil e incremental. Es un tema avanzado muy importante, pero que no podemos abordar en la asignatura por falta de tiempo. Un par de referencias que os pueden ser de utilidad son el art\u00edculo Evolutionary Database Design y herramientas como Flyway que permiten automatizar las migraciones de la base de datos. En la pr\u00e1ctica vamos a trabajar con la base de datos de producci\u00f3n de dos formas: Realizaremos una copia de seguridad antes de instalar una nueva versi\u00f3n. Actualizaremos el esquema de datos aplicando un fichero de migraci\u00f3n que construiremos manualmente. Copias de seguridad \u00b6 Si eliminamos el contenedor con la base de datos se perder\u00e1n todos los datos. Para evitar perder los datos, con el contenedor en marcha podemos hacer una copia de seguridad de la base de datos mads en el directorio compartido: $ docker exec -it db-equipo01 bash # pg_dump -U mads --clean mads > /mi-host/backup03092021.sql La copia de seguridad se guarda en el directorio compartido. Podemos poner la fecha en el nombre del fichero. Por ejemplo, la copia anterior ha sido creada el 3 de septiembre del 2021. Para restaurar una copia de seguridad basta con ejecutar el fichero SQL en la base de datos: $ docker exec -it db-equipo01 bash # psql -U mads mads < /mi-host/backup03092021.sql # exit Migraci\u00f3n de la base de datos \u00b6 Podemos obtener el esquema de datos de la aplicaci\u00f3n (la definici\u00f3n de las tablas, sin los datos) conect\u00e1ndonos al contenedor y ejecutando el siguiente comando para guardar el fichero en el directorio compartido: $ docker exec -it db-equipo01 bash # pg_dump -U mads -s mads > /mi-host/schema.sql # exit Tendremos el esquema de datos en el directorio actual, que hemos montado en el contenedor con la instrucci\u00f3n -V. Los esquemas son instrucciones SQL en texto plano. Supongamos que tenemos una nueva versi\u00f3n de la aplicaci\u00f3n ( 1.3.0 ) en la que hemos a\u00f1adido el atributo descripcion a la entidad Equipo . Si generamos el esquema de datos de esta nueva versi\u00f3n y lo llamamos schema-1.3.0.sql lo podemos comparar con el esquema anterior usando el comando de linux diff : % diff sql/schema-1.3.0.sql sql/schema-1.2.0.sql 41,42c41 < nombre character varying(255), < descripcion character varying(255) --- > nombre character varying(255) Por ejemplo, en el ejemplo mostrado, el fichero schema-1.3.0.sql tiene un campo adicional que el fichero schema-1.2.0.sql . Se trata del campo descripcion . En la versi\u00f3n anterior ( schema-1.2.0.sql ) la tabla equipo se define como: CREATE TABLE public . equipos ( id bigint NOT NULL , nombre character varying ( 255 ) ); Mientras que en la versi\u00f3n nueva ( schema-1.3.0.sql ) se define como: CREATE TABLE public . equipos ( id bigint NOT NULL , nombre character varying ( 255 ), descripcion character varying ( 255 ) ); Si queremos migrar la base de datos de producci\u00f3n de una versi\u00f3n a otra, debemos crear un script de migraci\u00f3n en el que modifiquemos \u00fanicamente el esquema de datos anterior para adaptarlo al nuevo. En este caso el script lo llamaremos schema-1.2.0-1.3.0.sql y contendr\u00e1 \u00fanicamente la siguiente instrucci\u00f3n: ALTER TABLE public . equipos ADD COLUMN descripcion character varying ( 255 ) Para actualizar la base de datos de producci\u00f3n s\u00f3lo tenemos que ejecutar el script anterior: $ docker exec -it db-equipo01 bash $ psql -U mads mads < /mi-host/schema-1.2.0-1.3.0.sql ALTER TABLE $ exit De esta forma habremos a\u00f1adido manualmente un campo en la tabla equipos . La aplicaci\u00f3n deber\u00e1 funcionar ahora perfectamente si la lanzamos en modo producci\u00f3n, definiendo la variable que hemos mencionado antes con el modo validate : spring.jpa.hibernate.ddl-auto=validate Pasos a seguir \u00b6 Creamos un issue llamado Esquema de datos y perfil de producci\u00f3n y trabajamos en la rama esquema-datos y en el pull request equivalente. $ git checkout -b esquema-datos $ git push -u origin esquema-datos Lanzamos la aplicaci\u00f3n en local con el modo postgres , trabajando sobre la base de datos. Previamente hemos lanzado el contenedor postgres montando el directorio actual en su directorio /mi-host/ : $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 $ ./mvnw spring-boot:run -D profiles=postgres Al lanzar la aplicaci\u00f3n se habr\u00e1 creado en la base de datos el esquema de datos. Lo generamos y lo salvamos en el directorio actual: $ docker exec -it postgres-develop bash # pg_dump -U mads -s mads > /mi-host/schema-1.2.0.sql # exit Comprobamos que el esquema de datos se ha creado correctamente y lo movemos al directorio sql en el directorio ra\u00edz: $ ls -l Dockerfile README.md mvnw mvnw.cmd pom.xml schema-1.2.0.sql src target $ mkdir sql $ mv schema-1.2.0.sql sql Creamos un commit con el nuevo fichero con el esquema de datos. Creamos un nuevo fichero con el perfil de producci\u00f3n: Fichero /src/main/resources/application-postgres-prod.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.datasource.initialization-mode=never spring.jpa.hibernate.ddl-auto=validate Contiene exactamente la misma configuraci\u00f3n del perfil postgres, excepto la propiedad spring.jpa.hibernate.ddl-auto que tiene el valor validate . Probamos en local que el perfil funciona correctamente, lanz\u00e1ndolo: $ ./mvnw spring-boot:run -D profiles=postgres-prod Probamos que realmente valida el esquema de datos, en lugar de actualizarlo. Para ello, paramos y borramos el contenedor postgres y lo lanzamos de nuevo. Esto crear\u00e1 una base de datos vac\u00eda: $ docker container stop docker-develop $ docker container rm docker-develop $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Si ahora lanzamos la aplicaci\u00f3n en modo postgres-prod obtendremos un error: $ ./mvnw spring-boot:run -D profiles=postgres-prod org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.tool.schema.spi.SchemaManagementException: Schema-validation: missing table [equipo_usuario] Si queremos volver a construir la base de datos, no tenemos m\u00e1s que lanzar la aplicaci\u00f3n con el perfile postgres , que tiene la propiedad spring.jpa.hibernate.ddl-auto con el valor update . Hacemos un commit con el nuevo perfil, subimos los cambios y cerramos el pull request y el issue. Nos conectamos al servidor de la asignatura y ponemos en marcha la base de datos de producci\u00f3n y hacemos una copia de seguridad tal y como se explica anteriormente. Dejamos el fichero en el servidor de la asignatura, indicando la fecha en el nombre del mismo. Por ejemplo backup10112021.sql . 7. Desarrollo de la nueva versi\u00f3n con GitFlow \u00b6 El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ) Ramas de largo recorrido \u00b6 En GitFlow se publican las distintas versiones del proyecto en la rama long-lived main y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en main sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings > Branches > Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop . Ramas de feature \u00b6 Desde el comienzo de trabajo con Git en las pr\u00e1cticas 2 y 3 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request. Pasos a seguir \u00b6 Cread la rama develop y configurarla como rama principal del proyecto en GitHub. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. Cread tres issues distintos, simulando tres nuevas funcionalidades. Deben ser issues sencillos, que no cuesten demasiado de implementar (mejorar alg\u00fan defecto de la aplicaci\u00f3n, cambiar alg\u00fan elemento de alguna de las vistas, o algo similar). Uno de los cambios debe afectar a alguna entidad , por ejemplo a\u00f1adir un campo de descripci\u00f3n a los equipos y actualizar las vistas correspondientes para permitir su inicializaci\u00f3n y su actualizaci\u00f3n. Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues. Configurad el repositorio GitHub para obligar a que cualquier pull request tenga que tener la revisi\u00f3n de una persona distinta del responsable del PR. Desarrollad e integrar los issues en develop siguiendo el flujo de trabajo planteado anteriormente. Deb\u00e9is ir actualizando el tablero de GitHub se actualiza correctamente. Rama de release \u00b6 Hasta ahora hemos hecho los releases en la rama main . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en main y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request. Una cosa importante que tendremos que hacer en el release es crear el guardar el de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos. Pasos a seguir \u00b6 Vamos a probar el lanzamiento de una release usando el flujo de trabajo GitFlow. Cread un issue con la tarea Lanzar release 1.3.0 . Siguiendo las indicaciones de GitFlow, crear la rama local release-1.3.0 a partir de develop . En esta rama se deben realizar los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina Acerca de \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero pom.xml . Generad el esquema de datos de la base de datos postgres y guardarlo en sql/schema-1.3.0.sql . Comparar este esquema con el esquema anterior y crear el script de migraci\u00f3n con las instrucciones ALTER TABLE necesarias para actualizar la base de datos de producci\u00f3n de la versi\u00f3n 1.2.0 a la 1.3.0. Guardar el script en sql/schema-1.2.0-1.3.0.sql . Publicad la rama release-1.3.0 en GitHub y hacer un pull request sobre main . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en main creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Subir la nueva versi\u00f3n de la imagen de docker a Docker Hub. Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas main y develop estar\u00e1n actualizadas a la nueva versi\u00f3n. Hacer por \u00faltimo un commit en develop (no hace falta PR) cambiando la versi\u00f3n a 1.4.0-SNAPSHOT . Debemos comprobar que GitHub Actions pasa correctamente todos los tests de las nuevas caracter\u00edsticas que se a\u00f1aden. 8. Despliegue de la nueva versi\u00f3n y actualizaci\u00f3n de la BD de producci\u00f3n \u00b6 Deber\u00e9is desplegar la nueva versi\u00f3n de la aplicaci\u00f3n en el servidor de la asignatura, actualizando la base de datos de producci\u00f3n con los cambios introducidos. Pasos a seguir \u00b6 Conectarse al servidor de la asignatura. Descargar la nueva versi\u00f3n de la aplicaci\u00f3n. Hacer una copia de seguridad de la base de datos, tal y como se explica en el apartado Mantenimiento de la base de datos de producci\u00f3n . Dejar el fichero de copia de seguridad en el directorio ra\u00edz del usuario alu con el que se est\u00e1 conectado al servidor de la asignatura. Hacer una migraci\u00f3n de la base de datos tal y como se explica en el mismo apartado anterior. Lanzar el contenedor de la aplicaci\u00f3n con el perfil postgres-prod y comprobar que funciona correctamente la aplicaci\u00f3n en producci\u00f3n. 8. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e9is a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica4.md en la que deber\u00e9is incluir: Breve documentaci\u00f3n t\u00e9cnica de los cambios introducidos en la aplicaci\u00f3n. Detalles del despliegue de producci\u00f3n: usuario alu con el que se ha realizado la puesta en producci\u00f3n, as\u00ed como directorio y fichero en el que se encuentra (en el servidor de la asignatura) el backup de la base de datos de producci\u00f3n. Script de migraci\u00f3n de la base de datos. La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 23 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de pr\u00e1cticas. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las semanas y no dejar todo para la \u00faltima). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"Pr\u00e1ctica 4"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#practica-4-trabajo-en-equipo-con-gitflow-y-despliegue-en-produccion","text":"","title":"Pr\u00e1ctica 4: Trabajo en equipo con GitFlow y despliegue en producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#1-objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub. Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Desplegar la aplicaci\u00f3n usando una base de datos de producci\u00f3n y mantener esta base de datos. Implementar GitFlow: Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow.","title":"1. Objetivos y resumen de la pr\u00e1ctica"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#2-formacion-de-equipos","text":"En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas. Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio.","title":"2. Formaci\u00f3n de equipos"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir","text":"Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolist--NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 2, el repositorio se crear\u00e1 en la organizaci\u00f3n mads-ua-21-22 . Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo: Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 2 y 3. Escoged el proyecto que vais a usar como punto de partida de estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: $ git remote set-url origin https://github.com/mads-ua-21-22/todolist-NOMBRE-EQUIPO.git $ git push -u origin main Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto (en el fichero POM.xml y en el about.html a todolist-equipo-XX . Haced un commit directamente en main con estos cambios. Comprobad que GitHub Actions sigue funcionando correctamente.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#3-nuevo-flujo-de-trabajo-para-los-issues","text":"Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable del desarrollo del issue . Nueva rama con el issue : El responsable seleccionado ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable, trabajando sobre la rama. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al menos uno de los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Deb\u00e9is configurar la opci\u00f3n de GitHub que obliga a que haya un m\u00ednimo de revisores en el pull request. Integraci\u00f3n del pull request : Cuando un miembro da el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios.","title":"3. Nuevo flujo de trabajo para los issues"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#comandos-git","text":"Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar por primera vez una rama del repositorio remoto y moverse a ella $ git fetch $ git checkout nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas locales conectadas con las remotas (ramas remote tracking ) a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). Estas ramas remote tracking son de solo lectura y no podemos hacer commits en ellas. Para trabajar con ellas hay que crear una rama local conectada a ella (normalmente tendr\u00e1 el mismo nombre, por ejemplo nueva-rama ). En el caso del comando anterior, el comando $ git checkout nueva-rama es equivalente a $ git checkout -b nueva-rama origin/nueva-rama Se est\u00e1 creando una rama local nueva-rama conectada a la rama origin/nueva-rama . Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: $ git checkout nueva-rama $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . El comando git fetch actualiza la rama local conectada con la remote tracking origin/nueva-rama . El comando git pull es equivalente a hacer: $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: (estando en la rama que queremos subir) $ git push Si somos nosotros los que hemos creado la rama, hay que configurarla para que funcione correctamente el git push haciendo: $ git push -u origin nueva-rama Comprobar el estado de las ramas locales: $ git branch -vv Con la opci\u00f3n -a ( git branch -vva ) se muestra tambi\u00e9n el estado de las ramas remote tracking de solo lectura (en rojo, y precedidas con el nombre remotes/ ): $ git branch -vva main dd867ac [origin/main] Colocados esquemas en su directorio * prueba 8d2d093 [origin/prueba] Correcci\u00f3n remotes/origin/HEAD -> origin/main remotes/origin/main dd867ac Colocados esquemas en su directorio remotes/origin/prueba 8d2d093 Correcci\u00f3n Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: $ git fetch --all $ git branch -vva Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que actualiza las ramas remote tracking . Informaci\u00f3n de los repositorios remotos: $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminal: $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama main . Podemos hacer un merge de la rama main en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en main y que necesitamos en nuestra nueva rama: $ git checkout nueva-rama $ git merge main Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y main . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: $ git checkout main $ git pull $ git checkout nueva-rama $ git merge main # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub","title":"Comandos Git"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_1","text":"A\u00f1adid el milestone 1.3.0 y etiquetad todos los pr\u00f3ximos issues con \u00e9l. Probad el nuevo flujo de trabajo descrito anteriormente creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en main y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 descargar esa rama y realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en main que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en main .","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#4-contenedor-con-la-aplicacion-todolist","text":"Una de las cosas que vamos a hacer en esta pr\u00e1ctica (en el siguiente apartado) es poner en producci\u00f3n en el servidor de la asignatura la aplicaci\u00f3n ToDoList conect\u00e1ndola con la base de datos. En las pr\u00e1cticas 1 y 2 ya hemos construido el contenedor Docker de la aplicaci\u00f3n, con el siguiente fichero Dockerfile: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] Este Dockerfile tiene un problema importante. El comando de ejecuci\u00f3n es fijo y no permite definir ning\u00fan par\u00e1metro de ejecuci\u00f3n. No es posible, por ejemplo, definir el perfil de Postgres, ni definir ning\u00fan par\u00e1metro de configuraci\u00f3n. Debemos cambiarlo de la siguiente forma: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] De esta forma podremos llamar al comando docker a\u00f1adiendo al final par\u00e1metros que se van a pasar al comando java. La forma de a\u00f1adir variables de entorno a ese comando java es precedi\u00e9ndolos con dos guiones -- . Por ejemplo: $ docker run --rm <usuario>/mads-todolist-equipoXX --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Vamos a probarlo, creando y subiendo la nueva imagen a DockerHub y despleg\u00e1ndola en el servidor de la asignatura.","title":"4. Contenedor con la aplicaci\u00f3n ToDoList"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_2","text":"Deb\u00e9is hacer lo siguiente: Creamos un issue llamado Configuraci\u00f3n imagen docker y trabajamos en la rama imagen-docker . Cambiad el fichero Dockerfile de la aplicaci\u00f3n tal y como se indica en el listado anterior: Fichero Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] Cread la nueva imagen Docker con el nombre mads-todolist-equipoXX y la etiqueta 1.3.0-snapshot . El usuario puede ser cualquier miembro del equipo, no es necesario que sea el autor del proyecto original. $ ./mvnw package $ docker build -t <usuario-docker>/mads-todolist-equipoXX:1.3.0-snapshot . Probad que funcionan correctamente los par\u00e1metros de configuraci\u00f3n en la imagen Docker. Una forma sencilla de hacerlo es comprobar que se puede definir el perfil de Postgres y modificar alguno de sus par\u00e1metros. Deber\u00e1 aparecer un mensaje de error de que no se puede conectar con la base de datos (lo que est\u00e1 bien, porque significa que s\u00ed que se ha cargado el perfil). $ docker run --rm <usuario>/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Subid, por \u00faltimo, la imagen a Docker Hub: $ docker login $ docker push <usuario-docker>/mads-todolist-equipoXX","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#5-despliegue-en-produccion-con-bd","text":"Vamos a ver c\u00f3mo ejecutar en producci\u00f3n el contenedor con la aplicaci\u00f3n de forma que se conecte con una base de datos postgres. En las pr\u00e1cticas 1 y 2 vimos c\u00f3mo construir una versi\u00f3n en forma de contenedor de nuestra aplicaci\u00f3n Spring Boot y en la pr\u00e1ctica 3 vimos como usar un contenedor de Postgres para definir un servicio de base de datos con el que conectar la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a definir la configuraci\u00f3n en producci\u00f3n definitiva de nuestra aplicaci\u00f3n. Veremos c\u00f3mo poner en marcha dos contenedores y conectarlos entre si. En nuestro caso un contenedor tendr\u00e1 la base de datos postgres y el otro la aplicaci\u00f3n Spring Boot. La imagen anterior muestra los dos contenedores conectados por una red. Desde el contenedor con la aplicaci\u00f3n se acceder\u00e1 a la direcci\u00f3n postgres:5432 para conectarse con la base de datos. Veremos los comandos de docker para definir una red y para lanzar el contenedor de base de datos en esa direcci\u00f3n de la red. El contenedor de base de datos montar\u00e1 el directorio actual del host en el directorio /mi-host del contenedor. De esta forma, cualquier fichero que coloquemos en ese directorio del contenedor ser\u00e1 visible en el directorio actual del host (y viceversa). Usaremos este directorio para guardar datos de la base de datos, como copias de seguridad o ficheros de migraci\u00f3n. El contenedor de base de datos implementar\u00e1 la base de datos en producci\u00f3n. Base de datos de producci\u00f3n La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir tambi\u00e9n un flujo de trabajo para actualizar la base de datos de producci\u00f3n con los cambios del modelo de datos introducidos por la nuevas funcionalidades (nuevas tablas y nuevas relaciones).","title":"5. Despliegue en producci\u00f3n con BD"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_3","text":"Veamos paso a paso c\u00f3mo crear la configuraci\u00f3n anterior. En muchos casos tendremos que usar el nombre de nuestro equipo. En los ejemplos hemos usado equipo01 . Deb\u00e9is cambiarlo por el nombre de vuestro equipo. Nos conectamos al servidor de la asignatura con uno de los usuarios del equipo. La direcci\u00f3n IP est\u00e1 en un mensaje enviado al foro de la asignatura. $ ssh alu02@<direccion-IP> Creamos una red gestionada por Docker: $ docker network create network-equipo01 Lanzamos el contenedor con la base de datos usando la red creada anteriormente y con el nombre db-equipo01 . Definimos el nombre del host creado en el contenedor como postgres con el modificador --network-alias . $ docker run -d --network network-equipo01 --network-alias postgres -v ${PWD}:/mi-host --name db-equipo01 -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 El modificador -v permite montar el directorio actual en el directorio /mi-host del contenedor. Vamos a probar que funciona correctamente. Nos conectamos al contenedor lanzando un bash interactivo. Estando en el contenedor creamos un fichero en el directorio /mi-host , salimos del contenedor y comprobamos que est\u00e1 en el directorio actual $ docker exec -it db-equipo01 bash root@e470db191dc6:/# cd /mi-host root@e470db191dc6:/mi-host# echo \"Hola\" > prueba.txt root@e470db191dc6:/mi-host# exit $ ls prueba.txt $ more prueba.txt Hola Con esto ya tenemos configurado y en marcha el contenedor con la base de datos Postgres. Esta va a ser nuestra base de datos de producci\u00f3n. Vamos ahora a poner en marcha la aplicaci\u00f3n. Descargamos la \u00faltima versi\u00f3n de nuestra aplicaci\u00f3n y lanzamos el contenedor usando la red definida anteriormente. Los modificadores --spring.profiles.active y --POSTGRES_HOST permiten pasar al contenedor esas variables del entorno. $ docker pull <usuario>/mads-todolist-equipo01:1.3.0-snapshot $ docker run --rm --name spring-boot-equipo01 --network network-equipo01 -p8080:8080 <usuario>/mads-todolist-equipo01:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=postgres \u00a1\u00a1\u00a1Enhorabuena!!! \u00a1Ya tenemos la aplicaci\u00f3n en producci\u00f3n trabajando con la base de datos! Podremos conectarnos a la aplicaci\u00f3n usando la direcci\u00f3n IP del servidor de la asignatura y el puerto 8080. Probamos la aplicaci\u00f3n y creamos alg\u00fan usuario de prueba. Por \u00faltimo paramos el contenedor y lo volvemos a arrancar para comprobar que los datos son persistentes. Para comprobar que la base de datos est\u00e1 funcionando correctamente podemos conectarnos al contenedor y examinar la base de datos mads y alguna de sus tablas: $ docker exec -it db-equipo01 bash # psql -U mads -W mads (nos pedir\u00e1 la contrase\u00f1a: mads) # \\l (lista las bases de datos) # \\dt (lista las tablas) # SELECT * FROM usuarios; La base de datos se mantendr\u00e1 mientras que no borremos el contenedor. Podemos pararlo y volver a ponerlo en marcha y seguiremos conservando los datos: $ docker stop db-equipo01 $ docker start db-equipo01","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion","text":"","title":"6. Perfil de producci\u00f3n y mantenimiento de la base de datos de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#perfil-de-produccion","text":"Una vez que vamos a trabajar en producci\u00f3n con una base de datos, esta base de datos ser\u00e1 un elemento clave de la aplicaci\u00f3n. No debemos, bajo ning\u00fan concepto, perder datos que se hayan introducido en ella, ya que son datos de nuestros usuarios y clientes. Es imprescindible para ello cambiar el modo con el que la aplicaci\u00f3n construye las tablas de la base de datos. Sabemos que nuestra aplicaci\u00f3n est\u00e1 trabajando con JPA/Hibernate y que las tablas de la base de datos se construyen de forma autom\u00e1tica. Si hay alg\u00fan cambio en las entidades (se a\u00f1ade alg\u00fan atributo o alguna nueva entidad) Spring Boot actualiza las tablas de la base de datos de forma autom\u00e1tica cuando se lanza la aplicaci\u00f3n. Esto es razonable si estamos trabajando en un entorno de desarrollo, pero est\u00e1 totalmente desaconsejado en un entorno de producci\u00f3n. El par\u00e1metro spring.jpa.hibernate.ddl-auto es el que determina el funcionamiento de la actualizaci\u00f3n de las tablas de la base de datos. Su valor puede ser: CREATE : El esquema de datos se crea de nuevo cada vez que se lanza la aplicaci\u00f3n. Una vez creado, se a\u00f1aden los datos definidos en el fichero spring.datasource.data si el spring.datasource.initialization-mode tiene como valor always . Esta es la forma de funcionar de los tests. UPDATE : El esquema de datos de la base de datos se actualiza autom\u00e1ticamente cuando hay un cambio en las entidades de la aplicaci\u00f3n. As\u00ed es como tenemos configurado el perfil por defecto de nuestra aplicaci\u00f3n. Si estamos trabajando con la base de datos Postgres, se actualizar\u00e1 el esquema de datos. Pero esto no es recomendable para producci\u00f3n, porque no tenemos control de las instrucciones de actualizaci\u00f3n y pueden resultar en alguna p\u00e9rdida de datos. VALIDATE : El esquema de datos de la base de datos se valida con respecto al esquema de datos definido por las entidades JPA. Si hay alguna diferencia, salta una excepci\u00f3n. Este es el valor que hay que usar cuando lanzamos la aplicaci\u00f3n en producci\u00f3n. Vamos a definir en la aplicaci\u00f3n un nuevo perfil de ejecuci\u00f3n, llamado postgres-prod , en el que pondremos el valor del par\u00e1metro spring.jpa.hibernate.ddl-auto a VALIDATE . Y ser\u00e1 este el perfil que usaremos para lanzar la aplicaci\u00f3n en el servidor de producci\u00f3n.","title":"Perfil de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#mantenimiento-de-la-base-de-datos-de-produccion","text":"En una aplicaci\u00f3n en producci\u00f3n se deben configurar pol\u00edticas estrictas de realizaci\u00f3n de copias de seguridad y de integridad de los datos. Tambi\u00e9n en la gesti\u00f3n de las versiones y en la actualizaci\u00f3n del esquema de datos. Esto \u00faltimo se denomina una migraci\u00f3n de la base de datos y representa un elemento fundamental del mantenimiento en producci\u00f3n de una aplicaci\u00f3n, sobre todo cuando estamos trabajando de una forma \u00e1gil e incremental. Es un tema avanzado muy importante, pero que no podemos abordar en la asignatura por falta de tiempo. Un par de referencias que os pueden ser de utilidad son el art\u00edculo Evolutionary Database Design y herramientas como Flyway que permiten automatizar las migraciones de la base de datos. En la pr\u00e1ctica vamos a trabajar con la base de datos de producci\u00f3n de dos formas: Realizaremos una copia de seguridad antes de instalar una nueva versi\u00f3n. Actualizaremos el esquema de datos aplicando un fichero de migraci\u00f3n que construiremos manualmente.","title":"Mantenimiento de la base de datos de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_4","text":"Creamos un issue llamado Esquema de datos y perfil de producci\u00f3n y trabajamos en la rama esquema-datos y en el pull request equivalente. $ git checkout -b esquema-datos $ git push -u origin esquema-datos Lanzamos la aplicaci\u00f3n en local con el modo postgres , trabajando sobre la base de datos. Previamente hemos lanzado el contenedor postgres montando el directorio actual en su directorio /mi-host/ : $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 $ ./mvnw spring-boot:run -D profiles=postgres Al lanzar la aplicaci\u00f3n se habr\u00e1 creado en la base de datos el esquema de datos. Lo generamos y lo salvamos en el directorio actual: $ docker exec -it postgres-develop bash # pg_dump -U mads -s mads > /mi-host/schema-1.2.0.sql # exit Comprobamos que el esquema de datos se ha creado correctamente y lo movemos al directorio sql en el directorio ra\u00edz: $ ls -l Dockerfile README.md mvnw mvnw.cmd pom.xml schema-1.2.0.sql src target $ mkdir sql $ mv schema-1.2.0.sql sql Creamos un commit con el nuevo fichero con el esquema de datos. Creamos un nuevo fichero con el perfil de producci\u00f3n: Fichero /src/main/resources/application-postgres-prod.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.datasource.initialization-mode=never spring.jpa.hibernate.ddl-auto=validate Contiene exactamente la misma configuraci\u00f3n del perfil postgres, excepto la propiedad spring.jpa.hibernate.ddl-auto que tiene el valor validate . Probamos en local que el perfil funciona correctamente, lanz\u00e1ndolo: $ ./mvnw spring-boot:run -D profiles=postgres-prod Probamos que realmente valida el esquema de datos, en lugar de actualizarlo. Para ello, paramos y borramos el contenedor postgres y lo lanzamos de nuevo. Esto crear\u00e1 una base de datos vac\u00eda: $ docker container stop docker-develop $ docker container rm docker-develop $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Si ahora lanzamos la aplicaci\u00f3n en modo postgres-prod obtendremos un error: $ ./mvnw spring-boot:run -D profiles=postgres-prod org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.tool.schema.spi.SchemaManagementException: Schema-validation: missing table [equipo_usuario] Si queremos volver a construir la base de datos, no tenemos m\u00e1s que lanzar la aplicaci\u00f3n con el perfile postgres , que tiene la propiedad spring.jpa.hibernate.ddl-auto con el valor update . Hacemos un commit con el nuevo perfil, subimos los cambios y cerramos el pull request y el issue. Nos conectamos al servidor de la asignatura y ponemos en marcha la base de datos de producci\u00f3n y hacemos una copia de seguridad tal y como se explica anteriormente. Dejamos el fichero en el servidor de la asignatura, indicando la fecha en el nombre del mismo. Por ejemplo backup10112021.sql .","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#7-desarrollo-de-la-nueva-version-con-gitflow","text":"El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda )","title":"7. Desarrollo de la nueva versi\u00f3n con GitFlow"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#ramas-de-largo-recorrido","text":"En GitFlow se publican las distintas versiones del proyecto en la rama long-lived main y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en main sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings > Branches > Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop .","title":"Ramas de largo recorrido"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#ramas-de-feature","text":"Desde el comienzo de trabajo con Git en las pr\u00e1cticas 2 y 3 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request.","title":"Ramas de feature"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_5","text":"Cread la rama develop y configurarla como rama principal del proyecto en GitHub. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. Cread tres issues distintos, simulando tres nuevas funcionalidades. Deben ser issues sencillos, que no cuesten demasiado de implementar (mejorar alg\u00fan defecto de la aplicaci\u00f3n, cambiar alg\u00fan elemento de alguna de las vistas, o algo similar). Uno de los cambios debe afectar a alguna entidad , por ejemplo a\u00f1adir un campo de descripci\u00f3n a los equipos y actualizar las vistas correspondientes para permitir su inicializaci\u00f3n y su actualizaci\u00f3n. Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues. Configurad el repositorio GitHub para obligar a que cualquier pull request tenga que tener la revisi\u00f3n de una persona distinta del responsable del PR. Desarrollad e integrar los issues en develop siguiendo el flujo de trabajo planteado anteriormente. Deb\u00e9is ir actualizando el tablero de GitHub se actualiza correctamente.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#rama-de-release","text":"Hasta ahora hemos hecho los releases en la rama main . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en main y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request. Una cosa importante que tendremos que hacer en el release es crear el guardar el de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos.","title":"Rama de release"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_6","text":"Vamos a probar el lanzamiento de una release usando el flujo de trabajo GitFlow. Cread un issue con la tarea Lanzar release 1.3.0 . Siguiendo las indicaciones de GitFlow, crear la rama local release-1.3.0 a partir de develop . En esta rama se deben realizar los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina Acerca de \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero pom.xml . Generad el esquema de datos de la base de datos postgres y guardarlo en sql/schema-1.3.0.sql . Comparar este esquema con el esquema anterior y crear el script de migraci\u00f3n con las instrucciones ALTER TABLE necesarias para actualizar la base de datos de producci\u00f3n de la versi\u00f3n 1.2.0 a la 1.3.0. Guardar el script en sql/schema-1.2.0-1.3.0.sql . Publicad la rama release-1.3.0 en GitHub y hacer un pull request sobre main . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en main creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Subir la nueva versi\u00f3n de la imagen de docker a Docker Hub. Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas main y develop estar\u00e1n actualizadas a la nueva versi\u00f3n. Hacer por \u00faltimo un commit en develop (no hace falta PR) cambiando la versi\u00f3n a 1.4.0-SNAPSHOT . Debemos comprobar que GitHub Actions pasa correctamente todos los tests de las nuevas caracter\u00edsticas que se a\u00f1aden.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#8-despliegue-de-la-nueva-version-y-actualizacion-de-la-bd-de-produccion","text":"Deber\u00e9is desplegar la nueva versi\u00f3n de la aplicaci\u00f3n en el servidor de la asignatura, actualizando la base de datos de producci\u00f3n con los cambios introducidos.","title":"8. Despliegue de la nueva versi\u00f3n y actualizaci\u00f3n de la BD de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_7","text":"Conectarse al servidor de la asignatura. Descargar la nueva versi\u00f3n de la aplicaci\u00f3n. Hacer una copia de seguridad de la base de datos, tal y como se explica en el apartado Mantenimiento de la base de datos de producci\u00f3n . Dejar el fichero de copia de seguridad en el directorio ra\u00edz del usuario alu con el que se est\u00e1 conectado al servidor de la asignatura. Hacer una migraci\u00f3n de la base de datos tal y como se explica en el mismo apartado anterior. Lanzar el contenedor de la aplicaci\u00f3n con el perfil postgres-prod y comprobar que funciona correctamente la aplicaci\u00f3n en producci\u00f3n.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#8-documentacion-entrega-y-evaluacion","text":"Deber\u00e9is a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica4.md en la que deber\u00e9is incluir: Breve documentaci\u00f3n t\u00e9cnica de los cambios introducidos en la aplicaci\u00f3n. Detalles del despliegue de producci\u00f3n: usuario alu con el que se ha realizado la puesta en producci\u00f3n, as\u00ed como directorio y fichero en el que se encuentra (en el servidor de la asignatura) el backup de la base de datos de producci\u00f3n. Script de migraci\u00f3n de la base de datos. La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 23 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de pr\u00e1cticas. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las semanas y no dejar todo para la \u00faltima). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"8. Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"05-iteracion-scrum/iteracion-scrum.html","text":"Pr\u00e1ctica 5: Sprint \u00b6 Versi\u00f3n del curso 2020-21 Pendiente de actualizar Objetivos y resumen de la pr\u00e1ctica \u00b6 En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 4. Durante las 3 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n TodoList . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 4 para desarrollar sobre la rama develop : Una tarjeta en el tablero de Trello para cada historia de usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que comenzamos en la pr\u00e1ctica 3. La historia de usuario se puede descomponer en mas de un issue en GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso, se deber\u00e1n etiquetar los issues con la etiqueta asociada a la historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues. El repositorio est\u00e1 conectado a GitHub Actions para hacer la integraci\u00f3n continua. Se comprueban de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop . Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior. Artefactos del sprint \u00b6 El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint. Tablero Trello \u00b6 El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Cada tarjeta Trello contendr\u00e1 lo que ya hab\u00e9is hecho para la pr\u00e1ctica 4: T\u00edtulo de la historia de usuario Descripci\u00f3n Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta) Y se deber\u00e1 a\u00f1adir: Responsable de la historia de usuario (otra etiqueta) : miembro del equipo que liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la responsable. Enlace a una p\u00e1gina Google Docs en la que el responsable de la historia copiar\u00e1, y ampliar\u00e1 y/o modificar\u00e1 sus detalles. La descripci\u00f3n en Trello hay que dejarla tal cual, sin modificar. En la p\u00e1gina de Google Docs deber\u00e1 incluirse: T\u00edtulo de historia de usuario Descripci\u00f3n y detalles Borrador del aspecto de la interfaz de usuario resultante Condiciones de satisfacci\u00f3n (COS). Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia y de darla por acabada. Deben estar lo suficientemente claras como para poder elaborar a partir de ellas las pruebas manuales de la historia de usuario. Importante Los detalles de la historia de usuario en Google Docs se escribir\u00e1n s\u00f3lo cuando la historia haya sido seleccionada y est\u00e9 en la columna Seleccionadas . Es recomendable que el paso de una historia a seleccionada se haga cuando se haya terminado la historia anterior con la que se estaba trabajando. De esta forma, cuando escribamos los detalles de la siguiente historia seleccionada ya tendremos el proyecto m\u00e1s avanzado y podremos elaborar mejor los detalles de la nueva historia. Es posible cambiar cosas en la p\u00e1gina de Google Docs con respecto a la descripci\u00f3n de la tarjeta en Trello. Dejad la descripci\u00f3n sin modificar, para tener una referencia de la evoluci\u00f3n del dise\u00f1o del proyecto. Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: Backlog , Seleccionadas , En marcha , En prueba y Terminadas . Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Seleccionadas Se est\u00e1n elaborando todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en develop . En la tarjeta se debe a\u00f1adir un enlace al commit. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n de la historia. Se debe documentar la evoluci\u00f3n del tablero realizando 4 capturas de pantalla y registrando la fecha de cada una. Importante Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs. Tablero GitHub \u00b6 El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. En los issues podremos tener: Desarrollo de historias de usuario (en parte o completas) Bugs y refactorizaciones Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de usuario en concreto Usaremos las etiquetas para definir el tipo de issue: C\u00f3digo de historia de usuario Bug Refactor Mejora t\u00e9cnica Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere. En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues/ pull requests movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando. Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto (se archivar\u00e1 la tarjeta del issue y se dejar\u00e1 s\u00f3lo la tarjeta del pull request). Done El pull request que se ha resuelto y el issue est\u00e1 integrado en develop . Al igual que el tablero de Trello, se debe documentar la evoluci\u00f3n del tablero de issues realizando 4 capturas de pantalla y registrando la fecha de cada una. Reuni\u00f3n de revisi\u00f3n del backlog \u00b6 Al comienzo de la pr\u00e1ctica el equipo habr\u00e1 definido un backlog formado por historias de usuario con tama\u00f1os de 1 y 2 puntos. Los puntos indican un tama\u00f1o relativo. Si una historia se estima en 2 puntos es porque se piensa que se tardar\u00e1 el doble en terminarla que otra de 1 punto. La puntaci\u00f3n total de las historias a desarrollar ser\u00e1 entre 12 y 15 puntos (entre 4 y 5 puntos por persona). Las historias deben consistir en nuevas funcionalidades que construyan un producto atractivo, coherente y \u00fatil para el usuario. Estar\u00e1n ordenadas por importancia en la columna de backlog. En la primera semana de la esta pr\u00e1ctica el profesor se reunir\u00e1 con el equipo y podr\u00e1 pediros alguna aclaraci\u00f3n sobre las propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades antes de validarlas. El profesor a\u00f1adir\u00e1 una nota en el tablero Trello con el resultado de esta revisi\u00f3n, pudiendo realizar alguna aclaraci\u00f3n sobre el alcance de las historias de usuario. Responsables de historia de usuario \u00b6 Una vez realizada la revisi\u00f3n los miembros del equipo elegir\u00e1n responsables para cada historia, se seleccionara la primera de ellas a realizar, se crear\u00e1 su p\u00e1gina Google Docs, y se detallar\u00e1 all\u00ed las condiciones de satisfacci\u00f3n y el borrador de la interfaz de usuario definitivas. No deb\u00e9is borrar lo escrito en la tarjeta de Trello. Utilizad el documento Google Docs para ampliar o detallar m\u00e1s aquellos elementos que consider\u00e9is oportuno. Una vez creado el documento Google de la historia de usuario ya se puede comenzar a realizar la implementaci\u00f3n de la misma abriendo el o los issues en GitHub y a\u00f1adiendo al mismo el responsable de su desarrollo. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. Desarrollo del sprint \u00b6 Se deber\u00e1n realizar los siguientes eventos, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Retrospectiva del sprint: an\u00e1lisis de qu\u00e9 cosas han funcionado regular y hay que mejorar y qu\u00e9 cosas han funcionado bien durante el sprint. Desarrollo de issues e historias \u00b6 Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en main . Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Seguimos usando GitHub Actions para la integraci\u00f3n continua. Como hemos hecho hasta ahora, cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Una vez terminados todos los issues de una historia de usuario, el responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a En prueba , se a\u00f1adir\u00e1 en la tarjeta el enlace al commit de develop en el que se ha realizado la integraci\u00f3n y otro miembro del equipo realizar\u00e1 las pruebas manuales especificadas en sus COS utilizando la base de datos MySQL . Cuando se hayan superado todas las pruebas se pasar\u00e1 la historia a Terminada . Si se detectara alg\u00fan fallo, se volver\u00e1 la historia a En marcha y se abrir\u00e1 un issue de tipo bug para resolver el problema. Publicaci\u00f3n de nueva versi\u00f3n \u00b6 Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama main . Documentaci\u00f3n del desarrollo \u00b6 Documentar las sesiones de pair programming . Documentar la evoluci\u00f3n de los tableros Trello y GitHub capturando 4 instant\u00e1neas y registrando su fecha. Entrega y evaluaci\u00f3n \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 15 minutos en las clases de pr\u00e1cticas del 23 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint y las nuevas funcionalidades introducidas. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima versi\u00f3n subida a GitHub. En la fecha l\u00edmite del 10 de enero deber\u00e1 entregar la pr\u00e1ctica y tener disponible: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog : historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en los documentos subidos a GoogleDocs). Funcionalidades implementadas : breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica. Informe sobre la evoluci\u00f3n del desarrollo : instant\u00e1neas de los tableros y alguna m\u00e9trica o gr\u00e1fica sobre el desarrollo (n\u00famero de pull requests cada semana, por ejemplo). Informe sobre las sesiones de pair programming Resultado de la retrospectiva : qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. El repositorio GitHub deber\u00e1 incluir el tablero con el backlog del sprint con los PR completados. El tablero de Trello deber\u00e1 incluir el backlog del producto con las historias de usuario que se deb\u00edan implementar en el sprint y los enlaces a los documentos Google Docs con sus detalles. Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Pr\u00e1ctica 5"},{"location":"05-iteracion-scrum/iteracion-scrum.html#practica-5-sprint","text":"Versi\u00f3n del curso 2020-21 Pendiente de actualizar","title":"Pr\u00e1ctica 5: Sprint"},{"location":"05-iteracion-scrum/iteracion-scrum.html#objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 4. Durante las 3 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n TodoList . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 4 para desarrollar sobre la rama develop : Una tarjeta en el tablero de Trello para cada historia de usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que comenzamos en la pr\u00e1ctica 3. La historia de usuario se puede descomponer en mas de un issue en GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso, se deber\u00e1n etiquetar los issues con la etiqueta asociada a la historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues. El repositorio est\u00e1 conectado a GitHub Actions para hacer la integraci\u00f3n continua. Se comprueban de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop . Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior.","title":"Objetivos y resumen de la pr\u00e1ctica"},{"location":"05-iteracion-scrum/iteracion-scrum.html#artefactos-del-sprint","text":"El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint.","title":"Artefactos del sprint"},{"location":"05-iteracion-scrum/iteracion-scrum.html#tablero-trello","text":"El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Cada tarjeta Trello contendr\u00e1 lo que ya hab\u00e9is hecho para la pr\u00e1ctica 4: T\u00edtulo de la historia de usuario Descripci\u00f3n Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta) Y se deber\u00e1 a\u00f1adir: Responsable de la historia de usuario (otra etiqueta) : miembro del equipo que liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la responsable. Enlace a una p\u00e1gina Google Docs en la que el responsable de la historia copiar\u00e1, y ampliar\u00e1 y/o modificar\u00e1 sus detalles. La descripci\u00f3n en Trello hay que dejarla tal cual, sin modificar. En la p\u00e1gina de Google Docs deber\u00e1 incluirse: T\u00edtulo de historia de usuario Descripci\u00f3n y detalles Borrador del aspecto de la interfaz de usuario resultante Condiciones de satisfacci\u00f3n (COS). Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia y de darla por acabada. Deben estar lo suficientemente claras como para poder elaborar a partir de ellas las pruebas manuales de la historia de usuario. Importante Los detalles de la historia de usuario en Google Docs se escribir\u00e1n s\u00f3lo cuando la historia haya sido seleccionada y est\u00e9 en la columna Seleccionadas . Es recomendable que el paso de una historia a seleccionada se haga cuando se haya terminado la historia anterior con la que se estaba trabajando. De esta forma, cuando escribamos los detalles de la siguiente historia seleccionada ya tendremos el proyecto m\u00e1s avanzado y podremos elaborar mejor los detalles de la nueva historia. Es posible cambiar cosas en la p\u00e1gina de Google Docs con respecto a la descripci\u00f3n de la tarjeta en Trello. Dejad la descripci\u00f3n sin modificar, para tener una referencia de la evoluci\u00f3n del dise\u00f1o del proyecto. Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: Backlog , Seleccionadas , En marcha , En prueba y Terminadas . Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Seleccionadas Se est\u00e1n elaborando todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en develop . En la tarjeta se debe a\u00f1adir un enlace al commit. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n de la historia. Se debe documentar la evoluci\u00f3n del tablero realizando 4 capturas de pantalla y registrando la fecha de cada una. Importante Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs.","title":"Tablero Trello"},{"location":"05-iteracion-scrum/iteracion-scrum.html#tablero-github","text":"El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. En los issues podremos tener: Desarrollo de historias de usuario (en parte o completas) Bugs y refactorizaciones Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de usuario en concreto Usaremos las etiquetas para definir el tipo de issue: C\u00f3digo de historia de usuario Bug Refactor Mejora t\u00e9cnica Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere. En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues/ pull requests movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando. Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto (se archivar\u00e1 la tarjeta del issue y se dejar\u00e1 s\u00f3lo la tarjeta del pull request). Done El pull request que se ha resuelto y el issue est\u00e1 integrado en develop . Al igual que el tablero de Trello, se debe documentar la evoluci\u00f3n del tablero de issues realizando 4 capturas de pantalla y registrando la fecha de cada una.","title":"Tablero GitHub"},{"location":"05-iteracion-scrum/iteracion-scrum.html#reunion-de-revision-del-backlog","text":"Al comienzo de la pr\u00e1ctica el equipo habr\u00e1 definido un backlog formado por historias de usuario con tama\u00f1os de 1 y 2 puntos. Los puntos indican un tama\u00f1o relativo. Si una historia se estima en 2 puntos es porque se piensa que se tardar\u00e1 el doble en terminarla que otra de 1 punto. La puntaci\u00f3n total de las historias a desarrollar ser\u00e1 entre 12 y 15 puntos (entre 4 y 5 puntos por persona). Las historias deben consistir en nuevas funcionalidades que construyan un producto atractivo, coherente y \u00fatil para el usuario. Estar\u00e1n ordenadas por importancia en la columna de backlog. En la primera semana de la esta pr\u00e1ctica el profesor se reunir\u00e1 con el equipo y podr\u00e1 pediros alguna aclaraci\u00f3n sobre las propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades antes de validarlas. El profesor a\u00f1adir\u00e1 una nota en el tablero Trello con el resultado de esta revisi\u00f3n, pudiendo realizar alguna aclaraci\u00f3n sobre el alcance de las historias de usuario.","title":"Reuni\u00f3n de revisi\u00f3n del backlog"},{"location":"05-iteracion-scrum/iteracion-scrum.html#responsables-de-historia-de-usuario","text":"Una vez realizada la revisi\u00f3n los miembros del equipo elegir\u00e1n responsables para cada historia, se seleccionara la primera de ellas a realizar, se crear\u00e1 su p\u00e1gina Google Docs, y se detallar\u00e1 all\u00ed las condiciones de satisfacci\u00f3n y el borrador de la interfaz de usuario definitivas. No deb\u00e9is borrar lo escrito en la tarjeta de Trello. Utilizad el documento Google Docs para ampliar o detallar m\u00e1s aquellos elementos que consider\u00e9is oportuno. Una vez creado el documento Google de la historia de usuario ya se puede comenzar a realizar la implementaci\u00f3n de la misma abriendo el o los issues en GitHub y a\u00f1adiendo al mismo el responsable de su desarrollo. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno.","title":"Responsables de historia de usuario"},{"location":"05-iteracion-scrum/iteracion-scrum.html#desarrollo-del-sprint","text":"Se deber\u00e1n realizar los siguientes eventos, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Retrospectiva del sprint: an\u00e1lisis de qu\u00e9 cosas han funcionado regular y hay que mejorar y qu\u00e9 cosas han funcionado bien durante el sprint.","title":"Desarrollo del sprint"},{"location":"05-iteracion-scrum/iteracion-scrum.html#desarrollo-de-issues-e-historias","text":"Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en main . Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Seguimos usando GitHub Actions para la integraci\u00f3n continua. Como hemos hecho hasta ahora, cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Una vez terminados todos los issues de una historia de usuario, el responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a En prueba , se a\u00f1adir\u00e1 en la tarjeta el enlace al commit de develop en el que se ha realizado la integraci\u00f3n y otro miembro del equipo realizar\u00e1 las pruebas manuales especificadas en sus COS utilizando la base de datos MySQL . Cuando se hayan superado todas las pruebas se pasar\u00e1 la historia a Terminada . Si se detectara alg\u00fan fallo, se volver\u00e1 la historia a En marcha y se abrir\u00e1 un issue de tipo bug para resolver el problema.","title":"Desarrollo de issues e historias"},{"location":"05-iteracion-scrum/iteracion-scrum.html#publicacion-de-nueva-version","text":"Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama main .","title":"Publicaci\u00f3n de nueva versi\u00f3n"},{"location":"05-iteracion-scrum/iteracion-scrum.html#documentacion-del-desarrollo","text":"Documentar las sesiones de pair programming . Documentar la evoluci\u00f3n de los tableros Trello y GitHub capturando 4 instant\u00e1neas y registrando su fecha.","title":"Documentaci\u00f3n del desarrollo"},{"location":"05-iteracion-scrum/iteracion-scrum.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 15 minutos en las clases de pr\u00e1cticas del 23 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint y las nuevas funcionalidades introducidas. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima versi\u00f3n subida a GitHub. En la fecha l\u00edmite del 10 de enero deber\u00e1 entregar la pr\u00e1ctica y tener disponible: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog : historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en los documentos subidos a GoogleDocs). Funcionalidades implementadas : breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica. Informe sobre la evoluci\u00f3n del desarrollo : instant\u00e1neas de los tableros y alguna m\u00e9trica o gr\u00e1fica sobre el desarrollo (n\u00famero de pull requests cada semana, por ejemplo). Informe sobre las sesiones de pair programming Resultado de la retrospectiva : qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. El repositorio GitHub deber\u00e1 incluir el tablero con el backlog del sprint con los PR completados. El tablero de Trello deber\u00e1 incluir el backlog del producto con las historias de usuario que se deb\u00edan implementar en el sprint y los enlaces a los documentos Google Docs con sus detalles. Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Entrega y evaluaci\u00f3n"},{"location":"06-practica-c4/practica-c4.html","text":"Pr\u00e1ctica extraordinaria para la convocatoria C4 \u00b6 Versi\u00f3n del curso 2020-21 Pendiente de actualizar Aplicaci\u00f3n a desarrollar \u00b6 Debes desarrollar una aplicaci\u00f3n similar a ToDoList. Por ejemplo, una gesti\u00f3n de recetas, una gesti\u00f3n de los libros de tu biblioteca, etc. La aplicaci\u00f3n debe tener como m\u00ednimo: Login y registro de usuarios Acceso autorizado a p\u00e1ginas de consultas y actualizaci\u00f3n Un m\u00ednimo de tres entidades, con al menos una relaci\u00f3n uno-a-muchos y una relaci\u00f3n muchos-a-muchos. Para el desarrollo de la aplicaci\u00f3n deber\u00e1s usar las mismas tecnolog\u00edas que en la pr\u00e1ctica ToDoList: SpringBoot, Thymeleaf, Hibernate. El total de puntos de historias de usuario deber\u00e1 ser similar a los realizados la pr\u00e1ctica de la convocatoria ordinaria, alrededor de 20 puntos. Historias relacionadas con la gesti\u00f3n b\u00e1sica de recetas, libros, etc. (alrededor de 8 puntos). Historias relacionadas con la gesti\u00f3n de usuarios (alrededor de 4 puntos). Historias adicionales que incluyan la relaci\u00f3n muchos-a-muchos (alrededor de 8 puntos). Repositorio en GitHub \u00b6 A diferencia de la pr\u00e1ctica 1 en la que us\u00e1bamos Github Classroom, deber\u00e1s crear tu mismo el repositorio con una aplicaci\u00f3n b\u00e1sica de Spring Boot. Puedes empezar haciendo un fork del repositorio domingogallardo/spring-boot-demoapp y a\u00f1adir las dependencias necesarias para trabajar con Hibernate y con la base de datos H2 (consultar el repositorio inicial de la pr\u00e1ctica domingogallardo/mads-todolist-inicial ). Metodolog\u00eda de desarrollo \u00b6 Deber\u00e1s usar la misma metodolog\u00eda que la usada en las pr\u00e1cticas de la convocatoria ordinaria. Consulta los apuntes de las pr\u00e1cticas. En concreto, deber\u00e1s las siguientes metodolog\u00edas desde el principio del desarrollo de la pr\u00e1ctica: Flujo de trabajo GitFlow con Pull Requests (como en la pr\u00e1ctica 3). GitHub actions y al menos 2 historias de usuario realizadas con TDD (similar a la pr\u00e1ctica 2). Historias de usuario en Trello, descripci\u00f3n extendida de cada historia de usuario en Google Docs, tablero de issues en GitHub y dividir cada historia de usuario en uno o m\u00e1s issues. Tanto el tablero Trello como el repositorio GitHub se deben compartir con el profesor de la asignatura (usuario: domingogallardo, e-mail: domingo.gallardo@ua.es). Entrega \u00b6 La fecha de entrega es la fecha del examen oficial de la convocatoria C4 (12/07/2021) Se habilitar\u00e1 una entrega en Moodle, en la que se debe subir un documento PDF con: Explicaci\u00f3n t\u00e9cnica de la aplicaci\u00f3n (debe incluir al menos una descripci\u00f3n de las entidades y de los m\u00e9todos de servicio definidos). Explicaci\u00f3n de las funcionalidades introducidas (pueden ser las descripciones extendidas de cada historia de usuario). Enlace al tablero Trello Enlace al repositorio GitHub","title":"Pr\u00e1ctica C4"},{"location":"06-practica-c4/practica-c4.html#practica-extraordinaria-para-la-convocatoria-c4","text":"Versi\u00f3n del curso 2020-21 Pendiente de actualizar","title":"Pr\u00e1ctica extraordinaria para la convocatoria C4"},{"location":"06-practica-c4/practica-c4.html#aplicacion-a-desarrollar","text":"Debes desarrollar una aplicaci\u00f3n similar a ToDoList. Por ejemplo, una gesti\u00f3n de recetas, una gesti\u00f3n de los libros de tu biblioteca, etc. La aplicaci\u00f3n debe tener como m\u00ednimo: Login y registro de usuarios Acceso autorizado a p\u00e1ginas de consultas y actualizaci\u00f3n Un m\u00ednimo de tres entidades, con al menos una relaci\u00f3n uno-a-muchos y una relaci\u00f3n muchos-a-muchos. Para el desarrollo de la aplicaci\u00f3n deber\u00e1s usar las mismas tecnolog\u00edas que en la pr\u00e1ctica ToDoList: SpringBoot, Thymeleaf, Hibernate. El total de puntos de historias de usuario deber\u00e1 ser similar a los realizados la pr\u00e1ctica de la convocatoria ordinaria, alrededor de 20 puntos. Historias relacionadas con la gesti\u00f3n b\u00e1sica de recetas, libros, etc. (alrededor de 8 puntos). Historias relacionadas con la gesti\u00f3n de usuarios (alrededor de 4 puntos). Historias adicionales que incluyan la relaci\u00f3n muchos-a-muchos (alrededor de 8 puntos).","title":"Aplicaci\u00f3n a desarrollar"},{"location":"06-practica-c4/practica-c4.html#repositorio-en-github","text":"A diferencia de la pr\u00e1ctica 1 en la que us\u00e1bamos Github Classroom, deber\u00e1s crear tu mismo el repositorio con una aplicaci\u00f3n b\u00e1sica de Spring Boot. Puedes empezar haciendo un fork del repositorio domingogallardo/spring-boot-demoapp y a\u00f1adir las dependencias necesarias para trabajar con Hibernate y con la base de datos H2 (consultar el repositorio inicial de la pr\u00e1ctica domingogallardo/mads-todolist-inicial ).","title":"Repositorio en GitHub"},{"location":"06-practica-c4/practica-c4.html#metodologia-de-desarrollo","text":"Deber\u00e1s usar la misma metodolog\u00eda que la usada en las pr\u00e1cticas de la convocatoria ordinaria. Consulta los apuntes de las pr\u00e1cticas. En concreto, deber\u00e1s las siguientes metodolog\u00edas desde el principio del desarrollo de la pr\u00e1ctica: Flujo de trabajo GitFlow con Pull Requests (como en la pr\u00e1ctica 3). GitHub actions y al menos 2 historias de usuario realizadas con TDD (similar a la pr\u00e1ctica 2). Historias de usuario en Trello, descripci\u00f3n extendida de cada historia de usuario en Google Docs, tablero de issues en GitHub y dividir cada historia de usuario en uno o m\u00e1s issues. Tanto el tablero Trello como el repositorio GitHub se deben compartir con el profesor de la asignatura (usuario: domingogallardo, e-mail: domingo.gallardo@ua.es).","title":"Metodolog\u00eda de desarrollo"},{"location":"06-practica-c4/practica-c4.html#entrega","text":"La fecha de entrega es la fecha del examen oficial de la convocatoria C4 (12/07/2021) Se habilitar\u00e1 una entrega en Moodle, en la que se debe subir un documento PDF con: Explicaci\u00f3n t\u00e9cnica de la aplicaci\u00f3n (debe incluir al menos una descripci\u00f3n de las entidades y de los m\u00e9todos de servicio definidos). Explicaci\u00f3n de las funcionalidades introducidas (pueden ser las descripciones extendidas de cada historia de usuario). Enlace al tablero Trello Enlace al repositorio GitHub","title":"Entrega"}]}