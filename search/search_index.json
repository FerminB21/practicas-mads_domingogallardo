{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante. Pr\u00e1ctica 1 Introducci\u00f3n a Spring Boot Comandos Git Primera aplicaci\u00f3n con Spring Boot Aplicaci\u00f3n ToDoList Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Construido con MkDocs Versi\u00f3n HTML compilada usando el tema Material de MkDocs . Repositorio en GitHub .","title":"Index"},{"location":"01-intro-spring-boot/comandos-git.html","text":"Resumen de comandos Git \u00b6 Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi). Comandos b\u00e1sicos \u00b6 Configurar el usuario y direcci\u00f3n de correo en git: 1 2 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name <nombre-usuario> $ git config --global user.email <email> $ git init $ git add . $ git commit -m \"Versi\u00f3n inicial\" Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin <url-repo>.git $ git push -u origin main El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama main (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add <fichero o directorio> El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m \"Mensaje\" Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD <fichero> Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m \"Mensaje\" Se puede abreviar como 1 $ git commit -am \"Mensaje\" ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd ( si se ha a\u00f1adido alg\u00fan fichero ) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [ --oneline ] [ --graph ] [ --all ] Comprobar las diferencias entre dos commits: 1 $ git diff <hash-previo> <hash-nuevo> Devuelve las cambios que se han introducido desde el commit identificado por y hasta el . Ramas \u00b6 Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt ( si hay cambios en el espacio de trabajo se llevan a la nueva rama ) Switched to a new branch 'nueva-rama' Listar todas las ramas de un repositorio (incluyendo ramas remotas) 1 2 3 4 $ git branch -av main * nueva-rama $ git commit -a -m \"Confirmamos los cambios en la nueva rama\" Moverse a otra rama: 1 2 $ git checkout main Switched to branch 'main' Mostrar un fichero de una rama (o commit) dado: 1 $ git show <commit o rama>:<nombre-fichero> Comparar dos ramas: 1 $ git diff main nueva-rama El comando git diff main nueva-rama devuelve las diferencias entre las ramas main y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama main . Merge de ramas : Mezclar la rama nueva-rama en la rama main (a\u00f1ade a la main los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout main $ git merge [ --no-ff ] nueva-rama -m \"Mensaje de commit\" La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT ( content ) : Merge conflict in hola.txt Automatic merge failed ; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m \"Arreglado el conflicto en el merge\" $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama main ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m \"Cambios en experiment\" $ git checkout main # hacemos cambios $ git commit -a -m \"Cambios en main\" $ git checkout experiment $ git rebase main First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama main ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama main y tener una historia lineal: 1 2 3 4 $ git checkout main $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase main CONFLICT ( content ) : Merge conflict in <some-file> # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use \"git reset HEAD <some-file>...\" to unstage) # (use \"git add/rm <some-file>...\" as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add <some-file> $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama ( was c241d7b ) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin <rama> Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b <rama> origin/<rama> Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete <branchName> Modificar la historia \u00b6 Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [ --m \"Nuevo mensaje\" ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout <hash> ( o tag, por ejemplo v2.0 ) You are in 'detached HEAD' state. # Ahora est\u00e1s en un detached HEAD $ git branch * ( HEAD detached at 594b606 ) main $ git checkout -b v2.0.1 Switched to a new branch 'v2.0.1' $ git branch main * v2.0.1 $ git checkout main Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard <hash> M\u00e1s informaci\u00f3n \u00b6 Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"Comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#resumen-de-comandos-git","text":"Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).","title":"Resumen de comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#comandos-basicos","text":"Configurar el usuario y direcci\u00f3n de correo en git: 1 2 $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name <nombre-usuario> $ git config --global user.email <email> $ git init $ git add . $ git commit -m \"Versi\u00f3n inicial\" Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin <url-repo>.git $ git push -u origin main El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama main (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add <fichero o directorio> El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m \"Mensaje\" Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD <fichero> Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m \"Mensaje\" Se puede abreviar como 1 $ git commit -am \"Mensaje\" ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd ( si se ha a\u00f1adido alg\u00fan fichero ) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [ --oneline ] [ --graph ] [ --all ] Comprobar las diferencias entre dos commits: 1 $ git diff <hash-previo> <hash-nuevo> Devuelve las cambios que se han introducido desde el commit identificado por y hasta el .","title":"Comandos b\u00e1sicos"},{"location":"01-intro-spring-boot/comandos-git.html#ramas","text":"Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt ( si hay cambios en el espacio de trabajo se llevan a la nueva rama ) Switched to a new branch 'nueva-rama' Listar todas las ramas de un repositorio (incluyendo ramas remotas) 1 2 3 4 $ git branch -av main * nueva-rama $ git commit -a -m \"Confirmamos los cambios en la nueva rama\" Moverse a otra rama: 1 2 $ git checkout main Switched to branch 'main' Mostrar un fichero de una rama (o commit) dado: 1 $ git show <commit o rama>:<nombre-fichero> Comparar dos ramas: 1 $ git diff main nueva-rama El comando git diff main nueva-rama devuelve las diferencias entre las ramas main y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama main . Merge de ramas : Mezclar la rama nueva-rama en la rama main (a\u00f1ade a la main los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout main $ git merge [ --no-ff ] nueva-rama -m \"Mensaje de commit\" La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT ( content ) : Merge conflict in hola.txt Automatic merge failed ; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m \"Arreglado el conflicto en el merge\" $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama main ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m \"Cambios en experiment\" $ git checkout main # hacemos cambios $ git commit -a -m \"Cambios en main\" $ git checkout experiment $ git rebase main First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama main ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama main y tener una historia lineal: 1 2 3 4 $ git checkout main $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase main CONFLICT ( content ) : Merge conflict in <some-file> # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use \"git reset HEAD <some-file>...\" to unstage) # (use \"git add/rm <some-file>...\" as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add <some-file> $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama ( was c241d7b ) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin <rama> Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b <rama> origin/<rama> Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete <branchName>","title":"Ramas"},{"location":"01-intro-spring-boot/comandos-git.html#modificar-la-historia","text":"Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [ --m \"Nuevo mensaje\" ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout <hash> ( o tag, por ejemplo v2.0 ) You are in 'detached HEAD' state. # Ahora est\u00e1s en un detached HEAD $ git branch * ( HEAD detached at 594b606 ) main $ git checkout -b v2.0.1 Switched to a new branch 'v2.0.1' $ git branch main * v2.0.1 $ git checkout main Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard <hash>","title":"Modificar la historia"},{"location":"01-intro-spring-boot/comandos-git.html#mas-informacion","text":"Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"M\u00e1s informaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html","text":"Introducci\u00f3n a Spring Boot \u00b6 Descarga de la aplicaci\u00f3n ejemplo \u00b6 Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr . En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp . Puedes descargarla usando Git: 1 $ git clone https://github.com/domingogallardo/spring-boot-demoapp.git La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona. Ejecuci\u00f3n de aplicaciones Spring Boot \u00b6 Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper , como es el caso de la aplicaci\u00f3n ejemplo. Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a mvn si tenemos instalado Maven o a ./mvnw para usar Maven Wrapper: 1 2 $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: 1 $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito Desarrollo y ejecuci\u00f3n con IntelliJ \u00b6 Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para importar un proyecto Spring Boot en IntelliJ basta con importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File > New > Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ importa el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc: Conceptos de Spring Boot \u00b6 Estructura de la aplicaci\u00f3n \u00b6 Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.ua.mads </groupId> <artifactId> demoapp </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> demoapp </name> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.1.16.RELEASE </version> </parent> <properties> <java.version> 1.8 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-thymeleaf </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties 1 spring.application.name = demoapp Controladores \u00b6 Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { private final SaludoService service ; @Autowired public SaludoController ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: 1 2 3 4 5 6 HTTP / 1 . 1 200 Content-Type : text / plain ; charset = UTF-8 Content-Length : 8 Date : Mon , 02 Sep 2019 14 : 59 : 04 GMT Hola Ana Clases de Servicio \u00b6 Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java 1 2 3 4 5 6 7 8 9 10 package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return \"Hola \" + nombre ; } } Inyecci\u00f3n de dependencias en Spring \u00b6 Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. En este caso lo hacemos anotando el constructor. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable service que se pasa como par\u00e1metro al constructor. Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection . Alcance de los objetos inyectados Por defecto el alcance ( scope ) de todas las anotaciones de Spring ( @service , @controller , @component , etc.) es un Singleton . Existe una \u00fanica instancia de ese objeto que es la que se inyecta en las variables. Al estar funcionando en una aplicaci\u00f3n web, el singleton que hace de controlador recibir\u00e1 m\u00faltiples peticiones concurrentemente. Cada petici\u00f3n ir\u00e1 en su propio hilo de Java, por lo que m\u00faltiples hilos podr\u00e1n estar ejecutando el mismo c\u00f3digo del controlador. Por ello hay que tener cuidado en no definir variables de instancia mutables (con estado) dentro del controlador, porque podr\u00edan producirse errores debidos a condiciones de carrera (un hilo modifica la misma variable que otro est\u00e1 leyendo). Es conveniente que todos los beans (controladores, servicios, etc.) sean objetos sin estado. Tambi\u00e9n es posible definir otros alcances, como @RequestScope o @SessionScope . En el primer caso se crea una instancia nueva del objeto para cada petici\u00f3n HTTP y en el segundo se crea una instancia nueva en cada sesi\u00f3n HTTP. Puedes encontrar m\u00e1s informaci\u00f3n y ejemplos en este enlace . Plantillas Thymeleaf \u00b6 Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html 1 2 3 4 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < h1 th:text = \"'Saludo: ' + ${mensaje}\" > </ h1 > </ html > El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { private final SaludoService service ; @Autowired public SaludoControllerPlantilla ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludoplantilla/{nombre}\" ) public String saludo ( @PathVariable ( value = \"nombre\" ) String nombre , Model model ) { // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa // en la plantilla model . addAttribute ( \"mensaje\" , service . saluda ( nombre )); // Se llama a la plantilla 'saludo.html' return \"saludo\" ; } } Tests \u00b6 En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: 1 $ mvn test O tambi\u00e9n, usando el comando de Maven Wrapper: 1 $ .mvnw test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ. Tests sobre clases de servicio Podemos realizar pruebas sobre la capa de servicio, obteniendo una instancia del servicio mediante inyecci\u00f3n de dependencias. En el siguiente ejemplo se muestra c\u00f3mo se prueba el m\u00e9todo de servicio saluda . Fichero src/test/java/demoapp/ServiceTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package demoapp ; import demoapp.service.SaludoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class ServiceTest { @Autowired SaludoService saludo ; @Test public void contexLoads () throws Exception { assertThat ( saludo ). isNotNull (); } @Test public void serviceSaludo () throws Exception { assertThat ( saludo . saluda ( \"Domingo\" )). isEqualTo ( \"Hola Domingo\" ); } } Tests sobre capa web Es posible realizar tests sobre la capa de presentaci\u00f3n sin lanzar realmente el servidor web ni ejecutar realmente las peticiones HTTP. Se obtiene por inyecci\u00f3n de dependencias un mock de la clase MockMvc y se usan m\u00e9todos como perform(get(\"/\")) . En el ejemplo siguiente se comprueba que una petici\u00f3n GET a la URL / devuelve un c\u00f3digo HTTP OK (200) y una p\u00e1gina HTML con la cadena esperada. En este test lo \u00fanico que se moquea es el servidor web, y se ejecuta el c\u00f3digo real del servicio, del controlador y de la plantilla. Se utilizan los m\u00e9todos andDo y andExpect de la propia librer\u00eda de testeo de Spring Framework y el m\u00e9todo conteainsString de la librer\u00eda de testeo Hamcrest . Fichero src/test/demoapp/AutoConfigureWebMockTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package demoapp ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @RunWith ( SpringRunner . class ) @SpringBootTest @AutoConfigureMockMvc public class AutoConfigureWebMockTest { @Autowired private MockMvc mockMvc ; @Test public void shouldReturnDefaultMessage () throws Exception { this . mockMvc . perform ( get ( \"/\" )) . andDo ( print ()) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hello World\" ))); } } Tambi\u00e9n es posible realizar un test \u00fanicamente del controlador y la plantilla de presentaci\u00f3n, moqueando el servicio. Se muestra en el siguiente ejemplo. Fichero src/test/java/WebMockTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package demoapp ; import demoapp.controller.SaludoController ; import demoapp.service.SaludoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest ; import org.springframework.boot.test.mock.mockito.MockBean ; import org.springframework.test.context.junit4.SpringRunner ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.mockito.Mockito.when ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @RunWith ( SpringRunner . class ) @WebMvcTest ( SaludoController . class ) public class WebMockTest { @Autowired private MockMvc mockMvc ; @MockBean private SaludoService service ; @Test public void greetingShouldReturnMessageFromService () throws Exception { when ( service . saluda ( \"Domingo\" )). thenReturn ( \"Hola Mock Domingo\" ); this . mockMvc . perform ( get ( \"/saludo/Domingo\" )) . andDo ( print ()) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hola Mock Domingo\" ))); } } Tests sobre la aplicaci\u00f3n en funcionamiento Por \u00faltimo, tambi\u00e9n podemos realizar tests sobre la aplicaci\u00f3n funcionando completamente, realizando una petici\u00f3n al servidor web y comprobando que se devuelve lo esperado. Estos tests son los m\u00e1s costosos porque conllevan levantar el servidor web y realizar completamente el procesamiento de la petici\u00f3n. Fichero src/test/java/demoapp/HttpRequestTest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package demoapp ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.web.server.LocalServerPort ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest ( webEnvironment = WebEnvironment . RANDOM_PORT ) public class HttpRequestTest { @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; @Test public void greetingShouldReturnDefaultMessage () throws Exception { assertThat ( this . restTemplate . getForObject ( \"http://localhost:\" + port + \"/\" , String . class )). contains ( \"Hello World\" ); } } Referencias \u00b6 Getting Started Guide Building an Application with Spring Boot Getting Started Guide Serving Web Content with Spring MVC Spring Boot Reference Guide 2.1.16.RELEASE ( HTML , PDF )","title":"Introducci\u00f3n a Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#introduccion-a-spring-boot","text":"","title":"Introducci\u00f3n a Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#descarga-de-la-aplicacion-ejemplo","text":"Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr . En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp . Puedes descargarla usando Git: 1 $ git clone https://github.com/domingogallardo/spring-boot-demoapp.git La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona.","title":"Descarga de la aplicaci\u00f3n ejemplo"},{"location":"01-intro-spring-boot/intro-spring-boot.html#ejecucion-de-aplicaciones-spring-boot","text":"Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper , como es el caso de la aplicaci\u00f3n ejemplo. Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a mvn si tenemos instalado Maven o a ./mvnw para usar Maven Wrapper: 1 2 $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: 1 $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito","title":"Ejecuci\u00f3n de aplicaciones Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#desarrollo-y-ejecucion-con-intellij","text":"Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para importar un proyecto Spring Boot en IntelliJ basta con importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File > New > Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ importa el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:","title":"Desarrollo y ejecuci\u00f3n con IntelliJ"},{"location":"01-intro-spring-boot/intro-spring-boot.html#conceptos-de-spring-boot","text":"","title":"Conceptos de Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#estructura-de-la-aplicacion","text":"Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.ua.mads </groupId> <artifactId> demoapp </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> demoapp </name> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.1.16.RELEASE </version> </parent> <properties> <java.version> 1.8 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-thymeleaf </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties 1 spring.application.name = demoapp","title":"Estructura de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html#controladores","text":"Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { private final SaludoService service ; @Autowired public SaludoController ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: 1 2 3 4 5 6 HTTP / 1 . 1 200 Content-Type : text / plain ; charset = UTF-8 Content-Length : 8 Date : Mon , 02 Sep 2019 14 : 59 : 04 GMT Hola Ana","title":"Controladores"},{"location":"01-intro-spring-boot/intro-spring-boot.html#clases-de-servicio","text":"Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java 1 2 3 4 5 6 7 8 9 10 package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return \"Hola \" + nombre ; } }","title":"Clases de Servicio"},{"location":"01-intro-spring-boot/intro-spring-boot.html#inyeccion-de-dependencias-en-spring","text":"Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. En este caso lo hacemos anotando el constructor. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable service que se pasa como par\u00e1metro al constructor. Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection .","title":"Inyecci\u00f3n de dependencias en Spring"},{"location":"01-intro-spring-boot/intro-spring-boot.html#plantillas-thymeleaf","text":"Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html 1 2 3 4 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < h1 th:text = \"'Saludo: ' + ${mensaje}\" > </ h1 > </ html > El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { private final SaludoService service ; @Autowired public SaludoControllerPlantilla ( SaludoService service ) { this . service = service ; } @RequestMapping ( \"/saludoplantilla/{nombre}\" ) public String saludo ( @PathVariable ( value = \"nombre\" ) String nombre , Model model ) { // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa // en la plantilla model . addAttribute ( \"mensaje\" , service . saluda ( nombre )); // Se llama a la plantilla 'saludo.html' return \"saludo\" ; } }","title":"Plantillas Thymeleaf"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests","text":"En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: 1 $ mvn test O tambi\u00e9n, usando el comando de Maven Wrapper: 1 $ .mvnw test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ.","title":"Tests"},{"location":"01-intro-spring-boot/intro-spring-boot.html#referencias","text":"Getting Started Guide Building an Application with Spring Boot Getting Started Guide Serving Web Content with Spring MVC Spring Boot Reference Guide 2.1.16.RELEASE ( HTML , PDF )","title":"Referencias"},{"location":"01-intro-spring-boot/practica0.html","text":"Primera aplicaci\u00f3n con Spring Boot \u00b6 Esta es la primera parte de la pr\u00e1ctica 1. En esta parte tendremos un primer contacto con Spring Boot. Tambi\u00e9n usaremos Git. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub. Instalaci\u00f3n de software \u00b6 Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior Maven (opcional, se puede usar el comando ./mvnw del proyecto) IntelliJ Ultimate Nota del profesor sobre en el sistema operativo en el que realizar la pr\u00e1ctica Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones, ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica. Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Instalaci\u00f3n b\u00e1sica \u00b6 Linux Para instalar el software en Linux. Instalar Git, Java y Maven: 1 2 3 $ sudo apt install git $ sudo apt install default-jdk $ sudo apt install maven Instalar IntelliJ Ultimate macOS Git y Java vienen instalados con el sistema operativo. Recomendamos usar Homebrew para instalar Maven: 1 $ brew install maven Instalar IntelliJ Ultimate Windows Es recomendable instalar git for Windows , que adem\u00e1s de Git instala Git BASH, un terminal Bash integrado en Windows. Adem\u00e1s, hay que instalar Java, Maven e IntelliJ Ultimate . Despu\u00e9s de la instalaci\u00f3n b\u00e1sica \u00b6 Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: 1 2 $ git --version $ mvn --version ( imprime la versi\u00f3n de Maven y de Java ) Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero $HOME/.bashrc (linux y Git Bash Windows) o $HOME/.bash_profile (macOS) : 1 2 3 4 parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/' } export PS1=\"\\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \" Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed . Repositorio GitHub \u00b6 Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. 1 2 $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings > Profile y actualizando el campo Name . Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring Boot Demo App . Se crear\u00e1 autom\u00e1ticamente el repositorio springboot-demo-app-<usuario> en la organizaci\u00f3n mads-ua-20-21 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp ). Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-20-21 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub: El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n mads-ua-20-21 y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-20-21 . Documentaci\u00f3n a consultar \u00b6 Para realizar la pr\u00e1ctica debes leer los siguientes documentos: Introducci\u00f3n a Spring Boot Validating Form Input En el caso en que necesites m\u00e1s informaci\u00f3n puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . Enunciado de la pr\u00e1ctica \u00b6 Haremos una primera pr\u00e1ctica sencilla en la que pondremos en marcha una aplicaci\u00f3n inicial en Spring Boot y a\u00f1adiremos alguna funcionalidad. Trabajamos con la aplicaci\u00f3n Demo de Spring Boot \u00b6 Debemos hacer lo siguiente: Descargar la aplicaci\u00f3n demo de Spring Boot que hemos creado en GitHub usando el comando git clone. Importarla en IntelliJ Probar que se pasan todos los tests usando Maven e IntelliJ Ejecutarla desde l\u00ednea de comando y desde IntelliJ Hacer alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n. Por ejemplo, cambiar los mensajes de saludo. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n \u00b6 Debemos a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n que realice lo siguiente: Leer datos de un formulario usando Thymeleaf y realizando alguna validaci\u00f3n. Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Incluir al menos 2 tests: 1 de la capa de servicio 1 de la capa de presentaci\u00f3n usando MockMvc y moqueando el servicio Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra: Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma. N\u00famero par: lee un n\u00famero y comprueba si es par Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado. Comandos Git \u00b6 Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en documento comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura. Entrega \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada el martes 22 de septiembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 3% en la nota final de la asignatura. Para realizar la entrega debes hacer lo siguiente: Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits conforme se van realizando. Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho ./mvnw clean para eliminar los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de toda la semana y no dejar todo para el \u00faltimo d\u00eda). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Primera aplicaci\u00f3n con Spring Boot"},{"location":"01-intro-spring-boot/practica0.html#primera-aplicacion-con-spring-boot","text":"Esta es la primera parte de la pr\u00e1ctica 1. En esta parte tendremos un primer contacto con Spring Boot. Tambi\u00e9n usaremos Git. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub.","title":"Primera aplicaci\u00f3n con Spring Boot"},{"location":"01-intro-spring-boot/practica0.html#instalacion-de-software","text":"Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior Maven (opcional, se puede usar el comando ./mvnw del proyecto) IntelliJ Ultimate Nota del profesor sobre en el sistema operativo en el que realizar la pr\u00e1ctica Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones, ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica. Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.","title":"Instalaci\u00f3n de software"},{"location":"01-intro-spring-boot/practica0.html#instalacion-basica","text":"","title":"Instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica0.html#despues-de-la-instalacion-basica","text":"Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: 1 2 $ git --version $ mvn --version ( imprime la versi\u00f3n de Maven y de Java ) Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero $HOME/.bashrc (linux y Git Bash Windows) o $HOME/.bash_profile (macOS) : 1 2 3 4 parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/' } export PS1=\"\\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \" Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed .","title":"Despu\u00e9s de la instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica0.html#repositorio-github","text":"Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. 1 2 $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings > Profile y actualizando el campo Name . Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring Boot Demo App . Se crear\u00e1 autom\u00e1ticamente el repositorio springboot-demo-app-<usuario> en la organizaci\u00f3n mads-ua-20-21 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp ). Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-20-21 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub: El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n mads-ua-20-21 y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-20-21 .","title":"Repositorio GitHub"},{"location":"01-intro-spring-boot/practica0.html#documentacion-a-consultar","text":"Para realizar la pr\u00e1ctica debes leer los siguientes documentos: Introducci\u00f3n a Spring Boot Validating Form Input En el caso en que necesites m\u00e1s informaci\u00f3n puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides .","title":"Documentaci\u00f3n a consultar"},{"location":"01-intro-spring-boot/practica0.html#enunciado-de-la-practica","text":"Haremos una primera pr\u00e1ctica sencilla en la que pondremos en marcha una aplicaci\u00f3n inicial en Spring Boot y a\u00f1adiremos alguna funcionalidad.","title":"Enunciado de la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica0.html#trabajamos-con-la-aplicacion-demo-de-spring-boot","text":"Debemos hacer lo siguiente: Descargar la aplicaci\u00f3n demo de Spring Boot que hemos creado en GitHub usando el comando git clone. Importarla en IntelliJ Probar que se pasan todos los tests usando Maven e IntelliJ Ejecutarla desde l\u00ednea de comando y desde IntelliJ Hacer alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n. Por ejemplo, cambiar los mensajes de saludo.","title":"Trabajamos con la aplicaci\u00f3n Demo de Spring Boot"},{"location":"01-intro-spring-boot/practica0.html#anadimos-alguna-funcionalidad-sencilla-a-la-aplicacion","text":"Debemos a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n que realice lo siguiente: Leer datos de un formulario usando Thymeleaf y realizando alguna validaci\u00f3n. Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Incluir al menos 2 tests: 1 de la capa de servicio 1 de la capa de presentaci\u00f3n usando MockMvc y moqueando el servicio Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra: Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma. N\u00famero par: lee un n\u00famero y comprueba si es par Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado.","title":"A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica0.html#comandos-git","text":"Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en documento comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura.","title":"Comandos Git"},{"location":"01-intro-spring-boot/practica0.html#entrega","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada el martes 22 de septiembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 3% en la nota final de la asignatura. Para realizar la entrega debes hacer lo siguiente: Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits conforme se van realizando. Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho ./mvnw clean para eliminar los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de toda la semana y no dejar todo para el \u00faltimo d\u00eda). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Entrega"},{"location":"01-intro-spring-boot/practica1.html","text":"Aplicaci\u00f3n ToDoList \u00b6 Esta es la segunda parte de la pr\u00e1ctica 1. Objetivos \u00b6 En esta segunda parte de la pr\u00e1ctica vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . Esta parte tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Igual que en la primera parte, debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework. Aplicaci\u00f3n inicial \u00b6 La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los usuarios de la aplicaci\u00f3n. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List . Metodolog\u00eda de desarrollo \u00b6 En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues, labels, milestones, etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java. Git \u00b6 Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto. Flujo de trabajo \u00b6 Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request. Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama main haciendo un pull request . Cuando se mezcle el PR en main el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub). Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Importante Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Note Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack o Confluence . Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias. La aplicaci\u00f3n ToDoList \u00b6 La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la parte anterior de la pr\u00e1ctica. Entre otros, tiene los siguientes elementos: Gestiona distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo y prueba. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos. Configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : 1 2 3 4 5 6 7 spring . application . name = madstodolist spring . datasource . url = jdbc : h2 : mem : dev spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = update logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - dev . sql spring . datasource . initialization - mode = always Se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2) y el fichero que contiene los datos iniciales que se van a cargar en la base de datos al arrancar la aplicaci\u00f3n, el fichero datos-dev.sql . Tambi\u00e9n se define la caracter\u00edstica de JPA spring.jpa.hibernate.ddl-auto que define c\u00f3mo se debe inicializar el esquema de datos de la aplicaci\u00f3n cuando haya un cambio en el c\u00f3digo fuente que define las entidades. En este caso tenemos un valor de update para indicar que se el esquema de datos debe actualizarse. En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n. Otras configuraciones Es posible definir otras configuraciones e indicar en el comando de ejecuci\u00f3n de la aplicaci\u00f3n Spring Boot qu\u00e9 fichero de configuraci\u00f3n usar. Lo veremos en la pr\u00e1ctica 2. En esta pr\u00e1ctica se define otra configuraci\u00f3n en el directorio de test, que es la que se carga cuando se lanzan los tests: Fichero src/test/resources/application.properties : 1 2 3 4 5 6 spring . datasource . url = jdbc : h2 : mem : test spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = create logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - test . sql spring . datasource . initialization - mode = always La diferencia con el fichero de configuraci\u00f3n de desarrollo es el nombre de la fuente de datos, el modo del spring.jpa.hibernate.ddl-auto , que es create y el fichero de datos iniciales que se carga al ejecutar los tests. Gesti\u00f3n de persistencia con JPA \u00b6 Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate 5.3.17. Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades. Definici\u00f3n del modelo de datos El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario que se lista a continuaci\u00f3n define la tabla usuarios en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia @GeneratedValue(strategy = GenerationType.IDENTITY) que define una columna que se autoincrementa en cada operaci\u00f3n de inserci\u00f3n de un nuevo registro en la tabla. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario (en nuestro caso el correo electronico), los getters y setters de todas las propiedades (necesario para JPA) y los m\u00e9todos equals y hashCode para comparar usuarios. Los m\u00e9todos equals y hashCode son necesarios para buscar instancias de la entidad en colecciones y JPA los usa para no incluir instancias repetidas en los resultados de las queries. El m\u00e9todo equals proporcionado no es el que genera IntelliJ por defecto, sino que hay que considerar si la instancia ha sido ya vinculada a la base de datos o no. En el caso en que la instancia ya est\u00e9 vinculada a la base de datos, tendr\u00e1 una clave primaria asignada y \u00e9sta ser\u00e1 la que se usar\u00e1 para comparar. En el caso en que la instancia no est\u00e9 vinculada (se acaba de crear o la estamos usando para alguna parte de la l\u00f3gica de negocio y no se va a persistir) se comparan los atributos obligatorios (en este caso el correo electr\u00f3nico). Fichero src/main/java/madstodolist/model/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.Date ; import java.util.List ; import java.util.Objects ; @Entity @Table ( name = \"usuarios\" ) public class Usuario implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String email ; private String nombre ; private String password ; @Column ( name = \"fecha_nacimiento\" ) @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = \"usuario\" , fetch = FetchType . EAGER ) List < Tarea > tareas = new ArrayList < Tarea > (); // Constructor vac\u00edo necesario para JPA/Hibernate. // Lo hacemos privado para que no se pueda usar desde el c\u00f3digo de la aplicaci\u00f3n. Para crear un // usuario en la aplicaci\u00f3n habr\u00e1 que llamar al constructor p\u00fablico. Hibernate s\u00ed que lo puede usar, a pesar // de ser privado. private Usuario () {} // Constructor p\u00fablico con los atributos obligatorios. En este caso el correo electr\u00f3nico. public Usuario ( String email ) { this . email = email ; } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getNombre () { return nombre ; } public void setNombre ( String nombre ) { this . nombre = nombre ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public Date getFechaNacimiento () { return fechaNacimiento ; } public void setFechaNacimiento ( Date fechaNacimiento ) { this . fechaNacimiento = fechaNacimiento ; } public List < Tarea > getTareas () { return tareas ; } public void setTareas ( List < Tarea > tareas ) { this . tareas = tareas ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Usuario usuario = ( Usuario ) o ; if ( id != null && usuario . id != null ) // Si tenemos los ID, comparamos por ID return Objects . equals ( id , usuario . id ); // sino comparamos por campos obligatorios return email . equals ( usuario . email ); } @Override public int hashCode () { // Generamos un hash basado en los campos obligatorios return Objects . hash ( email ); } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La definici\u00f3n de Tarea es la siguiente: Fichero src/main/java/madstodolist/model/Tarea.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.Objects ; @Entity @Table ( name = \"tareas\" ) public class Tarea implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String titulo ; @NotNull // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = \"usuario_id\" ) private Usuario usuario ; // Constructor vac\u00edo necesario para JPA/Hibernate. // Lo hacemos privado para que no se pueda usar desde el c\u00f3digo de la aplicaci\u00f3n. Para crear un // usuario en la aplicaci\u00f3n habr\u00e1 que llamar al constructor p\u00fablico. Hibernate s\u00ed que lo puede usar, a pesar // de ser privado. private Tarea () {} // Al crear una tarea la asociamos autom\u00e1ticamente a un // usuario. Actualizamos por tanto la lista de tareas del // usuario. public Tarea ( Usuario usuario , String titulo ) { this . usuario = usuario ; this . titulo = titulo ; usuario . getTareas (). add ( this ); } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getTitulo () { return titulo ; } public void setTitulo ( String titulo ) { this . titulo = titulo ; } public Usuario getUsuario () { return usuario ; } public void setUsuario ( Usuario usuario ) { this . usuario = usuario ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Tarea tarea = ( Tarea ) o ; return titulo . equals ( tarea . titulo ) && usuario . equals ( tarea . usuario ); } @Override public int hashCode () { return Objects . hash ( titulo , usuario ); } } Recuperaci\u00f3n eager y lazy de las colecciones Como hemos visto anteriormente, en la aplicaci\u00f3n se define la relaci\u00f3n uno-a-muchos entre usuarios y tareas: un usuario tiene muchas tareas. Por defecto, todas las relaciones a-muchos en JPA se definen de tipo LAZY . La caracter\u00edstica de los atributos marcados como lazy en JPA es que no se traen a memoria cuando se recupera la entidad, sino cuando se consultan expl\u00edcitamente accediendo al atributo. Para que se traigan a memoria la conexi\u00f3n con la base de datos debe estar abierta . Si ya se ha cerrado esa conexi\u00f3n (por ejemplo, se ha cerrado la transacci\u00f3n en el m\u00e9todo de servicio y se quiere acceder a la una lista de tareas de un usuario devuelto por el propio m\u00e9todo estando en el controller) se producir\u00e1 un error. Frente a la recuperaci\u00f3n lazy de colecciones, tambi\u00e9n existe la posibilidad de definir una colecci\u00f3n como de tipo EAGER . En este caso JPA se traer\u00e1 siempre a memoria todos los elementos. Es el caso de la relaci\u00f3n entre un usuario y sus tareas. En general, no es conveniente definir una relaci\u00f3n como eager porque puede provocar problemas de rendimiento en el caso en que haya muchos elementos relacionados. Pero si no hay muchos datos en la relaci\u00f3n y los vamos a usar con frecuencia, s\u00ed que es aconsejable usar el tipo EAGER para facilitar el manejo de la entidad. El c\u00f3digo queda como hemos visto anteriormente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Entity public class Usuario { ... // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = \"usuario\" , fetch = FetchType . EAGER ) List < Tarea > tareas = new ArrayList < Tarea > (); ... } @Entity public class Tarea { ... // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = \"usuario_id\" ) private Usuario usuario ; ... } Clases Repository Spring define la clase gen\u00e9rica CrudRepository que contienen m\u00e9todos por defecto para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. 1 2 3 4 5 6 7 8 9 public interface CrudRepository < T , ID extends Serializable > extends Repository < T , ID > { < S extends T > S save ( S entity ); Optional < T > findById ( ID primaryKey ); Iterable < T > findAll (); long count (); void delete ( T entity ); boolean existsById ( ID primaryKey ); // \u2026 more functionality omitted. } Para usar estos m\u00e9todos con nuestras entidades basta con definir interfaces que extienden esta clase gen\u00e9rica. Por ejemplo, la interfaz TareaRepository : Fichero src/main/java/madstodolist/model/TareaRepository.java : 1 2 3 4 5 package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; public interface TareaRepository extends CrudRepository < Tarea , Long > {} Una vez definida la interfaz, ya podemos inyectar una instancia de repository y usarla en las clases de servicio. Por ejemplo, mostramos el m\u00e9todo de servicio que modifica el t\u00edtulo de una tarea: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Service public class TareaService { private UsuarioRepository usuarioRepository ; private TareaRepository tareaRepository ; @Autowired public TareaService ( UsuarioRepository usuarioRepository , TareaRepository tareaRepository ) { this . usuarioRepository = usuarioRepository ; this . tareaRepository = tareaRepository ; } ... @Transactional public Tarea modificaTarea ( Long idTarea , String nuevoTitulo ) { Tarea tarea = tareaRepository . findById ( idTarea ). orElse ( null ); if ( tarea == null ) { throw new TareaServiceException ( \"No existe tarea con id \" + idTarea ); } tarea . setTitulo ( nuevoTitulo ); tareaRepository . save ( tarea ); return tarea ; } ... } La anotaci\u00f3n @Transactional hace que las acciones sobre la base de datos se ejecuten de forma transaccional. Se abre la transacci\u00f3n al del m\u00e9todo y se cierra al final. Si sucede alguna excepci\u00f3n durante su ejecuci\u00f3n la transacci\u00f3n se deshace. En el cuerpo del m\u00e9todo se llama al m\u00e9todo findById del repositorio que realiza una b\u00fasqueda en la base de datos y al m\u00e9todo save que actualiza el valor de la entidad. La interfaz UsuarioRepository es similar. Fichero src/main/java/madstodolist/model/UsuarioRepository.java : 1 2 3 4 5 6 7 8 9 package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; import java.util.Optional ; public interface UsuarioRepository extends CrudRepository < Usuario , Long > { Optional < Usuario > findByEmail ( String s ); } La diferencia es que se a\u00f1ade un m\u00e9todo findByEmail que hace que Spring construya autom\u00e1ticamente una consulta sobre la base de datos. Al usar como nombre del m\u00e9todo el nombre de la propiedad de la entidad ( email ), Spring puede generar autom\u00e1ticamente la consulta. Servicios \u00b6 La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Fichero src/main/java/madstodolist/service/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } private UsuarioRepository usuarioRepository ; @Autowired public UsuarioService ( UsuarioRepository usuarioRepository ) { this . usuarioRepository = usuarioRepository ; } @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional < Usuario > usuario = usuarioRepository . findByEmail ( eMail ); if ( ! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if ( ! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional < Usuario > usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( \"El usuario \" + usuario . getEmail () + \" ya est\u00e1 registrado\" ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( \"El usuario no tiene email\" ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( \"El usuario no tiene password\" ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Controllers \u00b6 Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 package madstodolist.controller ; import madstodolist.authentication.ManagerUserSesion ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import org.springframework.web.servlet.mvc.support.RedirectAttributes ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSesion managerUserSesion ; @GetMapping ( \"/login\" ) public String loginForm ( Model model ) { model . addAttribute ( \"loginData\" , new LoginData ()); return \"formLogin\" ; } @PostMapping ( \"/login\" ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , RedirectAttributes flash , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSesion . logearUsuario ( session , usuario . getId ()); return \"redirect:/usuarios/\" + usuario . getId () + \"/tareas\" ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( \"error\" , \"No existe usuario\" ); return \"formLogin\" ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( \"error\" , \"Contrase\u00f1a incorrecta\" ); return \"formLogin\" ; } return \"formLogin\" ; } @GetMapping ( \"/registro\" ) public String registroForm ( Model model ) { model . addAttribute ( \"registroData\" , new RegistroData ()); return \"formRegistro\" ; } @PostMapping ( \"/registro\" ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return \"registroForm\" ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( \"registroData\" , registroData ); model . addAttribute ( \"error\" , \"El usuario \" + registroData . geteMail () + \" ya existe\" ); return \"formRegistro\" ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return \"redirect:/login\" ; } @GetMapping ( \"/logout\" ) public String logout ( HttpSession session ) { session . setAttribute ( \"idUsuarioLogeado\" , null ); return \"redirect:/login\" ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Peticiones y rutas Las rutas que se definen en los controllers para realizar las acciones de la aplicaci\u00f3n son: LoginController GET /login : devuelve el formulario de login POST /login : realiza el login GET /registro : devuelve el formulario de registro POST /registro : realiza el registro GET /logout : realiza la salida del usuario de la aplicaci\u00f3n TareaController GET /usuarios/{id}/tareas/nueva : devuelve el formulario para a\u00f1adir una tarea al usuario con identificador {id} POST /usuarios/{id}/tareas/nueva : a\u00f1ade una tarea nueva a un usuario GET /usuarios/{id}/tareas : devuelve el listado de tareas de un usuario GET /tareas/{id}/editar\" : devuelve el formulario para editar una tarea POST /tareas/{id}/editar : a\u00f1ade una tarea modificada DELETE /tareas/{id} : realiza el borrado de una tarea Vistas \u00b6 Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:fragment = \"head (titulo)\" > < meta charset = \"UTF-8\" /> < title th:text = \"${titulo}\" ></ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" > </ head > < div th:fragment = \"javascript\" > < script th:src = \"@{/js/jquery.min.js}\" ></ script > < script th:src = \"@{/js/popper.min.js.css}\" ></ script > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > < span th:text = \"${scripts}\" ></ span > </ div > /html> Vemos que las vistas usan el framework CSS Bootstrap y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n. Fichero src/main/resources/templates/listaTareas.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"row mt-3\" > < div class = \"col\" > < h2 th:text = \"'Listado de tareas de ' + ${usuario.nombre}\" ></ h2 > </ div > </ div > < div class = \"row mt-3\" > < div class = \"col\" > < table class = \"table table-striped\" > < thead > < tr > < th > Id </ th > < th > Tarea </ th > < th > Acci\u00f3n </ th > </ tr > </ thead > < tbody > < tr th:each = \"tarea: ${tareas}\" > < td th:text = \"${tarea.id}\" ></ td > < td th:text = \"${tarea.titulo}\" ></ td > < td >< a class = \"btn btn-primary btn-xs\" th:href = \"@{/tareas/{id}/editar(id=${tarea.id})}\" /> editar </ a > < a class = \"btn btn-danger btn-xs\" href = \"#\" onmouseover = \"\" style = \"cursor: pointer;\" th:onclick = \"'del(\\'/tareas/' + ${tarea.id} + '\\')'\" > borrar </ a > </ td > </ tr > </ tbody > </ table > < p >< a class = \"btn btn-primary\" th:href = \"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\" > Nueva tarea </ a > < a class = \"btn btn-link\" href = \"/logout\" > Salir </ a ></ p > </ div > </ div > < div class = \"row mt-2\" > < div class = \"col\" > < div class = \"alert alert-success alert-dismissible fade show\" role = \"alert\" th:if = \"${!#strings.isEmpty(mensaje)}\" > < span th:text = \"${mensaje}\" ></ span > < button type = \"button\" class = \"close\" data-dismiss = \"alert\" aria-label = \"Close\" > < span aria-hidden = \"true\" > &times; </ span > </ button > </ div > </ div > </ div > </ div > </ div > < div th:replace = \"fragments::javascript\" /> <!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --> < script type = \"text/javascript\" > function del ( urlBorrar ) { if ( confirm ( '\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?' )) { $ . ajax ({ url : urlBorrar , type : 'DELETE' , success : function ( results ) { //refresh the page location . reload (); } }); } } </ script > </ body > </ html > La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea. Autenticaci\u00f3n y control de acceso En la aplicaci\u00f3n se realiza una autenticaci\u00f3n y un control de acceso muy sencillo usando la sesi\u00f3n HTTP. Esta sesi\u00f3n se implementa en Spring Boot con una cookie que se pasa desde el navegador hasta el servidor en cada petici\u00f3n. El manejo de la sesi\u00f3n es muy sencillo: es un diccionario en el que podemos a\u00f1adir datos. En el servidor podemos obtener los datos de la sesi\u00f3n consultando el diccionario. La implementaci\u00f3n de la autenticaci\u00f3n y del control de acceso se realiza con en la clase ManagerUserSesion : Fichero src/main/java/madstodolist/authentication/ManagerUserSesion.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package madstodolist.authentication ; import org.springframework.stereotype.Component ; import javax.servlet.http.HttpSession ; @Component public class ManagerUserSesion { // A\u00f1adimos el id de usuario en la sesi\u00f3n HTTP para hacer // una autorizaci\u00f3n sencilla. En los m\u00e9todos de controllers // comprobamos si el id del usuario logeado coincide con el obtenido // desde la URL public void logearUsuario ( HttpSession session , Long idUsuario ) { session . setAttribute ( \"idUsuarioLogeado\" , idUsuario ); } // Si el usuario no est\u00e1 logeado se lanza una excepci\u00f3n public void comprobarUsuarioLogeado ( HttpSession session , Long idUsuario ) { Long idUsuarioLogeado = ( Long ) session . getAttribute ( \"idUsuarioLogeado\" ); if ( ! idUsuario . equals ( idUsuarioLogeado )) throw new UsuarioNoLogeadoException (); } } Se implementa como un componente Spring con la anotaci\u00f3n @Component , lo inyectamos en los controllers y lo mockeamos en los tests de los controllers. Pruebas manuales y autom\u00e1ticas \u00b6 Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/datos-dev.sql : 1 2 3 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'domingo@ua' , 'Domingo Gallardo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Para los tests autom\u00e1ticos se cargan los datos definidos en el fichero datos-tests.sql . Fichero src/test/resources/datos-test.sql : 1 2 3 4 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'ana.garcia@gmail.com' , 'Ana Garc\u00eda' , '12345678' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : Tambi\u00e9n sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Y sobre las vistas: UsuarioWebTest.java TareaWebTest.java En los tests sobre repository se debe usar la anotaci\u00f3n @Transactional para definir el contexto transaccional en el que se realiza la llamada a las acciones sobre la base de datos. En los tests sobre las vistas se mockean los servicios para que devuelvan los datos que nos interesan. Hay que ser cuidadoso al hacer pruebas que afectan a la base de datos, porque podemos insertar o modificar datos que se comprueban en otros tests. Tenemos que tener cuidado en que cada test sea independiente de los dem\u00e1s. Antes de empezar la pr\u00e1ctica \u00b6 Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-<usuario> en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la primera parte de la pr\u00e1ctica es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-20-21 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas. Descarga el proyecto y comprueba que se compila y ejecuta correctamente: 1 2 3 $ git clone https://github.com/mads-ua/todolist-<usuario>.git $ cd todolist-<usuario> $ ./mvnw spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: 1 2 spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: Crea un tablero Trello p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial . Desarrollo de la pr\u00e1ctica \u00b6 En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features: P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0. Versi\u00f3n 1.0.1 \u00b6 La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de . Tablero Trello Utilizaremos el tablero Trello para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una tarjeta para cada caracter\u00edstica. Cada caracter\u00edstica deber\u00e1 tener un n\u00famero y un t\u00edtulo. A\u00f1ade la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de : Cuando empecemos a trabajar en la historia de usuario moveremos la tarjeta a En marcha y cuando la hayamos terminado de testear e integrar en la rama principal la moveremos a Terminadas . Tablero de GitHub Configura el tablero de GitHub, poniendo como nombre ToDoList y seleccionando como plantilla Automated kanban . Elimina las tarjetas en la columna To do y a\u00f1ade la columna In pull request entre In progress y Done . En las columnas deber\u00e1n aparecer los issues del proyecto (y los PRs estar\u00e1n enlazados en ellos). GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. A continuaci\u00f3n mostramos la configuraci\u00f3n que usaremos: Deberemos mover manualmente las tarjetas en alg\u00fan caso, porque GitHub no podr\u00e1 detectar las condiciones. En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : moveremos a esta columna el issue abramos un PR y lo enlacemos con el issue. Manual. GitHub lo coloca autom\u00e1ticamente en esta columna. implementado por el pull request manualmente. Columna Done : pull requests cerrados. GitHub lo detecta autom\u00e1ticamente. Issues A\u00f1ade las etiquetas que vamos a usar inicialmente. Crea el primer issue, correspondiente a la feature a desarrollar P\u00e1gina Acerca de . Crea el milestone 1.0.1. y a\u00f1ade el issue a \u00e9l. A\u00f1ade el issue al proyecto (desde la p\u00e1gina del issue) y autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To do . Desarrollo Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama main . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y abriendo un terminal para trabajar con Git: En el terminal escribimos los comandos para crear la rama en la que desarrollaremos la feature y subirla: 1 2 (main) $ git checkout -b acerca-de (acerca-de) $ git push -u origin acerca-de Primer commit Hacemos un primer commit. Cambia en pom.xml el nombre del proyecto ( artifactId ) a mads-todolist-<tu-nombre> y la versi\u00f3n a 1.0.1-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.1 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (acerca-de) $ git status (comprobamos los ficheros que han cambiado) On branch acerca-de Your branch is up to date with 'origin/acerca-de'. Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: README.md modified: pom.xml no changes added to commit (use \"git add\" and/or \"git commit -a\") (acerca-de) $ git add . (acerca-de) $ git status (comprobamos que est\u00e1 listo para a\u00f1adirse en el commit) (acerca-de) $ git commit -m \"Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.1\" On branch acerca-de Your branch is up to date with 'origin/acerca-de'. Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: README.md modified: pom.xml (acerca-de) $ git push Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Segundo commit En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Acci\u00f3n en controller Vista A\u00f1ade los siguientes ficheros: Controller HomeController.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package madstodolist.controller ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.GetMapping ; @Controller public class HomeController { @GetMapping ( \"/about\" ) public String about ( Model model ) { return \"about\" ; } } Vista about.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"container-fluid\" > < h1 > ToDo List </ h1 > < ul > < li > Desarrollada por Domingo Gallardo </ li > < li > Versi\u00f3n 1.0.1 (en desarrollo) </ li > < li > Fecha de release: pendiente de release </ li > </ ul > </ div > </ div > < div th:replace = \"fragments::javascript\" /> </ body > </ html > Prueba la p\u00e1gina accediendo a la url http://localhost:9000/about . Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : 1 2 3 4 (acerca-de) $ git add . (acerca-de) $ git status (comprueba que se han a\u00f1adido los ficheros) (acerca-de) $ git commit -m \"A\u00f1adida vista y controller 'about'\" (acerca-de) $ git push Tercer commit En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero formLogin.html : 1 2 3 4 <a class=\"btn btn-link\" href=\"/registro\">Ir a registro</a> + <a class=\"btn btn-link\" href=\"/about\">Acerca de</a> </div> </form> Prueba que funciona correctamente, haz el commit y s\u00fabelo a GitHub: 1 2 3 4 (acerca-de) $ git status (acerca-de) $ git add . (acerca-de) $ git commit -m \"A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login'\" (acerca-de) $ git push Pull request Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( main ). M\u00e1s adelante a\u00f1adiremos al pull request una comprobaci\u00f3n autom\u00e1tica de las pruebas y una revisi\u00f3n de c\u00f3digo por parte de compa\u00f1eros del equipo. Por ahora haremos nosotros ambas tareas. Vamos a verlo paso a paso. Empezamos por mezclar la rama de forma local con main , antes de hacer el pull request en GitHub, para probar que no se ha roto nada (todos los tests deben seguir pasando) y que los tests que hemos a\u00f1adido tambi\u00e9n funcionan correctamente (en este caso no hemos a\u00f1adido ninguno). En el terminal: 1 2 3 4 5 6 7 8 9 (acerca-de) $ git checkout main (main) $ git pull (bajamos cambios que se hayan subido main. En este caso no habr\u00e1 ninguno, pero los habr\u00e1n cuando trabajemos en equipo) (main) $ git checkout acerca-de (main) $ git merge main (actualizamos la rama de desarrollo con los cambios que se hayan incluido en la rama principal. En este caso no habr\u00e1 ninguno, pero los habr\u00e1n cuando trabajemos en equipo) Lanzamos los tests (lo podemos hacer en el terminal o en IntelliJ): 1 2 3 4 5 6 7 8 9 (main) $ ./mvnw test ... [INFO] [INFO] Tests run: 31, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 21.879 s Ya podemos crear el pull request en GitHub. Accede a la rama y comprueba que est\u00e1n todos los cambios pulsando Compare . Aparecer\u00e1 la siguiente p\u00e1gina, con la informaci\u00f3n de los cambios que introducen todos los commits de la rama: Pulsa despu\u00e9s el bot\u00f3n Create pull request para crear el pull request. Escribe como t\u00edtulo del PR: A\u00f1adida p\u00e1gina 'Acerca de' y En el comentario escribe: 1 Closes #1 Ver\u00e1s que al escribir #1 aparecer\u00e1 el nombre del issue. Si escribes s\u00f3lo # ver\u00e1s una lista de los \u00faltimos issues. De esta forma estamos enlazando el PR con el issue. Cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue. Y podremos en todas las pantallas en las que aparece el issue acceder al PR enlazado. UPulsa en el bot\u00f3n para crear el pull request. Debe quedar la siguiente pantalla en la que informa del PR reci\u00e9n creado: En el proyecto mueve la tarjeta con el issue a la columna In Pull Request . Ver\u00e1s que se ha a\u00f1adido en la parte inferior de la tarjeta un desplegable con la informaci\u00f3n sobre el PR enlazado. En este momento los compa\u00f1eros del equipo deber\u00edan revisar el pull request y su c\u00f3digo. En la propia p\u00e1gina del pull request es posible conversar y realizar comentarios que puede aclarar el autor del PR. Y tambi\u00e9n es posible subir nuevos commits con modificaciones o ampliaciones correspondientes a las sugerencias indicadas. Tambi\u00e9n es posible configurar un sistema de integraci\u00f3n continua que de forma autom\u00e1tica compruebe que la integraci\u00f3n con main no introduce errores en los tests. Tanto la discusi\u00f3n en la p\u00e1gina del pull request como los tests autom\u00e1ticos son funcionalidades que utilizaremos en las pr\u00f3ximas pr\u00e1cticas. Podemos ver que GitHub informa de que no hay conflictos con la rama main y que es posible hacer el merge. Pulsa el bot\u00f3n de Merge pull request (con la opci\u00f3n por defecto Create a merge commit ) y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Este merge lo has hecho en GitHub. Debes por \u00faltimo integrarlo en tu repositorio local. En el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 (acerca-de) $ git checkout main (main) $ git pull (bajamos los cambios) (main) $ git branch -d acerca-de (borramos la rama) (main) $ git remote prune origin (borramos referencias a rama remota) (main) $ git log --oneline --graph --all * 9527ae2 (HEAD -> main, origin/main, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login' | * 3fdfb83 A\u00f1adida ruta, vista y controller 'about' | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request. De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. El issue ligado al PR se habr\u00e1 cerrado autom\u00e1ticamente y en el tablero de proyecto debe haber cambiado la tarjeta a la columna Done . Actualizamos tablero Trello Actualizamos el tablero Trello moviendo la historia de usuario a la columna Terminadas . Versi\u00f3n 1.0.1 Por \u00faltimo creamos el release 1.0.1. Haremos un commit directamente sobre la rama main (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release, cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros pom.xml y about.html Fichero pom.xml : 1 2 3 4 <groupId>es.ua.mads</groupId> <artifactId>mads-todolist-dgallardo</artifactId> - <version>1.0.1-SNAPSHOT</version> + <version>1.0.1</version> Fichero about.html : 1 2 3 4 5 6 7 8 9 10 11 <h1>ToDo List</h1> <ul> <h1>ToDo List</h1> <ul> <li>Desarrollada por Domingo Gallardo</li> - <li>Versi\u00f3n 1.0.1 (en desarrollo)</li> - <li>Fecha de release: pendiente de release</li> + <li>Versi\u00f3n 1.0.1</li> + <li>Fecha de release: 17/9/2018</li> </ul> } A\u00f1adimos el commit y lo subimos a GitHub 1 2 3 (main) $ git add . (main) $ git commit -m \"Cambio de versi\u00f3n a 1.0.1\" (main) $ git push Y, por \u00faltimo, creamos la versi\u00f3n 1.0.1 en GitHub pulsando en el enlace Create a new release en la p\u00e1gina principal: Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. El resultado ser\u00e1: Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0) \u00b6 El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. En alguna de las caracter\u00edsticas deber\u00e1s tambi\u00e9n realizar alg\u00fan test de la vista. Barra de men\u00fa La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login y registro. La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar . de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n <nombre usuario> : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login. Listado de usuarios Si se introduce la URL /usuarios aparecer\u00e1 un listado de los usuarios registrados (identificador y correo electr\u00f3nico). Descripci\u00f3n de usuario En la lista de usuarios habr\u00e1 un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un usuario aparecer\u00e1n todos sus datos, menos la contrase\u00f1a. La ruta para obtener la descripci\u00f3n de un usuario ser\u00e1 /usuarios/:id . Usuario administrador (opcional) Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador acceder\u00e1 directamente a la lista de usuarios. Protecci\u00f3n de listado de usuario y descripci\u00f3n de usuario (opcional) Proteger las p\u00e1ginas con el listado de usuarios y la descripci\u00f3n de usuario para que s\u00f3lo las pueda consultar el administrador. Bloqueo de usuarios por usuario administrador (opcional) A\u00f1adir en el listado de usuarios un bot\u00f3n para que el administrador pueda bloquear o habilitar el acceso a cada uno de los usuarios. Si el usuario tiene bloqueado el acceso cuando intente logearse aparecer\u00e1 un mensaje de error indic\u00e1ndoselo. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n /doc/practica1.md en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica . Puedes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente . Por ejemplo, la documentaci\u00f3n podr\u00eda contener: Listado de nuevas clases y m\u00e9todos implementados. Listado de plantillas thyemeleaf a\u00f1adidas. Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades implementadas. Tests de web implementados. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 20 de octubre. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"Aplicaci\u00f3n ToDoList"},{"location":"01-intro-spring-boot/practica1.html#aplicacion-todolist","text":"Esta es la segunda parte de la pr\u00e1ctica 1.","title":"Aplicaci\u00f3n ToDoList"},{"location":"01-intro-spring-boot/practica1.html#objetivos","text":"En esta segunda parte de la pr\u00e1ctica vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . Esta parte tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Igual que en la primera parte, debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework.","title":"Objetivos"},{"location":"01-intro-spring-boot/practica1.html#aplicacion-inicial","text":"La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los usuarios de la aplicaci\u00f3n. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List .","title":"Aplicaci\u00f3n inicial"},{"location":"01-intro-spring-boot/practica1.html#metodologia-de-desarrollo","text":"En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues, labels, milestones, etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java.","title":"Metodolog\u00eda de desarrollo"},{"location":"01-intro-spring-boot/practica1.html#git","text":"Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto.","title":"Git"},{"location":"01-intro-spring-boot/practica1.html#flujo-de-trabajo","text":"Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request. Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama main haciendo un pull request . Cuando se mezcle el PR en main el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub). Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Importante Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Note Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack o Confluence . Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias.","title":"Flujo de trabajo"},{"location":"01-intro-spring-boot/practica1.html#la-aplicacion-todolist","text":"La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la parte anterior de la pr\u00e1ctica. Entre otros, tiene los siguientes elementos: Gestiona distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo y prueba. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos.","title":"La aplicaci\u00f3n ToDoList"},{"location":"01-intro-spring-boot/practica1.html#configuracion-de-la-aplicacion","text":"Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : 1 2 3 4 5 6 7 spring . application . name = madstodolist spring . datasource . url = jdbc : h2 : mem : dev spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = update logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - dev . sql spring . datasource . initialization - mode = always Se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2) y el fichero que contiene los datos iniciales que se van a cargar en la base de datos al arrancar la aplicaci\u00f3n, el fichero datos-dev.sql . Tambi\u00e9n se define la caracter\u00edstica de JPA spring.jpa.hibernate.ddl-auto que define c\u00f3mo se debe inicializar el esquema de datos de la aplicaci\u00f3n cuando haya un cambio en el c\u00f3digo fuente que define las entidades. En este caso tenemos un valor de update para indicar que se el esquema de datos debe actualizarse. En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#gestion-de-persistencia-con-jpa","text":"Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate 5.3.17. Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades.","title":"Gesti\u00f3n de persistencia con JPA"},{"location":"01-intro-spring-boot/practica1.html#servicios","text":"La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Fichero src/main/java/madstodolist/service/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } private UsuarioRepository usuarioRepository ; @Autowired public UsuarioService ( UsuarioRepository usuarioRepository ) { this . usuarioRepository = usuarioRepository ; } @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional < Usuario > usuario = usuarioRepository . findByEmail ( eMail ); if ( ! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if ( ! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional < Usuario > usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( \"El usuario \" + usuario . getEmail () + \" ya est\u00e1 registrado\" ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( \"El usuario no tiene email\" ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( \"El usuario no tiene password\" ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas.","title":"Servicios"},{"location":"01-intro-spring-boot/practica1.html#controllers","text":"Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 package madstodolist.controller ; import madstodolist.authentication.ManagerUserSesion ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import org.springframework.web.servlet.mvc.support.RedirectAttributes ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSesion managerUserSesion ; @GetMapping ( \"/login\" ) public String loginForm ( Model model ) { model . addAttribute ( \"loginData\" , new LoginData ()); return \"formLogin\" ; } @PostMapping ( \"/login\" ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , RedirectAttributes flash , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSesion . logearUsuario ( session , usuario . getId ()); return \"redirect:/usuarios/\" + usuario . getId () + \"/tareas\" ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( \"error\" , \"No existe usuario\" ); return \"formLogin\" ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( \"error\" , \"Contrase\u00f1a incorrecta\" ); return \"formLogin\" ; } return \"formLogin\" ; } @GetMapping ( \"/registro\" ) public String registroForm ( Model model ) { model . addAttribute ( \"registroData\" , new RegistroData ()); return \"formRegistro\" ; } @PostMapping ( \"/registro\" ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return \"registroForm\" ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( \"registroData\" , registroData ); model . addAttribute ( \"error\" , \"El usuario \" + registroData . geteMail () + \" ya existe\" ); return \"formRegistro\" ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return \"redirect:/login\" ; } @GetMapping ( \"/logout\" ) public String logout ( HttpSession session ) { session . setAttribute ( \"idUsuarioLogeado\" , null ); return \"redirect:/login\" ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } }","title":"Controllers"},{"location":"01-intro-spring-boot/practica1.html#vistas","text":"Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:fragment = \"head (titulo)\" > < meta charset = \"UTF-8\" /> < title th:text = \"${titulo}\" ></ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" > </ head > < div th:fragment = \"javascript\" > < script th:src = \"@{/js/jquery.min.js}\" ></ script > < script th:src = \"@{/js/popper.min.js.css}\" ></ script > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > < span th:text = \"${scripts}\" ></ span > </ div > /html> Vemos que las vistas usan el framework CSS Bootstrap y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n. Fichero src/main/resources/templates/listaTareas.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"row mt-3\" > < div class = \"col\" > < h2 th:text = \"'Listado de tareas de ' + ${usuario.nombre}\" ></ h2 > </ div > </ div > < div class = \"row mt-3\" > < div class = \"col\" > < table class = \"table table-striped\" > < thead > < tr > < th > Id </ th > < th > Tarea </ th > < th > Acci\u00f3n </ th > </ tr > </ thead > < tbody > < tr th:each = \"tarea: ${tareas}\" > < td th:text = \"${tarea.id}\" ></ td > < td th:text = \"${tarea.titulo}\" ></ td > < td >< a class = \"btn btn-primary btn-xs\" th:href = \"@{/tareas/{id}/editar(id=${tarea.id})}\" /> editar </ a > < a class = \"btn btn-danger btn-xs\" href = \"#\" onmouseover = \"\" style = \"cursor: pointer;\" th:onclick = \"'del(\\'/tareas/' + ${tarea.id} + '\\')'\" > borrar </ a > </ td > </ tr > </ tbody > </ table > < p >< a class = \"btn btn-primary\" th:href = \"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\" > Nueva tarea </ a > < a class = \"btn btn-link\" href = \"/logout\" > Salir </ a ></ p > </ div > </ div > < div class = \"row mt-2\" > < div class = \"col\" > < div class = \"alert alert-success alert-dismissible fade show\" role = \"alert\" th:if = \"${!#strings.isEmpty(mensaje)}\" > < span th:text = \"${mensaje}\" ></ span > < button type = \"button\" class = \"close\" data-dismiss = \"alert\" aria-label = \"Close\" > < span aria-hidden = \"true\" > &times; </ span > </ button > </ div > </ div > </ div > </ div > </ div > < div th:replace = \"fragments::javascript\" /> <!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --> < script type = \"text/javascript\" > function del ( urlBorrar ) { if ( confirm ( '\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?' )) { $ . ajax ({ url : urlBorrar , type : 'DELETE' , success : function ( results ) { //refresh the page location . reload (); } }); } } </ script > </ body > </ html > La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea.","title":"Vistas"},{"location":"01-intro-spring-boot/practica1.html#pruebas-manuales-y-automaticas","text":"Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/datos-dev.sql : 1 2 3 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'domingo@ua' , 'Domingo Gallardo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Para los tests autom\u00e1ticos se cargan los datos definidos en el fichero datos-tests.sql . Fichero src/test/resources/datos-test.sql : 1 2 3 4 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'ana.garcia@gmail.com' , 'Ana Garc\u00eda' , '12345678' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : Tambi\u00e9n sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Y sobre las vistas: UsuarioWebTest.java TareaWebTest.java En los tests sobre repository se debe usar la anotaci\u00f3n @Transactional para definir el contexto transaccional en el que se realiza la llamada a las acciones sobre la base de datos. En los tests sobre las vistas se mockean los servicios para que devuelvan los datos que nos interesan. Hay que ser cuidadoso al hacer pruebas que afectan a la base de datos, porque podemos insertar o modificar datos que se comprueban en otros tests. Tenemos que tener cuidado en que cada test sea independiente de los dem\u00e1s.","title":"Pruebas manuales y autom\u00e1ticas"},{"location":"01-intro-spring-boot/practica1.html#antes-de-empezar-la-practica","text":"Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-<usuario> en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la primera parte de la pr\u00e1ctica es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-20-21 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas. Descarga el proyecto y comprueba que se compila y ejecuta correctamente: 1 2 3 $ git clone https://github.com/mads-ua/todolist-<usuario>.git $ cd todolist-<usuario> $ ./mvnw spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: 1 2 spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: Crea un tablero Trello p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial .","title":"Antes de empezar la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#desarrollo-de-la-practica","text":"En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features: P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.","title":"Desarrollo de la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#version-101","text":"La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de .","title":"Versi\u00f3n 1.0.1"},{"location":"01-intro-spring-boot/practica1.html#resto-de-la-practica-version-110","text":"El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. En alguna de las caracter\u00edsticas deber\u00e1s tambi\u00e9n realizar alg\u00fan test de la vista.","title":"Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0)"},{"location":"01-intro-spring-boot/practica1.html#documentacion-entrega-y-evaluacion","text":"Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n /doc/practica1.md en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica . Puedes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente . Por ejemplo, la documentaci\u00f3n podr\u00eda contener: Listado de nuevas clases y m\u00e9todos implementados. Listado de plantillas thyemeleaf a\u00f1adidas. Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades implementadas. Tests de web implementados. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 20 de octubre. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html","text":"Pr\u00e1ctica 2: Integraci\u00f3n con GitHub Actions y TDD \u00b6 En esta pr\u00e1ctica 2 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua usando las actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request . Despu\u00e9s definiremos una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests sobre la base de datos MySQL. A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 10 de noviembre. Desarrollo de la release 1.2.0 \u00b6 En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release . Pasos a seguir \u00b6 Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en main es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega. Integraci\u00f3n continua con GitHub Actions \u00b6 GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions , Introduction to GitHub Actions y Building and testing Java with Maven . En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con main . Tests en los pull requests \u00b6 Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo ( workflows ) definidos en el directorio .github/workflows . GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main. El fichero de configuraci\u00f3n \u00b6 Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio .github/workflows . El fichero con el flujo de trabajo inicial lo llamaremos tests.yml : Fichero .github/workflows/tests.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name : Tests on : [ push ] jobs : build : runs - on : ubuntu - latest steps : - uses : actions / checkout @v2 - name : Set up JDK 1.8 uses : actions / setup - java @v1 with : java - version : 1.8 - name : Launch tests with Maven run : . / mvnw test Puntos interesantes a destacar: El nombre del flujo de trabajo es Tests . Con la palabra clave on se define el evento que causa que se lance el flujo de trabajo. Es en cualquier commit subido a GitHub (push). En jobs se definen los trabajos en paralelo a realizar por el flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno. En runs-on se define la m\u00e1quina base sobre la que se van a ejecutar los siguientes pasos del flujo. En uses: actions/checkout@v2 se especifica que se obtenga la versi\u00f3n 2 de la acci\u00f3n llamada actions/checkout . Esta acci\u00f3n se descarga el repositorio en la m\u00e1quina especificada anteriormente y lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n. En uses: actions/setup-java@v1 se especifica que se descargue los paquetes b\u00e1sicos de Java, en concreto la versi\u00f3n 1.8 (definido por la siguiente l\u00ednea with ). Por \u00faltimo, con el comando run: ./mvnw test se indica que el flujo de trabajo debe lanzar este comando, que es el que lanza los tests. Los nombres ( name ) son nombres arbitrarios que indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos sirven para localizar los distintos pasos. Builds en Actions \u00b6 En Actions tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado. En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n. Pasos a seguir \u00b6 Crea un issue llamado Integraci\u00f3n continua con GitHub Actions . Abre una rama integracion-continua-actions , s\u00fabela a GitHub y abre un pull request. A\u00f1ade el fichero .github/workflows/tests.yml . Haz un commit y s\u00fabelo a GitHub. Comprueba que se pasan los tests y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build falla. Vuelve a realizar los cambios para corregirlos, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request con main . Se volver\u00e1n a lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. 1 2 3 4 $ ( integracion-continua-actions ) git checkout main $ ( main ) git pull $ ( main ) git branch -d integracion-continua-actions $ ( main ) git remote prune origin Configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos MySQL de producci\u00f3n. En esta pr\u00e1ctica vamos a configurar un perfil de la aplicaci\u00f3n para poder lanzar los tests y ejecutar la aplicaci\u00f3n usando una base de datos MySQL. En la pr\u00e1ctica 3 veremos c\u00f3mo definir un perfil para trabajar con una base de datos de producci\u00f3n. Nota La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos en la pr\u00e1ctica 3 que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir un flujo de trabajo para implementar en el esquema de datos de la base de datos un cambio en el modelo de datos de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir distintas configuraciones de ejecuci\u00f3n de la aplicaci\u00f3n, utilizando los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos MySQL. La configuraci\u00f3n de tests con base de datos MySQL la utilizaremos para ejecutar los tests de integraci\u00f3n en el proceso de integraci\u00f3n continua de GitHub Actions. Ficheros de configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-mysql.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con MySQL. Estos ficheros de configuraci\u00f3n adicionales se cargan despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en application.properties . Pasos a seguir \u00b6 Instala Docker Desktop . Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Lo vamos a utilizar para lanzar el servidor MySQL de base de datos y tambi\u00e9n para la futura pr\u00e1ctica 3. Si tienes Windows, Docker no es compatible con VirtualBox . Si quieres usar ambos programas puedes usar una versi\u00f3n limitada de Docker llamada Docker Toolbox . Si tienes Ubuntu debes instalar Docker usando apt . Aqu\u00ed tienes un tutorial para instalar Docker en Ubuntu 18.04 . Prueba el tutorial r\u00e1pido de 2 minutos que viene junto con la instalaci\u00f3n de docker y que puedes lanzar desde el docker dashboard . Ese tutorial te ense\u00f1a c\u00f3mo crear una imagen Docker y como lanzar un contenedor a partir de esa imagen. En esta pr\u00e1ctica vamos a usar Docker s\u00f3lo para poner en marcha MySQL. En la pr\u00e1ctica siguiente ya veremos c\u00f3mo usarlo para dockerizar nuestra aplicaci\u00f3n. Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con MySQL . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. 1 2 $ ( main ) git checkout -b perfiles $ ( perfiles ) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-mysql.properties : 1 2 3 4 5 6 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos MySQL mads , su usuario ( root ) y contrase\u00f1a (vac\u00eda) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.MySQL5InnoDBDialect ). La propiedad spring.datasource.initialization-mode=never indica que no se debe cargar ning\u00fan fichero de datos inicial. Deber\u00e1s registrar un usuario inicial para poder probar la aplicaci\u00f3n. El esquema de la base de datos se actualizar\u00e1 si hay cambios en las entidades de la aplicaci\u00f3n, y los datos se mantendr\u00e1n en la base de datos. Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero en src/test/resources/application-mysql.properties : 1 2 3 4 5 spring.datasource.url=jdbc:mysql://localhost:3306/mads_test spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=create En este perfil la conexi\u00f3n se hace con una base de datos diferente: mads_test . La diferencia m\u00e1s importante del resto de par\u00e1metros es el valor de spring.jpa.hibernate.ddl-auto , que es create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver mysql-connector-java y poder utilizar una base de datos MySQL en la aplicaci\u00f3n: Fichero pom.xml : 1 2 3 4 5 6 7 8 9 <artifactId>h2</artifactId> <scope>runtime</scope> </dependency> + <dependency> + <groupId>mysql</groupId> + <artifactId>mysql-connector-java</artifactId> + </dependency> <dependency> <groupId>org.springframework.boot</groupId> Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor MySQL en el puerto 3306 con el usuario root sin contrase\u00f1a. Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: 1 docker run -d -p 3306:3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=mads mysql:5 Docker se descarga la imagen mysql:5 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 3306 (no debe estar ocupado) y sobre la base de datos mads . Le da como nombre mysql-develop . Puedes ejecutar los siguientes comandos de Docker: 1 2 3 4 $ docker container ls -a ( comprueba todos los contenedores en marcha ) $ docker container stop <nombre o id de contenedor> ( para un contenedor ) $ docker container start <nombre o id de contenedor> ( pone en marcha un contenedor ) $ docker container rm nombre o id de contenedor> ( elimina un contenedor ) Arranca la aplicaci\u00f3n con el siguiente comando: 1 ./mvnw spring-boot:run -Dspring.profiles.active=mysql Se activar\u00e1 el perfil mysql y se cargar\u00e1n las preferencias de src/main/resource/application.properties y src/main/resource/application-mysql.properties . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos con MySQL Workbench o alguna aplicaci\u00f3n similar. Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop : 1 2 3 4 $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e mysql:5 ... mysql-develop $ docker container stop mysql-develop Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker. Lanzamos ahora otro contenedor con la base de datos de test: 1 docker run -d -p 3306:3306 --name mysql-test -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=mads_test mysql:5 Y lanzamos los tests usando el perfil mysql con la base de datos MySQL con el siguiente comando: 1 ./mvnw test -Dspring.profiles.active=mysql Nos conectamos con MySQL Workbench a la base de datos mads_test y comprobamos que los datos que hay en la base de datos corresponden con los introducidos en el fichero datos-test.sql que se carga antes de ejecutar los tests. Podemos parar y arrancar el contenedor MySQL que necesitemos con docker container stop y docker container start . Como hemos dicho antes, mientras que no borres el contenedor los datos siguen estando en \u00e9l. Por ejemplo, para parar el contenedor MySQL con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: 1 2 3 $ docker container ls -a $ docker container stop mysql-test $ docker container start mysql-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en main : 1 2 3 4 5 6 7 8 $ ( perfiles ) git add . $ ( perfiles ) git commit -m \"A\u00f1adidos perfiles para trabajar con MySQL\" $ ( perfiles ) git push // Mezclamos el Pull Request en GitHub $ ( perfiles ) git checkout main $ ( main ) git pull $ ( main ) git branch -d perfiles $ ( main ) git remote prune origin TDD \u00b6 En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta. 008 Listado de equipos \u00b6 La descripci\u00f3n de la historia de usuario es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el nombre del equipo aparecer\u00e1 un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de abajo a arriba . Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional. Pasos a seguir \u00b6 Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea los issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo. Primer test - Entidad Equipo El primer test es para crear la entidad Equipo . Por ahora s\u00f3lo creamos la clase Java, sin las anotaciones JPA. Un equipo Fichero `src/test/java/madstodolist/EquipoTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package madstodolist ; import madstodolist.model.Equipo ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class EquipoTest { @Test public void crearEquipo () { Equipo equipo = new Equipo ( \"Proyecto P1\" ); assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); } } Escribe el c\u00f3digo necesario para que pase el test. No debes escribir c\u00f3digo de m\u00e1s, s\u00f3lo el c\u00f3digo m\u00ednimo para que el test pase . Haz un commit que contenga el test y el c\u00f3digo y s\u00fabelo a la rama remota. Segundo test - Entidad en base de datos Con el segundo test queremos conseguir que funcione JPA con la entidad Equipo y que podamos usar una tabla de equipos en la base de datos, en la que podamos guardar entidades equipo . Para comprobar que la entidad se ha guardado correctamente, comprobaremos se ha actualizando su identificador. Lo hacemos a\u00f1adiendo el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private EquipoRepository equipoRepository ; @Test @Transactional public void grabarEquipo () { // GIVEN Equipo equipo = new Equipo ( \"Proyecto P1\" ); // WHEN equipoRepository . save ( equipo ); // THEN assertThat ( equipo . getId ()). isNotNull (); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Tercer test - Definici\u00f3n de igualdad entre equipos Ahora que hemos introducido el id del equipo escribimos un test para comprobar que dos equipos son iguales. Debes escribir el c\u00f3digo de los m\u00e9todos equals y hashCode (necesario este \u00faltimo para que funcione correctamente la comprobaci\u00f3n de igualdades en las colecciones). Hacemos los tests para que el equals funcione de la siguiente forma: Si alguno de los dos equipos no tiene id (es null ), entonces se deben comparar sus nombres. Ahora bien, si los dos equipos tienen id , entonces se deben comparar esos id \". Puedes guiarte por la implementaci\u00f3n de equals y hashCode en Usuario . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Test public void comprobarIgualdadEquipos () { // GIVEN // Creamos tres equipos sin id, s\u00f3lo con el nombre Equipo equipo1 = new Equipo ( \"Proyecto P1\" ); Equipo equipo2 = new Equipo ( \"Proyecto P2\" ); Equipo equipo3 = new Equipo ( \"Proyecto P2\" ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isNotEqualTo ( equipo2 ); assertThat ( equipo2 ). isEqualTo ( equipo3 ); // WHEN // A\u00f1adimos identificadores y comprobamos igualdad por identificadores equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isEqualTo ( equipo2 ); assertThat ( equipo2 ). isNotEqualTo ( equipo3 ); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Cuarto test - Buscar equipo en base de datos Escribimos ahora un test para recuperar equipos por su identificador de la base de datos. A\u00f1adimos un equipo a la tabla en el fichero datos-test.sql para poder comprobar que funciona correctamente. A\u00f1adimos en el fichero src/test/java/resources/datos-test.sql : 1 INSERT INTO equipos (id, nombre) VALUES('1', 'Proyecto P1'); Test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void comprobarRecuperarEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo ). isNotNull (); assertThat ( equipo . getId ()). isEqualTo ( 1L ); assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); } Comprueba el test y si es necesario escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Quinto test - Relaci\u00f3n muchos-a-muchos entre equipos y usuarios Vamos ahora a dise\u00f1ar un test que introduzca la relaci\u00f3n entre equipos y usuarios. Debe ser una relaci\u00f3n muchos-a-muchos: un equipo contiene muchos usuarios y un usuario puede pertenecer a 0, 1 o muchos equipos. Para definir la relaci\u00f3n, JPA utiliza una tabla (la llamamos equipo_usuario ) en la que cada fila va a representar una relaci\u00f3n de un usuario con un equipo. Las columnas definen las claves ajenas que contienen el identificador de equipo y el del usuario. Para definir el test, creamos una relaci\u00f3n en la base de datos de prueba, en la que definimos que el equipo 1 tiene como usuario al usuario 1: 1 2 3 INSERT INTO tareas (id, titulo, usuario_id) VALUES('2', 'Renovar DNI', '1'); + INSERT INTO equipos (id, nombre) VALUES('1', 'Proyecto P1'); + INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES('1', '1'); Y comprobamos que se el usuario y equipo devuelto por cada clase repository tienen actualizada esa relaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Autowired private UsuarioRepository usuarioRepository ; @Test @Transactional public void comprobarRelacionBaseDatos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); Usuario usuario = usuarioRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo . getUsuarios ()). hasSize ( 1 ); assertThat ( equipo . getUsuarios ()). contains ( usuario ); assertThat ( usuario . getEquipos ()). hasSize ( 1 ); assertThat ( usuario . getEquipos ()). contains ( equipo ); } Para que este test funcione hay que crear la relaci\u00f3n muchos-a-muchos entre equipos y usuarios. Es necesario definir la anotaci\u00f3n @ManyToMany para indicar a JPA c\u00f3mo construir las tablas en la base de datos. En Equipo.java definimos la tabla en la que se va a guardar la relaci\u00f3n, e indicamos el papel de cada una de sus dos columnas. Tambi\u00e9n creamos el getter para obtener los usuarios. Fichero src/main/java/madstodolist/model/Equipo.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private String nombre; + @ManyToMany + @JoinTable(name = \"equipo_usuario\", + joinColumns = { @JoinColumn(name = \"fk_equipo\") }, + inverseJoinColumns = {@JoinColumn(name = \"fk_usuario\")}) + Set<Usuario> usuarios = new HashSet<>(); ... public void setId(Long id) { this.id = id; } + public Set<Usuario> getUsuarios() { + return usuarios; + } En el fichero Usuario.java definimos la parte inversa de la relaci\u00f3n. El mappedBy indica que la especificaci\u00f3n de la tabla join est\u00e1 en el otro lado de la relaci\u00f3n. Fichero src/main/java/madstodolist/model/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 @OneToMany(mappedBy = \"usuario\", fetch = FetchType.EAGER) Set<Tarea> tareas = new HashSet<>(); + @ManyToMany(mappedBy = \"usuarios\") + Set<Equipo> equipos = new HashSet<>(); ... + public Set<Equipo> getEquipos() { + return equipos; + } Comprueba el test, haz un commit en la rama y s\u00fabelo a GitHub. Sexto test - listado de equipos Ya por fin tenemos todo lo necesario para definir un test para obtener una lista de equipos en el repository : Actualizamos la base de datos de prueba con otro equipo: 1 2 INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES('1', '1'); + INSERT INTO equipos (id, nombre) VALUES('2', 'Proyecto P3'); Y a\u00f1adimos el test. Queremos que el tipo devuelto por el repository sea List . 1 2 3 4 5 6 7 8 9 10 11 @Test public void comprobarFindAll () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List < Equipo > equipos = equipoRepository . findAll (); // THEN assertThat ( equipos ). hasSize ( 2 ); } La soluci\u00f3n consiste en a\u00f1adir el m\u00e9todo findAll en la interfaz p EquipoRepository , definiendo el tipo devuelto como List . Spring Boot se encarga de construir autom\u00e1ticamente la implementaci\u00f3n de este m\u00e9todo. Fichero EquipoRepository.java : 1 2 3 4 5 + import java.util.List; public interface EquipoRepository extends CrudRepository<Equipo, Long> { + public List<Equipo> findAll(); } S\u00e9ptimo test - M\u00e9todo de servicio para el listado de equipos \u00a1Y por fin llegamos a la capa de servicio! Creamos el test que nos obliga a codificar en esa capa el m\u00e9todo que lista todos los equipos existentes. Lo llamamos findAllOrderedByName() para indicar que queremos que el resultado sea una lista ordenada por los nombres de los equipos. Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package madstodolist ; import madstodolist.model.Equipo ; import madstodolist.service.EquipoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import java.util.List ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class EquipoServiceTest { @Autowired EquipoService equipoService ; @Test public void obtenerListadoEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List < Equipo > equipos = equipoService . findAllOrderedByName (); // THEN assertThat ( equipos ). hasSize ( 2 ); assertThat ( equipos . get ( 0 ). getNombre ()). isEqualTo ( \"Proyecto P1\" ); assertThat ( equipos . get ( 1 ). getNombre ()). isEqualTo ( \"Proyecto P3\" ); } } Escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Octavo test - M\u00e9todo de servicio para recuperar un equipo Vamos a centrar este test en la forma de traer a memoria los objetos que participan en la relaci\u00f3n USUARIO-EQUIPO . En JPA hay dos formas de definir una relaci\u00f3n a-muchos: EAGER : Si una relaci\u00f3n a-muchos es EAGER , cuando la clase repository devuelve un objeto (ya sea al recuperarlo individualmente, o en una consulta en la que se recupera una colecci\u00f3n), se obtienen tambi\u00e9n de la base de datos todos los objetos con los que est\u00e1 relacionado. Por ejemplo, en la pr\u00e1ctica tenemos definida de esta forma la relaci\u00f3n entre usuarios y tareas. LAZY : Si una relaci\u00f3n a-muchos es LAZY , cuando la clase repository devuelve un objeto, no recupera de la base de datos los objetos relacionados. S\u00f3lo lo hace cuando se accede a la colecci\u00f3n que contiene la relaci\u00f3n. Entonces es cuando se realiza la consulta a la base de datos y se traen estos objetos a memoria. Si estos objetos tienen otras relaciones se traer\u00e1n a memoria o no dependiendo de si son EAGER o LAZY . Para que funcione la recuperaci\u00f3n perezosa debe estar abierta la conexi\u00f3n con la base de datos en el momento en que se accede a la colecci\u00f3n. Para ello es muy importante la etiqueta @Transactional . Cuando ponemos esta etiqueta en los m\u00e9todos de las clases de servicio se garantiza que todo el m\u00e9todo se realiza en una \u00fanica transacci\u00f3n. Por ello, al finalizar el m\u00e9todo se cerrar\u00e1 la conexi\u00f3n con la base de datos y el objeto que se devolver\u00e1 al controller estar\u00e1 desconectado de la base de datos , por lo que la recuperaci\u00f3n perezosa no funcionar\u00e1 en el controller . En el caso de la relaci\u00f3n USUARIO-EQUIPO vamos a definir el siguiente dise\u00f1o: La relaci\u00f3n entre un usuario y sus equipos ser\u00e1 EAGER . Cuando recuperemos un usuario, recuperaremos tambi\u00e9n la informaci\u00f3n de todos los equipos en los que participa. La relaci\u00f3n entre un equipo y sus usuarios ser\u00e1 LAZY . Esto es muy importante. Si no lo hici\u00e9ramos as\u00ed \u00a1podr\u00edamos f\u00e1cilmente traernos a memoria toda la base de datos!. Un equipo recuperar\u00eda todos sus usuarios, que tambi\u00e9n pueden estar en otros equipos, que a su vez tambi\u00e9n se traer\u00edan a memoria. Vamos entonces a definir un test que sirve para crear el m\u00e9todo de servicio que recupera un equipo y que se asegura de que la relaci\u00f3n entre equipos y usuarios es LAZY . Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void obtenerEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoService . findById ( 1L ); // THEN assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); // Comprobamos que la relaci\u00f3n con Usuarios es lazy: al // intentar acceder a la colecci\u00f3n de usuarios se debe lanzar una // excepci\u00f3n de tipo LazyInitializationException. assertThatThrownBy (() -> { equipo . getUsuarios (). size (); }). isInstanceOf ( LazyInitializationException . class ); } Comprueba si hay que modificar el c\u00f3digo, haz un commit y s\u00fabelo a GitHub. Noveno test - comprobaci\u00f3n de recuperaci\u00f3n eager de equipos Hacemos ahora un test para que un usuario recupere de forma eager sus equipos: Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void comprobarRelacionUsuarioEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Usuario usuario = usuarioService . findById ( 1L ); // THEN assertThat ( usuario . getEquipos ()). hasSize ( 1 ); } Comprueba que el test falla (por un error \"failed to lazily initialize a collection\"), arregla el c\u00f3digo para que pase, haz un commit y s\u00fabelo a GitHub. D\u00e9cimo test - M\u00e9todo de servicio para obtener los usuarios de un equipo El \u00faltimo test que sirve para definir el m\u00e9todo de servicio usuariosEquipo(Long idEquipo) que devuelve la lista de usuarios de un equipo. Despu\u00e9s de comprobar que la lista que se devuelve es correcta, volvemos a comprobar que la relaci\u00f3n entre usuarios y equipos es EAGER , esto es, que desde un usuario se puede obtener la lista de equipos a los que pertenece. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void obtenerUsuariosEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List < Usuario > usuarios = equipoService . usuariosEquipo ( 1L ); // THEN assertThat ( usuarios ). hasSize ( 1 ); assertThat ( usuarios . get ( 0 ). getEmail ()). isEqualTo ( \"ana.garcia@gmail.com\" ); // Comprobamos que la relaci\u00f3n entre usuarios y equipos es eager // Primero comprobamos que la colecci\u00f3n de equipos tiene 1 elemento assertThat ( usuarios . get ( 0 ). getEquipos ()). hasSize ( 1 ); // Y despu\u00e9s que el elemento es el equipo Proyecto P1 assertThat ( usuarios . get ( 0 ). getEquipos (). stream (). findFirst (). get (). getNombre ()). isEqualTo ( \"Proyecto P1\" ); } } Escribe el c\u00f3digo necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Cierre del issue Cuando hayas terminado todos los ciclos de TDD anteriores habr\u00e1s terminado el issue y testeado e implementado los m\u00e9todos necesarios para la clase de servicio que gestiona el listado de equipos y usuarios de esos equipos. Crea un pull request que cierre el issue , comprueba que GitHub Actions pasa correctamente los tests e int\u00e9gralo en main en GitHub. Baja los cambios al repositorio local. Vista y controller listado de equipos Abre un nuevo issue para implementar el controller y la vista que permita listar los equipos y sus miembros. Realiza el desarrollo del issue usando varios commits en los que a\u00f1adas las funcionalidades poco a poco. No hace falta que hagas TDD, pero a\u00f1ade al menos un test por cada m\u00e9todo del controller. Resto de historias de usuario \u00b6 Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Pasos a seguir \u00b6 Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica. Entrega y evaluaci\u00f3n \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de entrega es el martes 10 de noviembre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 7% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 2 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Pr\u00e1ctica 2"},{"location":"02-pruebas-tdd/integration-tdd.html#practica-2-integracion-con-github-actions-y-tdd","text":"En esta pr\u00e1ctica 2 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua usando las actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request . Despu\u00e9s definiremos una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests sobre la base de datos MySQL. A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 10 de noviembre.","title":"Pr\u00e1ctica 2: Integraci\u00f3n con GitHub Actions y TDD"},{"location":"02-pruebas-tdd/integration-tdd.html#desarrollo-de-la-release-120","text":"En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release .","title":"Desarrollo de la release 1.2.0"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir","text":"Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en main es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#integracion-continua-con-github-actions","text":"GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions , Introduction to GitHub Actions y Building and testing Java with Maven . En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con main .","title":"Integraci\u00f3n continua con GitHub Actions"},{"location":"02-pruebas-tdd/integration-tdd.html#tests-en-los-pull-requests","text":"Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo ( workflows ) definidos en el directorio .github/workflows . GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main.","title":"Tests en los pull requests"},{"location":"02-pruebas-tdd/integration-tdd.html#el-fichero-de-configuracion","text":"Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio .github/workflows . El fichero con el flujo de trabajo inicial lo llamaremos tests.yml : Fichero .github/workflows/tests.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name : Tests on : [ push ] jobs : build : runs - on : ubuntu - latest steps : - uses : actions / checkout @v2 - name : Set up JDK 1.8 uses : actions / setup - java @v1 with : java - version : 1.8 - name : Launch tests with Maven run : . / mvnw test Puntos interesantes a destacar: El nombre del flujo de trabajo es Tests . Con la palabra clave on se define el evento que causa que se lance el flujo de trabajo. Es en cualquier commit subido a GitHub (push). En jobs se definen los trabajos en paralelo a realizar por el flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno. En runs-on se define la m\u00e1quina base sobre la que se van a ejecutar los siguientes pasos del flujo. En uses: actions/checkout@v2 se especifica que se obtenga la versi\u00f3n 2 de la acci\u00f3n llamada actions/checkout . Esta acci\u00f3n se descarga el repositorio en la m\u00e1quina especificada anteriormente y lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n. En uses: actions/setup-java@v1 se especifica que se descargue los paquetes b\u00e1sicos de Java, en concreto la versi\u00f3n 1.8 (definido por la siguiente l\u00ednea with ). Por \u00faltimo, con el comando run: ./mvnw test se indica que el flujo de trabajo debe lanzar este comando, que es el que lanza los tests. Los nombres ( name ) son nombres arbitrarios que indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos sirven para localizar los distintos pasos.","title":"El fichero de configuraci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html#builds-en-actions","text":"En Actions tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado. En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n.","title":"Builds en Actions"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_1","text":"Crea un issue llamado Integraci\u00f3n continua con GitHub Actions . Abre una rama integracion-continua-actions , s\u00fabela a GitHub y abre un pull request. A\u00f1ade el fichero .github/workflows/tests.yml . Haz un commit y s\u00fabelo a GitHub. Comprueba que se pasan los tests y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build falla. Vuelve a realizar los cambios para corregirlos, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request con main . Se volver\u00e1n a lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. 1 2 3 4 $ ( integracion-continua-actions ) git checkout main $ ( main ) git pull $ ( main ) git branch -d integracion-continua-actions $ ( main ) git remote prune origin","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#configuracion-de-la-aplicacion","text":"Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos MySQL de producci\u00f3n. En esta pr\u00e1ctica vamos a configurar un perfil de la aplicaci\u00f3n para poder lanzar los tests y ejecutar la aplicaci\u00f3n usando una base de datos MySQL. En la pr\u00e1ctica 3 veremos c\u00f3mo definir un perfil para trabajar con una base de datos de producci\u00f3n. Nota La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos en la pr\u00e1ctica 3 que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir un flujo de trabajo para implementar en el esquema de datos de la base de datos un cambio en el modelo de datos de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir distintas configuraciones de ejecuci\u00f3n de la aplicaci\u00f3n, utilizando los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos MySQL. La configuraci\u00f3n de tests con base de datos MySQL la utilizaremos para ejecutar los tests de integraci\u00f3n en el proceso de integraci\u00f3n continua de GitHub Actions.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html#ficheros-de-configuracion-de-la-aplicacion","text":"Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-mysql.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con MySQL. Estos ficheros de configuraci\u00f3n adicionales se cargan despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en application.properties .","title":"Ficheros de configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_2","text":"Instala Docker Desktop . Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Lo vamos a utilizar para lanzar el servidor MySQL de base de datos y tambi\u00e9n para la futura pr\u00e1ctica 3. Si tienes Windows, Docker no es compatible con VirtualBox . Si quieres usar ambos programas puedes usar una versi\u00f3n limitada de Docker llamada Docker Toolbox . Si tienes Ubuntu debes instalar Docker usando apt . Aqu\u00ed tienes un tutorial para instalar Docker en Ubuntu 18.04 . Prueba el tutorial r\u00e1pido de 2 minutos que viene junto con la instalaci\u00f3n de docker y que puedes lanzar desde el docker dashboard . Ese tutorial te ense\u00f1a c\u00f3mo crear una imagen Docker y como lanzar un contenedor a partir de esa imagen. En esta pr\u00e1ctica vamos a usar Docker s\u00f3lo para poner en marcha MySQL. En la pr\u00e1ctica siguiente ya veremos c\u00f3mo usarlo para dockerizar nuestra aplicaci\u00f3n. Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con MySQL . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. 1 2 $ ( main ) git checkout -b perfiles $ ( perfiles ) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-mysql.properties : 1 2 3 4 5 6 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos MySQL mads , su usuario ( root ) y contrase\u00f1a (vac\u00eda) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.MySQL5InnoDBDialect ). La propiedad spring.datasource.initialization-mode=never indica que no se debe cargar ning\u00fan fichero de datos inicial. Deber\u00e1s registrar un usuario inicial para poder probar la aplicaci\u00f3n. El esquema de la base de datos se actualizar\u00e1 si hay cambios en las entidades de la aplicaci\u00f3n, y los datos se mantendr\u00e1n en la base de datos. Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero en src/test/resources/application-mysql.properties : 1 2 3 4 5 spring.datasource.url=jdbc:mysql://localhost:3306/mads_test spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=create En este perfil la conexi\u00f3n se hace con una base de datos diferente: mads_test . La diferencia m\u00e1s importante del resto de par\u00e1metros es el valor de spring.jpa.hibernate.ddl-auto , que es create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver mysql-connector-java y poder utilizar una base de datos MySQL en la aplicaci\u00f3n: Fichero pom.xml : 1 2 3 4 5 6 7 8 9 <artifactId>h2</artifactId> <scope>runtime</scope> </dependency> + <dependency> + <groupId>mysql</groupId> + <artifactId>mysql-connector-java</artifactId> + </dependency> <dependency> <groupId>org.springframework.boot</groupId> Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor MySQL en el puerto 3306 con el usuario root sin contrase\u00f1a. Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: 1 docker run -d -p 3306:3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=mads mysql:5 Docker se descarga la imagen mysql:5 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 3306 (no debe estar ocupado) y sobre la base de datos mads . Le da como nombre mysql-develop . Puedes ejecutar los siguientes comandos de Docker: 1 2 3 4 $ docker container ls -a ( comprueba todos los contenedores en marcha ) $ docker container stop <nombre o id de contenedor> ( para un contenedor ) $ docker container start <nombre o id de contenedor> ( pone en marcha un contenedor ) $ docker container rm nombre o id de contenedor> ( elimina un contenedor ) Arranca la aplicaci\u00f3n con el siguiente comando: 1 ./mvnw spring-boot:run -Dspring.profiles.active=mysql Se activar\u00e1 el perfil mysql y se cargar\u00e1n las preferencias de src/main/resource/application.properties y src/main/resource/application-mysql.properties . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos con MySQL Workbench o alguna aplicaci\u00f3n similar. Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop : 1 2 3 4 $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e mysql:5 ... mysql-develop $ docker container stop mysql-develop Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker. Lanzamos ahora otro contenedor con la base de datos de test: 1 docker run -d -p 3306:3306 --name mysql-test -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=mads_test mysql:5 Y lanzamos los tests usando el perfil mysql con la base de datos MySQL con el siguiente comando: 1 ./mvnw test -Dspring.profiles.active=mysql Nos conectamos con MySQL Workbench a la base de datos mads_test y comprobamos que los datos que hay en la base de datos corresponden con los introducidos en el fichero datos-test.sql que se carga antes de ejecutar los tests. Podemos parar y arrancar el contenedor MySQL que necesitemos con docker container stop y docker container start . Como hemos dicho antes, mientras que no borres el contenedor los datos siguen estando en \u00e9l. Por ejemplo, para parar el contenedor MySQL con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: 1 2 3 $ docker container ls -a $ docker container stop mysql-test $ docker container start mysql-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en main : 1 2 3 4 5 6 7 8 $ ( perfiles ) git add . $ ( perfiles ) git commit -m \"A\u00f1adidos perfiles para trabajar con MySQL\" $ ( perfiles ) git push // Mezclamos el Pull Request en GitHub $ ( perfiles ) git checkout main $ ( main ) git pull $ ( main ) git branch -d perfiles $ ( main ) git remote prune origin","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#tdd","text":"En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta.","title":"TDD"},{"location":"02-pruebas-tdd/integration-tdd.html#008-listado-de-equipos","text":"La descripci\u00f3n de la historia de usuario es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el nombre del equipo aparecer\u00e1 un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de abajo a arriba . Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional.","title":"008 Listado de equipos"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_3","text":"Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea los issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#resto-de-historias-de-usuario","text":"Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa.","title":"Resto de historias de usuario"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_4","text":"Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de entrega es el martes 10 de noviembre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 7% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 2 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Entrega y evaluaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html","text":"Pr\u00e1ctica 3: Trabajo en equipo con GitFlow y despliegue de la aplicaci\u00f3n \u00b6 Objetivos y resumen de la pr\u00e1ctica \u00b6 En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub. Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Implementar GitFlow. Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow. Despliegue en producci\u00f3n de la aplicaci\u00f3n, construyendo una imagen docker y lanz\u00e1ndola junto con la base de datos con docker compose . Formaci\u00f3n de equipos \u00b6 En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas (de forma excepcional podr\u00edan ser 2 o 4 personas). Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Se formar\u00e1 tambi\u00e9n un team en la organizaci\u00f3n mads-ua en el que participar\u00e1n todos los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio. Roles en el equipo \u00b6 Cada una de las tres personas del equipo tendr\u00e1 un papel diferente. Responsable de GitHub : encargado de gestionar el flujo de Git y de supervisar los pull requests, issues y tablero de GitHub. Resposable de integraci\u00f3n continua (devop) : encargado de gestionar Travis, Docker y configuraciones del proyecto. Responsable del producto : encargado de conocer y gestionar las historias de usuario, el tablero Trello y las pruebas de usuario del producto. Deb\u00e9is elegir qui\u00e9n va a tener cada papel. Pasos a seguir \u00b6 Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolistgrupo-2019-NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 1, el repositorio se crear\u00e1 en el grupo mads-ua . Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo: Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 1 y 2. Escoged el proyecto que vais a usar como punto de partida de estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: 1 2 $ git remote set-url origin https://github.com/mads-ua/todolistgrupo-2019-NOMBRE-EQUIPO.git $ git push -u origin master Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto (en el fichero POM.xml y en el about.html a mads-todolist-equipo-XX . Haced un commit directamente en master con estos cambios. Para conectar el repositorio con Travis el responsable de integraci\u00f3n continua debe acceder a su cuenta personal en Travis.com y sincronizar el nuevo repositorio todolistgrupo en la organizaci\u00f3n mads-ua . Puedes acceder a la p\u00e1gina para sincronizar este nuevo repositorio desde la p\u00e1gina principal de Travis, pulsando el bot\u00f3n + : Nuevo flujo de trabajo para los issues \u00b6 Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable del desarrollo del issue . Nueva rama con el issue : El responsable seleccionado ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable, trabajando sobre la rama. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Se archiva la tarjeta del issue . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al menos uno de los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Integraci\u00f3n del pull request : Cuando un miembro da el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios. Comandos Git \u00b6 Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: 1 2 $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar una rama del repositorio remoto: 1 2 $ git fetch $ git checkout nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas remote tracking a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). En el caso del comando anterior, el comando git checkout nueva-rama es equivalente a git checkout -b nueva-rama origin/nueva-rama . Se crea una rama local nueva-rama conectada a la rama origin/nueva-rama . Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: 1 $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . El comando git fetch actualiza la rama remota origin/nueva-rama . El comando git pull es equivalente a hacer: 1 2 3 $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: 1 2 (estando en la rama que queremos subir) $ git push El comando git push funcionar\u00e1 correctamente sin m\u00e1s par\u00e1metros si previamente hemos subido la rama con un git push -u . Comprobar el estado de las ramas locales y remotas: 1 $ git branch -vv Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: 1 2 $ git fetch --all $ git branch -vv Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que baja las ramas remotas cach\u00e9s locales. Informaci\u00f3n de los repositorios remotos: 1 $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. 1 $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminar: 1 2 $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama master . Podemos hacer un merge de la rama master en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en master y que necesitamos en nuestra nueva rama: 1 2 $ git checkout nueva-rama $ git merge master Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y master . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: 1 2 3 4 5 6 7 $ git checkout master $ git pull $ git checkout nueva-rama $ git merge master # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub Pasos a seguir \u00b6 Probad el nuevo flujo de trabajo en el tablero del proyecto creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en master y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n, indicando tambi\u00e9n su papel en el equipo. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en master que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en master . Configuraci\u00f3n de GitFlow \u00b6 El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ). Ramas de largo recorrido \u00b6 En GitFlow se publican las distintas versiones del proyecto en la rama long-lived master y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en master sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings > Branches > Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop . Ramas de feature \u00b6 Desde el comienzo de trabajo con Git en las pr\u00e1cticas 1 y 2 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request. Ramas de release \u00b6 Hasta ahora hemos hecho los releases en la rama master . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en master y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request. Pasos a seguir \u00b6 El responsable de GitHub se debe encargar de crear la rama develop y configurarla como rama principal del proyecto en GitHub. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. El responsable de integraci\u00f3n continua modificar\u00e1 el fichero de configuraci\u00f3n de Travis, para que tambi\u00e9n se lancen los builds en la rama develop (adem\u00e1s de en la rama master ). Haced un PR de prueba en la rama develop para comprobar que todo funciona bien. Cread tres issues distintos, simulando tres nuevas funcionalidades. Deben ser issues muy sencillos (cambiar el color de alg\u00fan elemento de la aplicaci\u00f3n, cambiar un texto, o algo similar). Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues. El responsable de GitHub configurar\u00e1 el repositorio para obligar a que cualquier pull request tenga que tener la revisi\u00f3n de una persona distinta del responsable del PR. Desarrollar e integrar los issues en develop siguiendo el flujo de trabajo planteado anteriormente. El responsable de GitHub se asegurar\u00e1 de que el tablero de GitHub se actualiza correctamente. Por \u00faltimo, vamos a probar el lanzamiento de una release usando el flujo de trabajo. Cread un issue con la tarea Lanzar release 1.3.0 que tendr\u00e1 como responsable al responsable de GitHub. El responsable de GitHub deber\u00e1 publicar la nueva versi\u00f3n siguiendo los pasos de GitFlow: Crear la rama local release-1.3.0 a partir de develop . Realizar en esta rama los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina Acerca de \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero pom.xml . Publicar la rama release-1.3.0 en GitHub y hacer un pull request sobre master . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en master creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas master y develop estar\u00e1n actualizadas a la nueva versi\u00f3n. Hacer por \u00faltimo un commit en develop (no hace falta PR) cambiando la versi\u00f3n a 1.4.0-SNAPSHOT . La rama develop tambi\u00e9n ser\u00e1 integrada por Travis. Debemos comprobar que pasan todos los tests de las nuevas caracter\u00edsticas que se a\u00f1aden. Por \u00faltimo, deber\u00e9is realizar un hot fix , simulando la resoluci\u00f3n de un error, siguiendo el flujo de trabajo de GitFlow, y actualizando el n\u00famero de versi\u00f3n a 1.3.1 . Despliegue en producci\u00f3n con Docker \u00b6 Este apartado lo realizar\u00e1 el responsable de integraci\u00f3n continua , pero todos los miembros del equipo deben conocer y entender todos los pasos. Sobreescribir propiedades desde la l\u00ednea de comando \u00b6 Hemos visto que al lanzar la aplicaci\u00f3n Spring Boot podemos seleccionar el perfil activo. Por ejemplo para lanzar la aplicaci\u00f3n usando como perfil activo el fichero application-mysql.properties : 1 mvn spring-boot:run -Dspring.profiles.active=mysql Tambi\u00e9n hemos visto que podemos seleccionar este perfile para lanzar los tests: 1 mvn test -Dspring.profiles.active=mysql La opci\u00f3n -D permite sobreescribir una propiedad del fichero de propiedades. Por ejemplo, podemos lanzar la aplicaci\u00f3n modificando el usuario y la contrase\u00f1a de una conexi\u00f3n a una base de datos con el siguiente comando: 1 mvn spring-boot:run -Dspring.datasource.username=root -Dspring.datasource.password=12345678 Tambi\u00e9n es posible definir variables en el propio fichero de propiedades para proporcionar nombres m\u00e1s cortos o reutilizar un mismo valor en varias propiedades. Por ejemplo, en el siguiente fichero application.properties definimos el nivel de logging (que puede ser off , fatal , error , warn , info , debug , trace , all ) y usamos el mismo nivel para los distintos paquetes de la aplicaci\u00f3n: 1 2 3 4 5 logging=info logging.level.org.springframework= ${ logging } logging.level.root= ${ logging } logging.level.org.hibernate= ${ logging } logging.level.sql= ${ logging } Podr\u00edamos entonces modificar el nivel de logs modificando la variable logging al lanzar los tests de la aplicaci\u00f3n, para que s\u00f3lo muestre los mensajes de error: 1 mvn test -Dloggin=error En la aplicaci\u00f3n vamos a usar esta variable y tambi\u00e9n otras que nos van a permitir configurar las propiedades relacionadas con la conexi\u00f3n con la base de datos. Pasos a seguir \u00b6 Abre un issue denominado Dockerizaci\u00f3n de la aplicaci\u00f3n en el que vas a configurar la aplicaci\u00f3n para lanzarla con docker-compose . Como siempre, desarrolla el issue en una rama propia. Modifica los ficheros de propiedades de ejecuci\u00f3n para que queden de la siguiente forma: Fichero src/main/resources/application.properties 1 2 3 4 5 6 7 8 9 10 11 12 13 spring.datasource.url=jdbc:h2:mem:dev spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update spring.datasource.data=classpath:datos-dev.sql spring.datasource.initialization-mode=always spring.h2.console.enabled=true spring.h2.console.path=/h2-console logging=info logging.level.org.springframework= ${ logging } logging.level.root= ${ logging } logging.level.org.hibernate= ${ logging } logging.level.sql= ${ logging } Fichero src/main/resources/application-mysql.properties 1 2 3 4 5 6 7 8 9 db_ip=localhost:3306 db_user=root db_passwd= spring.datasource.url=jdbc:mysql:// ${ db_ip } /mads spring.datasource.username= ${ db_user } spring.datasource.password= ${ db_passwd } spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never Probamos que funcionan bien las variables de configuraci\u00f3n. Para ello, lanzamos mysql en un puerto distinto, el 3316: 1 docker run -d -p 3316:3306 --name mysql-otro-puerto -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=mads mysql:5 y probamos a lanzar la aplicaci\u00f3n modificando la variable db_ip para que se conecte a ese nuevo puerto: 1 mvn spring-boot:run -Dspring.profiles.active=mysql -Ddb_ip=localhost:3316 La aplicaci\u00f3n debe arrancar correctamente, conect\u00e1ndose a la base de datos en el nuevo puerto. Por \u00faltimo, borramos el contenendor de prueba creado: 1 2 docker container stop mysql-otro-puerto docker container rm mysql-otro-puerto Realiza un commit con los nuevos ficheros de propiedades. Nota Es posible utilizar la variable db_ip para facilitar la conexi\u00f3n de la aplicaci\u00f3n a un contenedor Docker de MySQL lanzado en Windows con Docker Toolbox . En este caso hay que especificar la direcci\u00f3n IP en la que se est\u00e1 ejecutando el contenedor Docker. Imagen Docker de la aplicaci\u00f3n \u00b6 Hemos visto en teor\u00eda c\u00f3mo crear im\u00e1genes Docker. Vamos a crear una imagen con nuestra aplicaci\u00f3n mads-todolist . El fichero Dockerfile es el responsable de construir la m\u00e1quina Docker. Usaremos el siguiente Dockerfile : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #### Stage 1 : Build the application FROM openjdk : 8 - jdk - alpine as build # Set the current working directory inside the image WORKDIR / app # Copy maven executable to the image COPY mvnw . COPY . mvn . mvn # Copy the pom . xml file COPY pom . xml . # Build all the dependencies in preparation to go offline . # This is a separate step so the dependencies will be cached unless # the pom . xml file has changed . RUN . / mvnw dependency : go - offline - B # Copy the project source COPY src src # Package the application RUN . / mvnw package - DskipTests RUN mkdir - p target / dependency && ( cd target / dependency ; jar - xf .. /*.jar) #### Stage 2: A minimal docker image with command to run the app FROM openjdk:8-jre-alpine # Copy project dependencies from the build stage COPY --from=build /app/target/dependency/BOOT-INF/lib /app/lib COPY --from=build /app/target/dependency/META-INF /app/META-INF COPY --from=build /app/target/dependency/BOOT-INF/classes /app # Define environment variables ENV PROFILE= ENV DB_IP= ENV DB_USER= ENV DB_PASSWD= ENV LOGGING= CMD java -Dspring.profiles.active=$PROFILE -Ddb_ip=$DB_IP -Ddb_user=$DB_USER \\ -Ddb_passwd=$DB_PASSWD -Dlogging=$LOGGING -cp app:app/lib/* madstodolist.Application Se trata de un fichero que construye la imagen docker en dos fases. En una primera fase compila la aplicaci\u00f3n y guarda todos los jars en el directorio target . En la segunda fase crea la m\u00e1quina resultante, basada en openjdk:8-jre-alpine , con las librer\u00edas compiladas previamente. Docker permite definir variables de entorno que pueden ser modificadas al lanzar la m\u00e1quina. Definimos las mismas variables que hemos definido en el fichero de propiedades de spring boot: PROFILE : perfil a usar al lanzar la aplicaci\u00f3n. DB_IP : direcci\u00f3n IP y puerto de la base de datos con la que se debe conectar la aplicaci\u00f3n. DB_USER : usuario de la base de datos con el que la aplicaci\u00f3n se conecta con la base de datos. DB_PASSWD : contrase\u00f1a del usuario de la base de datos. LOGGING : nivel de logging que va a realizar la aplicaci\u00f3n. Para lanzar una imagen docker definiendo un valor de una variable de entorno hay que utilizar el flag -e VARIABLE=valor . Pasos a seguir \u00b6 Crea una cuenta en DockerHub . En esta cuenta se publicar\u00e1 la imagen docker de la aplicaci\u00f3n. Crea el fichero Dockerfile anterior en el directorio principal de la aplicaci\u00f3n. Construye la m\u00e1quina docker. Utiliza como usuario el usuario que has creado en DockerHub. 1 docker build -t USUARIO/mads-todolist-equipo-XX . Prueba a ejecutar la aplicaci\u00f3n trabajando con la base de datos en memoria y con logs de nivel INFO : 1 docker run --rm -it -p 8080:8080 -e LOGGING=error USUARIO/mads-todolist-equipo-XX El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C . Y prueba por \u00faltimo a ejecutar la aplicaci\u00f3n funcionando con la imagen docker con la base de datos MySQL: 1 2 3 4 $ docker run -d -p 3306 :3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 $ docker run --rm -it --link mysql-develop -p 8080 :8080 \\ -e PROFILE = mysql -e DB_IP = mysql-develop:3306 -e DB_USER = root -e LOGGING = info \\ USUARIO/mads-todolist-equipo-XX Cuando compruebes que todo funciona correctamente, sube a docker hub la imagen compilada: 1 2 3 $ docker login # introduce tus credenciales en docker hub $ docker push USUARIO/mads-todolist-equipo-XX Comprueba en docker hub que la imagen se ha subido correctamente. Uno de los compa\u00f1eros debe probar que la imagen funciona correctamente, ejecutando las dos instrucciones anteriores en su m\u00e1quina: 1 2 3 4 $ docker run -d -p 3306 :3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 $ docker run --rm -it --link mysql-develop -p 8080 :8080 \\ -e PROFILE = mysql -e DB_IP = mysql-develop:3306 -e DB_USER = root -e LOGGING = info \\ USUARIO/mads-todolist-equipo-XX Comprobad que se descarga correctamente la m\u00e1quina USUARIO/mads-todolist-equipo-XX y que la aplicaci\u00f3n se lanza sin errores. Por \u00faltimo, modifica el script de Travis para que sea Travis quien construya y publique la m\u00e1quina docker. Antes de que se ejecute el script deber\u00e1s configurar en los ajustes del repositorio en Travis ( travis-ci.com > USUARIO/mads-todolist-equipo-XX > Settings > Environment Variables ) las variables: DOCKER_USERNAME y DOCKER_PASSWORD , para que Travis pueda publicar en tu cuenta de DockerHub. L\u00edneas a a\u00f1adir al final del fichero .travis.yml : 1 2 3 4 5 6 7 8 after_success: - docker build -t USUARIO/mads-todolist-equipo-XX:$TRAVIS_BUILD_NUMBER . - if [ \"$TRAVIS_EVENT_TYPE\" != \"pull_request\" ]; then docker login -u=\"$DOCKER_USERNAME\" -p=\"$DOCKER_PASSWORD\"; docker push USUARIO/mads-todolist-equipo-XX:$TRAVIS_BUILD_NUMBER; docker tag USUARIO/mads-todolist-equipo-XX:$TRAVIS_BUILD_NUMBER USUARIO/mads-todolist-equipo-XX:latest; docker push USUARIO/mads-todolist-equipo-XX:latest; fi F\u00edjate en el script after_success . Es lo que Travis har\u00e1 despu\u00e9s de ejecutar con \u00e9xito los tests: Construir la m\u00e1quina docker de nuestra aplicaci\u00f3n, asign\u00e1ndole como etiqueta el n\u00famero de build actuar. Si la ejecuci\u00f3n de Travis es debida a un evento que no es un pull request (o sea, cuando sea un build disparado por el commit de merge con la rama en la que se integra el PR) se logea en docker hub con el usuario y la contrase\u00f1a definidas en las variables. Una vez logeado, publica la imagen usando como n\u00famero de tag el n\u00famero de build. Y esta \u00faltima imagen tambi\u00e9n se vuelve a etiquetar como latest y se vuelve a subir. Por ejemplo, cuando se realice el build #28 se publicar\u00e1 la imagen resultante de este build con las etiquetas 28 y latest : USUARIO/mads-todolist-equipo-XX:28 y USUARIO/mads-todolist-equipo-XX:latest . Por \u00faltimo, a\u00f1ade el siguiente fichero docker-compose.yml en el directorio ra\u00edz de la aplicaci\u00f3n. La aplicaci\u00f3n docker-compose permite automatizar la puesta en funcionamiento y conexi\u00f3n de m\u00e1s de un contenedor docker. En nuestro caso, servir\u00e1 para poner en marcha con un \u00fanico comando el contenedor de base de datos y nuestra aplicaci\u00f3n. Fichero docker-compose.yml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 version : '3.7' # Define services services : # App backend service mads - todolist : image : USUARIO / mads - todolist - equipo - XX ports : - \"8080:8080\" # Forward the exposed port 8080 on the container to port 8080 on the host machine restart : always depends_on : - db # This service depends on mysql . Start that first . environment : # Pass environment variables to the service PROFILE : mysql DB_IP : db : 3306 DB_USER : root LOGGING : info networks : # Networks to join ( Services on the same network can communicate with each other using their name ) - backend # Database Service ( Mysql ) db : image : mysql : 5 ports : - \"3306:3306\" restart : always environment : MYSQL_DATABASE : mads MYSQL_ALLOW_EMPTY_PASSWORD : 'yes' volumes : - db - data : / var / lib / mysql networks : - backend # Volumes volumes : db - data : # Networks to be created to facilitate communication between containers networks : backend : Prueba que funciona correctamente docker-compose ejecutando el comando docker-compose up . Para asegurarte de que la imagen que ejecutas es la que se descarga de docker hub debes borrar previamente la imagen que tengas en tu ordendador: 1 2 3 $ docker container prune $ docker image rm USUARIO/mads-todolist-equipo-XX $ docker-compose up Ver\u00e1s c\u00f3mo se ponen en marcha el contenedor mysql y el contenedor con nuestra aplicaci\u00f3n. Prueba a conectarte a la aplicaci\u00f3n y comprobar que todo funciona correctamente. Puedes terminar la ejecuci\u00f3n haciendo CTRL-C o lanzando desde otra terminal el comando 1 docker-compose down En el script de docker-compose el contenedor mysql utiliza un volumen . Esto permite conservar los datos que se introduzcan en la ejecuci\u00f3n del programa, aunque el contenedor se borre. Tambi\u00e9n ser\u00eda posible hacer un backup de estos datos a partir del volumen. Para listar los vol\u00famenes mantenidos por docker: 1 docker volume ls Para eliminar un volumen: 1 docker volume rm nombre-volumen Y para elminar todos los vol\u00famenes: 1 docker volume prune Haz un commit y sube los cambios a GitHub. Crea el pull request que cierra el issue y ci\u00e9rralo, comprobando que Travis construye la m\u00e1quina docker y la publica en docker hub. Por \u00faltimo un compa\u00f1ero debe probar el comando docker-compose up y comprobar si se ponen en marcha las im\u00e1genes docker y nuestra aplicaci\u00f3n funciona correctamente. Entrega y evaluaci\u00f3n \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 26 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 5% en la nota final de la asignatura. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las semanas y no dejar todo para la \u00faltima). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"Pr\u00e1ctica 3: Trabajo en equipo con GitFlow y despliegue de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#practica-3-trabajo-en-equipo-con-gitflow-y-despliegue-de-la-aplicacion","text":"","title":"Pr\u00e1ctica 3: Trabajo en equipo con GitFlow y despliegue de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub. Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Implementar GitFlow. Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow. Despliegue en producci\u00f3n de la aplicaci\u00f3n, construyendo una imagen docker y lanz\u00e1ndola junto con la base de datos con docker compose .","title":"Objetivos y resumen de la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#formacion-de-equipos","text":"En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas (de forma excepcional podr\u00edan ser 2 o 4 personas). Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Se formar\u00e1 tambi\u00e9n un team en la organizaci\u00f3n mads-ua en el que participar\u00e1n todos los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio.","title":"Formaci\u00f3n de equipos"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#roles-en-el-equipo","text":"Cada una de las tres personas del equipo tendr\u00e1 un papel diferente. Responsable de GitHub : encargado de gestionar el flujo de Git y de supervisar los pull requests, issues y tablero de GitHub. Resposable de integraci\u00f3n continua (devop) : encargado de gestionar Travis, Docker y configuraciones del proyecto. Responsable del producto : encargado de conocer y gestionar las historias de usuario, el tablero Trello y las pruebas de usuario del producto. Deb\u00e9is elegir qui\u00e9n va a tener cada papel.","title":"Roles en el equipo"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir","text":"Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolistgrupo-2019-NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 1, el repositorio se crear\u00e1 en el grupo mads-ua . Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo: Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 1 y 2. Escoged el proyecto que vais a usar como punto de partida de estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: 1 2 $ git remote set-url origin https://github.com/mads-ua/todolistgrupo-2019-NOMBRE-EQUIPO.git $ git push -u origin master Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto (en el fichero POM.xml y en el about.html a mads-todolist-equipo-XX . Haced un commit directamente en master con estos cambios. Para conectar el repositorio con Travis el responsable de integraci\u00f3n continua debe acceder a su cuenta personal en Travis.com y sincronizar el nuevo repositorio todolistgrupo en la organizaci\u00f3n mads-ua . Puedes acceder a la p\u00e1gina para sincronizar este nuevo repositorio desde la p\u00e1gina principal de Travis, pulsando el bot\u00f3n + :","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#nuevo-flujo-de-trabajo-para-los-issues","text":"Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable del desarrollo del issue . Nueva rama con el issue : El responsable seleccionado ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable, trabajando sobre la rama. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Se archiva la tarjeta del issue . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al menos uno de los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Integraci\u00f3n del pull request : Cuando un miembro da el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios.","title":"Nuevo flujo de trabajo para los issues"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#comandos-git","text":"Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: 1 2 $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar una rama del repositorio remoto: 1 2 $ git fetch $ git checkout nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas remote tracking a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). En el caso del comando anterior, el comando git checkout nueva-rama es equivalente a git checkout -b nueva-rama origin/nueva-rama . Se crea una rama local nueva-rama conectada a la rama origin/nueva-rama . Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: 1 $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . El comando git fetch actualiza la rama remota origin/nueva-rama . El comando git pull es equivalente a hacer: 1 2 3 $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: 1 2 (estando en la rama que queremos subir) $ git push El comando git push funcionar\u00e1 correctamente sin m\u00e1s par\u00e1metros si previamente hemos subido la rama con un git push -u . Comprobar el estado de las ramas locales y remotas: 1 $ git branch -vv Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: 1 2 $ git fetch --all $ git branch -vv Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que baja las ramas remotas cach\u00e9s locales. Informaci\u00f3n de los repositorios remotos: 1 $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. 1 $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminar: 1 2 $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama master . Podemos hacer un merge de la rama master en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en master y que necesitamos en nuestra nueva rama: 1 2 $ git checkout nueva-rama $ git merge master Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y master . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: 1 2 3 4 5 6 7 $ git checkout master $ git pull $ git checkout nueva-rama $ git merge master # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub","title":"Comandos Git"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_1","text":"Probad el nuevo flujo de trabajo en el tablero del proyecto creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en master y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n, indicando tambi\u00e9n su papel en el equipo. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en master que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en master .","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#configuracion-de-gitflow","text":"El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ).","title":"Configuraci\u00f3n de GitFlow"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ramas-de-largo-recorrido","text":"En GitFlow se publican las distintas versiones del proyecto en la rama long-lived master y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en master sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings > Branches > Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop .","title":"Ramas de largo recorrido"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ramas-de-feature","text":"Desde el comienzo de trabajo con Git en las pr\u00e1cticas 1 y 2 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request.","title":"Ramas de feature"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ramas-de-release","text":"Hasta ahora hemos hecho los releases en la rama master . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en master y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request.","title":"Ramas de release"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_2","text":"El responsable de GitHub se debe encargar de crear la rama develop y configurarla como rama principal del proyecto en GitHub. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. El responsable de integraci\u00f3n continua modificar\u00e1 el fichero de configuraci\u00f3n de Travis, para que tambi\u00e9n se lancen los builds en la rama develop (adem\u00e1s de en la rama master ). Haced un PR de prueba en la rama develop para comprobar que todo funciona bien. Cread tres issues distintos, simulando tres nuevas funcionalidades. Deben ser issues muy sencillos (cambiar el color de alg\u00fan elemento de la aplicaci\u00f3n, cambiar un texto, o algo similar). Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues. El responsable de GitHub configurar\u00e1 el repositorio para obligar a que cualquier pull request tenga que tener la revisi\u00f3n de una persona distinta del responsable del PR. Desarrollar e integrar los issues en develop siguiendo el flujo de trabajo planteado anteriormente. El responsable de GitHub se asegurar\u00e1 de que el tablero de GitHub se actualiza correctamente. Por \u00faltimo, vamos a probar el lanzamiento de una release usando el flujo de trabajo. Cread un issue con la tarea Lanzar release 1.3.0 que tendr\u00e1 como responsable al responsable de GitHub. El responsable de GitHub deber\u00e1 publicar la nueva versi\u00f3n siguiendo los pasos de GitFlow: Crear la rama local release-1.3.0 a partir de develop . Realizar en esta rama los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina Acerca de \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero pom.xml . Publicar la rama release-1.3.0 en GitHub y hacer un pull request sobre master . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en master creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas master y develop estar\u00e1n actualizadas a la nueva versi\u00f3n. Hacer por \u00faltimo un commit en develop (no hace falta PR) cambiando la versi\u00f3n a 1.4.0-SNAPSHOT . La rama develop tambi\u00e9n ser\u00e1 integrada por Travis. Debemos comprobar que pasan todos los tests de las nuevas caracter\u00edsticas que se a\u00f1aden. Por \u00faltimo, deber\u00e9is realizar un hot fix , simulando la resoluci\u00f3n de un error, siguiendo el flujo de trabajo de GitFlow, y actualizando el n\u00famero de versi\u00f3n a 1.3.1 .","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#despliegue-en-produccion-con-docker","text":"Este apartado lo realizar\u00e1 el responsable de integraci\u00f3n continua , pero todos los miembros del equipo deben conocer y entender todos los pasos.","title":"Despliegue en producci\u00f3n con Docker"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#sobreescribir-propiedades-desde-la-linea-de-comando","text":"Hemos visto que al lanzar la aplicaci\u00f3n Spring Boot podemos seleccionar el perfil activo. Por ejemplo para lanzar la aplicaci\u00f3n usando como perfil activo el fichero application-mysql.properties : 1 mvn spring-boot:run -Dspring.profiles.active=mysql Tambi\u00e9n hemos visto que podemos seleccionar este perfile para lanzar los tests: 1 mvn test -Dspring.profiles.active=mysql La opci\u00f3n -D permite sobreescribir una propiedad del fichero de propiedades. Por ejemplo, podemos lanzar la aplicaci\u00f3n modificando el usuario y la contrase\u00f1a de una conexi\u00f3n a una base de datos con el siguiente comando: 1 mvn spring-boot:run -Dspring.datasource.username=root -Dspring.datasource.password=12345678 Tambi\u00e9n es posible definir variables en el propio fichero de propiedades para proporcionar nombres m\u00e1s cortos o reutilizar un mismo valor en varias propiedades. Por ejemplo, en el siguiente fichero application.properties definimos el nivel de logging (que puede ser off , fatal , error , warn , info , debug , trace , all ) y usamos el mismo nivel para los distintos paquetes de la aplicaci\u00f3n: 1 2 3 4 5 logging=info logging.level.org.springframework= ${ logging } logging.level.root= ${ logging } logging.level.org.hibernate= ${ logging } logging.level.sql= ${ logging } Podr\u00edamos entonces modificar el nivel de logs modificando la variable logging al lanzar los tests de la aplicaci\u00f3n, para que s\u00f3lo muestre los mensajes de error: 1 mvn test -Dloggin=error En la aplicaci\u00f3n vamos a usar esta variable y tambi\u00e9n otras que nos van a permitir configurar las propiedades relacionadas con la conexi\u00f3n con la base de datos.","title":"Sobreescribir propiedades desde la l\u00ednea de comando"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_3","text":"Abre un issue denominado Dockerizaci\u00f3n de la aplicaci\u00f3n en el que vas a configurar la aplicaci\u00f3n para lanzarla con docker-compose . Como siempre, desarrolla el issue en una rama propia. Modifica los ficheros de propiedades de ejecuci\u00f3n para que queden de la siguiente forma: Fichero src/main/resources/application.properties 1 2 3 4 5 6 7 8 9 10 11 12 13 spring.datasource.url=jdbc:h2:mem:dev spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update spring.datasource.data=classpath:datos-dev.sql spring.datasource.initialization-mode=always spring.h2.console.enabled=true spring.h2.console.path=/h2-console logging=info logging.level.org.springframework= ${ logging } logging.level.root= ${ logging } logging.level.org.hibernate= ${ logging } logging.level.sql= ${ logging } Fichero src/main/resources/application-mysql.properties 1 2 3 4 5 6 7 8 9 db_ip=localhost:3306 db_user=root db_passwd= spring.datasource.url=jdbc:mysql:// ${ db_ip } /mads spring.datasource.username= ${ db_user } spring.datasource.password= ${ db_passwd } spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never Probamos que funcionan bien las variables de configuraci\u00f3n. Para ello, lanzamos mysql en un puerto distinto, el 3316: 1 docker run -d -p 3316:3306 --name mysql-otro-puerto -e MYSQL_ALLOW_EMPTY_PASSWORD=yes -e MYSQL_DATABASE=mads mysql:5 y probamos a lanzar la aplicaci\u00f3n modificando la variable db_ip para que se conecte a ese nuevo puerto: 1 mvn spring-boot:run -Dspring.profiles.active=mysql -Ddb_ip=localhost:3316 La aplicaci\u00f3n debe arrancar correctamente, conect\u00e1ndose a la base de datos en el nuevo puerto. Por \u00faltimo, borramos el contenendor de prueba creado: 1 2 docker container stop mysql-otro-puerto docker container rm mysql-otro-puerto Realiza un commit con los nuevos ficheros de propiedades. Nota Es posible utilizar la variable db_ip para facilitar la conexi\u00f3n de la aplicaci\u00f3n a un contenedor Docker de MySQL lanzado en Windows con Docker Toolbox . En este caso hay que especificar la direcci\u00f3n IP en la que se est\u00e1 ejecutando el contenedor Docker.","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#imagen-docker-de-la-aplicacion","text":"Hemos visto en teor\u00eda c\u00f3mo crear im\u00e1genes Docker. Vamos a crear una imagen con nuestra aplicaci\u00f3n mads-todolist . El fichero Dockerfile es el responsable de construir la m\u00e1quina Docker. Usaremos el siguiente Dockerfile : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #### Stage 1 : Build the application FROM openjdk : 8 - jdk - alpine as build # Set the current working directory inside the image WORKDIR / app # Copy maven executable to the image COPY mvnw . COPY . mvn . mvn # Copy the pom . xml file COPY pom . xml . # Build all the dependencies in preparation to go offline . # This is a separate step so the dependencies will be cached unless # the pom . xml file has changed . RUN . / mvnw dependency : go - offline - B # Copy the project source COPY src src # Package the application RUN . / mvnw package - DskipTests RUN mkdir - p target / dependency && ( cd target / dependency ; jar - xf .. /*.jar) #### Stage 2: A minimal docker image with command to run the app FROM openjdk:8-jre-alpine # Copy project dependencies from the build stage COPY --from=build /app/target/dependency/BOOT-INF/lib /app/lib COPY --from=build /app/target/dependency/META-INF /app/META-INF COPY --from=build /app/target/dependency/BOOT-INF/classes /app # Define environment variables ENV PROFILE= ENV DB_IP= ENV DB_USER= ENV DB_PASSWD= ENV LOGGING= CMD java -Dspring.profiles.active=$PROFILE -Ddb_ip=$DB_IP -Ddb_user=$DB_USER \\ -Ddb_passwd=$DB_PASSWD -Dlogging=$LOGGING -cp app:app/lib/* madstodolist.Application Se trata de un fichero que construye la imagen docker en dos fases. En una primera fase compila la aplicaci\u00f3n y guarda todos los jars en el directorio target . En la segunda fase crea la m\u00e1quina resultante, basada en openjdk:8-jre-alpine , con las librer\u00edas compiladas previamente. Docker permite definir variables de entorno que pueden ser modificadas al lanzar la m\u00e1quina. Definimos las mismas variables que hemos definido en el fichero de propiedades de spring boot: PROFILE : perfil a usar al lanzar la aplicaci\u00f3n. DB_IP : direcci\u00f3n IP y puerto de la base de datos con la que se debe conectar la aplicaci\u00f3n. DB_USER : usuario de la base de datos con el que la aplicaci\u00f3n se conecta con la base de datos. DB_PASSWD : contrase\u00f1a del usuario de la base de datos. LOGGING : nivel de logging que va a realizar la aplicaci\u00f3n. Para lanzar una imagen docker definiendo un valor de una variable de entorno hay que utilizar el flag -e VARIABLE=valor .","title":"Imagen Docker de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_4","text":"Crea una cuenta en DockerHub . En esta cuenta se publicar\u00e1 la imagen docker de la aplicaci\u00f3n. Crea el fichero Dockerfile anterior en el directorio principal de la aplicaci\u00f3n. Construye la m\u00e1quina docker. Utiliza como usuario el usuario que has creado en DockerHub. 1 docker build -t USUARIO/mads-todolist-equipo-XX . Prueba a ejecutar la aplicaci\u00f3n trabajando con la base de datos en memoria y con logs de nivel INFO : 1 docker run --rm -it -p 8080:8080 -e LOGGING=error USUARIO/mads-todolist-equipo-XX El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C . Y prueba por \u00faltimo a ejecutar la aplicaci\u00f3n funcionando con la imagen docker con la base de datos MySQL: 1 2 3 4 $ docker run -d -p 3306 :3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 $ docker run --rm -it --link mysql-develop -p 8080 :8080 \\ -e PROFILE = mysql -e DB_IP = mysql-develop:3306 -e DB_USER = root -e LOGGING = info \\ USUARIO/mads-todolist-equipo-XX Cuando compruebes que todo funciona correctamente, sube a docker hub la imagen compilada: 1 2 3 $ docker login # introduce tus credenciales en docker hub $ docker push USUARIO/mads-todolist-equipo-XX Comprueba en docker hub que la imagen se ha subido correctamente. Uno de los compa\u00f1eros debe probar que la imagen funciona correctamente, ejecutando las dos instrucciones anteriores en su m\u00e1quina: 1 2 3 4 $ docker run -d -p 3306 :3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 $ docker run --rm -it --link mysql-develop -p 8080 :8080 \\ -e PROFILE = mysql -e DB_IP = mysql-develop:3306 -e DB_USER = root -e LOGGING = info \\ USUARIO/mads-todolist-equipo-XX Comprobad que se descarga correctamente la m\u00e1quina USUARIO/mads-todolist-equipo-XX y que la aplicaci\u00f3n se lanza sin errores. Por \u00faltimo, modifica el script de Travis para que sea Travis quien construya y publique la m\u00e1quina docker. Antes de que se ejecute el script deber\u00e1s configurar en los ajustes del repositorio en Travis ( travis-ci.com > USUARIO/mads-todolist-equipo-XX > Settings > Environment Variables ) las variables: DOCKER_USERNAME y DOCKER_PASSWORD , para que Travis pueda publicar en tu cuenta de DockerHub. L\u00edneas a a\u00f1adir al final del fichero .travis.yml : 1 2 3 4 5 6 7 8 after_success: - docker build -t USUARIO/mads-todolist-equipo-XX:$TRAVIS_BUILD_NUMBER . - if [ \"$TRAVIS_EVENT_TYPE\" != \"pull_request\" ]; then docker login -u=\"$DOCKER_USERNAME\" -p=\"$DOCKER_PASSWORD\"; docker push USUARIO/mads-todolist-equipo-XX:$TRAVIS_BUILD_NUMBER; docker tag USUARIO/mads-todolist-equipo-XX:$TRAVIS_BUILD_NUMBER USUARIO/mads-todolist-equipo-XX:latest; docker push USUARIO/mads-todolist-equipo-XX:latest; fi F\u00edjate en el script after_success . Es lo que Travis har\u00e1 despu\u00e9s de ejecutar con \u00e9xito los tests: Construir la m\u00e1quina docker de nuestra aplicaci\u00f3n, asign\u00e1ndole como etiqueta el n\u00famero de build actuar. Si la ejecuci\u00f3n de Travis es debida a un evento que no es un pull request (o sea, cuando sea un build disparado por el commit de merge con la rama en la que se integra el PR) se logea en docker hub con el usuario y la contrase\u00f1a definidas en las variables. Una vez logeado, publica la imagen usando como n\u00famero de tag el n\u00famero de build. Y esta \u00faltima imagen tambi\u00e9n se vuelve a etiquetar como latest y se vuelve a subir. Por ejemplo, cuando se realice el build #28 se publicar\u00e1 la imagen resultante de este build con las etiquetas 28 y latest : USUARIO/mads-todolist-equipo-XX:28 y USUARIO/mads-todolist-equipo-XX:latest . Por \u00faltimo, a\u00f1ade el siguiente fichero docker-compose.yml en el directorio ra\u00edz de la aplicaci\u00f3n. La aplicaci\u00f3n docker-compose permite automatizar la puesta en funcionamiento y conexi\u00f3n de m\u00e1s de un contenedor docker. En nuestro caso, servir\u00e1 para poner en marcha con un \u00fanico comando el contenedor de base de datos y nuestra aplicaci\u00f3n. Fichero docker-compose.yml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 version : '3.7' # Define services services : # App backend service mads - todolist : image : USUARIO / mads - todolist - equipo - XX ports : - \"8080:8080\" # Forward the exposed port 8080 on the container to port 8080 on the host machine restart : always depends_on : - db # This service depends on mysql . Start that first . environment : # Pass environment variables to the service PROFILE : mysql DB_IP : db : 3306 DB_USER : root LOGGING : info networks : # Networks to join ( Services on the same network can communicate with each other using their name ) - backend # Database Service ( Mysql ) db : image : mysql : 5 ports : - \"3306:3306\" restart : always environment : MYSQL_DATABASE : mads MYSQL_ALLOW_EMPTY_PASSWORD : 'yes' volumes : - db - data : / var / lib / mysql networks : - backend # Volumes volumes : db - data : # Networks to be created to facilitate communication between containers networks : backend : Prueba que funciona correctamente docker-compose ejecutando el comando docker-compose up . Para asegurarte de que la imagen que ejecutas es la que se descarga de docker hub debes borrar previamente la imagen que tengas en tu ordendador: 1 2 3 $ docker container prune $ docker image rm USUARIO/mads-todolist-equipo-XX $ docker-compose up Ver\u00e1s c\u00f3mo se ponen en marcha el contenedor mysql y el contenedor con nuestra aplicaci\u00f3n. Prueba a conectarte a la aplicaci\u00f3n y comprobar que todo funciona correctamente. Puedes terminar la ejecuci\u00f3n haciendo CTRL-C o lanzando desde otra terminal el comando 1 docker-compose down En el script de docker-compose el contenedor mysql utiliza un volumen . Esto permite conservar los datos que se introduzcan en la ejecuci\u00f3n del programa, aunque el contenedor se borre. Tambi\u00e9n ser\u00eda posible hacer un backup de estos datos a partir del volumen. Para listar los vol\u00famenes mantenidos por docker: 1 docker volume ls Para eliminar un volumen: 1 docker volume rm nombre-volumen Y para elminar todos los vol\u00famenes: 1 docker volume prune Haz un commit y sube los cambios a GitHub. Crea el pull request que cierra el issue y ci\u00e9rralo, comprobando que Travis construye la m\u00e1quina docker y la publica en docker hub. Por \u00faltimo un compa\u00f1ero debe probar el comando docker-compose up y comprobar si se ponen en marcha las im\u00e1genes docker y nuestra aplicaci\u00f3n funciona correctamente.","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 26 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 5% en la nota final de la asignatura. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las semanas y no dejar todo para la \u00faltima). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"Entrega y evaluaci\u00f3n"},{"location":"04-iteracion-scrum/iteracion-scrum.html","text":"Pr\u00e1ctica 4: Sprint de Scrum \u00b6 Objetivos y resumen de la pr\u00e1ctica \u00b6 En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 3. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n TodoList . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 3 para desarrollar sobre la rama develop : Una tarjeta en el tablero de Trello para cada historia de usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que comenzamos en la pr\u00e1ctica 2. La historia de usuario se puede descomponer en mas de un issue en GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso, se deber\u00e1n etiquetar los issues con la etiqueta asociada a la historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues y pull requests El repositorio est\u00e1 conectado a Travis para hacer la integraci\u00f3n continua. Se comprueban de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop y se sube una imagen docker a Docker Hub cuando se realiza la integraci\u00f3n. En Docker Hub se tienen numerados todos los builds exitosos de develop , y est\u00e1 etiquetada como latest la \u00faltima versi\u00f3n de la imagen. Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior. Adem\u00e1s, aplicaremos algunos elementos de Scrum y pr\u00e1cticas de XP: Planificaci\u00f3n del sprint Reuniones de scrum diario Revisi\u00f3n del sprint (se har\u00e1 el \u00faltimo d\u00eda de clases de la asignatura) Retrospectiva del sprint Al menos dos sesiones de pair programming en las que deben participar todos los miembros del equipo. Se har\u00e1n en clase los d\u00edas 4 y 11 de diciembre. Artefactos del sprint \u00b6 El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint. Tablero Trello \u00b6 Cada equipo crear\u00e1 un tablero Trello compartido en el que se anotar\u00e1n en forma de tarjeta las historias de usuario candidatas para realizar en el sprint. El tablero debe ser p\u00fablico y su enlace se incluir\u00e1 en el t\u00edtulo del proyecto en GitHub, para que el profesor pueda consultarlo. El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Cada tarjeta Trello contendr\u00e1: T\u00edtulo de la historia de usuario Descripci\u00f3n en el formato visto en teor\u00eda: \"Como ... quiero ... para ...\" Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta) Responsable de la historia de usuario (otra etiqueta) : miembro del equipo que liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la responsable. Enlace a una p\u00e1gina Google Docs con los detalles de la historia de usuario realizada por el responsable de la historia de usuario: T\u00edtulo de historia de usuario Descripci\u00f3n y detalles Borrador del aspecto de la interfaz de usuario resultante (dibujado a mano y fotografiado o con alguna herramienta de mockup, lo que os resulte m\u00e1s sencillo) Condiciones de satisfacci\u00f3n (COS). Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia. Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: Backlog , Listas , En marcha , En prueba y Terminadas . Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Listas Se han elaborado todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en develop y publicada en la \u00faltima versi\u00f3n de Docker Hub. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n en la imagen descargada de Docker Hub. Importante Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs. Tablero GitHub \u00b6 El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. En los issues podremos tener: Desarrollo de historias de usuario (en parte o completas) Bugs y refactorizaciones Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de usuario en concreto Usaremos las etiquetas para definir el tipo de issue: C\u00f3digo de historia de usuario Bug Refactor Mejora t\u00e9cnica Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere. En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues/ pull requests movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando. Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto (se archivar\u00e1 la tarjeta del issue y se dejar\u00e1 s\u00f3lo la tarjeta del pull request). Done El pull request que se ha resuelto y el issue est\u00e1 integrado en develop . Planificaci\u00f3n del sprint \u00b6 La planificaci\u00f3n del sprint se realizar\u00e1 en la clase de pr\u00e1cticas del 27 de noviembre. Se seleccionar\u00e1n las historias de usuario a realizar en el sprint y se completar\u00e1n sus descripciones. Selecci\u00f3n del backlog \u00b6 Al comienzo de la pr\u00e1ctica el equipo seleccionar\u00e1 las historias de usuario a realizar en la iteraci\u00f3n, de forma que el tama\u00f1o total de las historias seleccionadas sea de 18 puntos (6 puntos por persona). Podr\u00e1n escogerse cualquiera de las historias definidas en el taller de mapping de historias de usuario realizado en clase, o idear alguna nueva. El resultado del taller de mapping de historias de usuario est\u00e1 recogido en el siguiente tablero: https://trello.com/b/V4zRe1Hi/historias-de-usuario-todolist Todos los miembros deber\u00e1n tomar el papel product owner y aportar ideas y sugerencias para definir las historias de usuario. Las historias seleccionadas se incluir\u00e1n en la columna Backlog del tablero Trello del equipo. Cada historia se analizar\u00e1, especificando claramente su descripci\u00f3n y su alcance. En la tarjeta de Trello se escribir\u00e1 el t\u00edtulo, el tama\u00f1o (etiqueta) y unas notas r\u00e1pidas con alguna aclaraci\u00f3n. Tambi\u00e9n se enlazar\u00e1 un documento Google Docs en el que el responsable de la historia deber\u00e1 especificarla con m\u00e1s detalle. Responsables de historia de usuario \u00b6 Una vez seleccionadas todas las historias los miembros del equipo elegir\u00e1n responsables para cada historia, se crear\u00e1 su p\u00e1gina Google Docs, y se detallar\u00e1 all\u00ed las condiciones de satisfacci\u00f3n y el borrador de la interfaz de usuario. Se crear\u00e1 el issue (o issues) correspondiente a la historia de usuario y se a\u00f1adir\u00e1 el responsable al issue. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. Desarrollo del sprint \u00b6 Se deber\u00e1n realizar los siguientes eventos definidos por Scrum, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: Scrum diario (al menos simular 2 reuniones: la segunda y tercera semana). En nuestro \"tiempo simulado\" en las pr\u00e1cticas, una semana es como un d\u00eda de trabajo completo en una empresa. 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Retrospectiva del sprint (en la semana final) Desarrollo de issues e historias \u00b6 Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en master. Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Seguimos usando Travis para la integraci\u00f3n continua. Como hemos hecho hasta ahora, cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Una vez terminados todos los issues de una historia de usuario, el responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a En prueba y el miembro del equipo responsable del producto realizar\u00e1 las pruebas manuales especificadas en sus COS sobre la \u00faltima imagen subida a Docker. Cuando se hayan superado todas las pruebas se pasar\u00e1 la historia a Terminada . Si se detectara alg\u00fan fallo, se volver\u00e1 la historia a En marcha y se abrir\u00e1 un issue de tipo bug para resolver el problema. Publicaci\u00f3n de nueva versi\u00f3n \u00b6 Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama master , y subir a DockerHub la imagen resultante con la etiqueta 1.4.0 . Documentaci\u00f3n del desarrollo \u00b6 Documentar los dailys , para incluir un informe en el documento. Documentar las sesiones de pair programming . Documentar la evoluci\u00f3n semanal de los tableros Trello y GitHub y calcular alguna m\u00e9trica del desarrollo (pull requests por semana, velocidad de la semana, gr\u00e1fica de burndown, etc.). Entrega y evaluaci\u00f3n \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 20 minutos en las clases de teor\u00eda y pr\u00e1ctica del 18 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint y las nuevas funcionalidades introducidas. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima imagen docker subida a Docker Hub. La fecha de entrega de la pr\u00e1ctica ser\u00e1 el domingo 22 de diciembre . En esa fecha se deber\u00e1 tener disponible: Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub. Deber\u00e1 contener: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog : historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en la Wiki). Funcionalidades implementadas : breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica. Informe sobre la metodolog\u00eda seguida : ejemplos de evoluci\u00f3n del tablero, alguna m\u00e9trica del desarrollo realizado en el sprint, etc. Informes sobre las reuniones de Scrum : planificaci\u00f3n del sprint, scrum diario, revisi\u00f3n y sobre las sesiones de pair programming . Resultado de la retrospectiva: qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. Versi\u00f3n 1.4.0 de la m\u00e1quina Docker en Docker Hub (es la m\u00e1quina que voy a usar para revisar la ejecuci\u00f3n de la pr\u00e1ctica). El repositorio GitHub deber\u00e1 incluir el tablero con el backlog del sprint con los PR completados. El tablero de Trello deber\u00e1 incluir el backlog del producto con las historias de usuario que se deb\u00edan implementar en el sprint y los enlaces a los documentos Google Docs con sus detalles. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de la asignatura. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Pr\u00e1ctica 4: Sprint de Scrum"},{"location":"04-iteracion-scrum/iteracion-scrum.html#practica-4-sprint-de-scrum","text":"","title":"Pr\u00e1ctica 4: Sprint de Scrum"},{"location":"04-iteracion-scrum/iteracion-scrum.html#objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 3. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n TodoList . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 3 para desarrollar sobre la rama develop : Una tarjeta en el tablero de Trello para cada historia de usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que comenzamos en la pr\u00e1ctica 2. La historia de usuario se puede descomponer en mas de un issue en GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso, se deber\u00e1n etiquetar los issues con la etiqueta asociada a la historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues y pull requests El repositorio est\u00e1 conectado a Travis para hacer la integraci\u00f3n continua. Se comprueban de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop y se sube una imagen docker a Docker Hub cuando se realiza la integraci\u00f3n. En Docker Hub se tienen numerados todos los builds exitosos de develop , y est\u00e1 etiquetada como latest la \u00faltima versi\u00f3n de la imagen. Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior. Adem\u00e1s, aplicaremos algunos elementos de Scrum y pr\u00e1cticas de XP: Planificaci\u00f3n del sprint Reuniones de scrum diario Revisi\u00f3n del sprint (se har\u00e1 el \u00faltimo d\u00eda de clases de la asignatura) Retrospectiva del sprint Al menos dos sesiones de pair programming en las que deben participar todos los miembros del equipo. Se har\u00e1n en clase los d\u00edas 4 y 11 de diciembre.","title":"Objetivos y resumen de la pr\u00e1ctica"},{"location":"04-iteracion-scrum/iteracion-scrum.html#artefactos-del-sprint","text":"El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint.","title":"Artefactos del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum.html#tablero-trello","text":"Cada equipo crear\u00e1 un tablero Trello compartido en el que se anotar\u00e1n en forma de tarjeta las historias de usuario candidatas para realizar en el sprint. El tablero debe ser p\u00fablico y su enlace se incluir\u00e1 en el t\u00edtulo del proyecto en GitHub, para que el profesor pueda consultarlo. El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Cada tarjeta Trello contendr\u00e1: T\u00edtulo de la historia de usuario Descripci\u00f3n en el formato visto en teor\u00eda: \"Como ... quiero ... para ...\" Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta) Responsable de la historia de usuario (otra etiqueta) : miembro del equipo que liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la responsable. Enlace a una p\u00e1gina Google Docs con los detalles de la historia de usuario realizada por el responsable de la historia de usuario: T\u00edtulo de historia de usuario Descripci\u00f3n y detalles Borrador del aspecto de la interfaz de usuario resultante (dibujado a mano y fotografiado o con alguna herramienta de mockup, lo que os resulte m\u00e1s sencillo) Condiciones de satisfacci\u00f3n (COS). Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia. Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: Backlog , Listas , En marcha , En prueba y Terminadas . Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Listas Se han elaborado todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en develop y publicada en la \u00faltima versi\u00f3n de Docker Hub. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n en la imagen descargada de Docker Hub. Importante Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs.","title":"Tablero Trello"},{"location":"04-iteracion-scrum/iteracion-scrum.html#tablero-github","text":"El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. En los issues podremos tener: Desarrollo de historias de usuario (en parte o completas) Bugs y refactorizaciones Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de usuario en concreto Usaremos las etiquetas para definir el tipo de issue: C\u00f3digo de historia de usuario Bug Refactor Mejora t\u00e9cnica Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere. En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues/ pull requests movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando. Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto (se archivar\u00e1 la tarjeta del issue y se dejar\u00e1 s\u00f3lo la tarjeta del pull request). Done El pull request que se ha resuelto y el issue est\u00e1 integrado en develop .","title":"Tablero GitHub"},{"location":"04-iteracion-scrum/iteracion-scrum.html#planificacion-del-sprint","text":"La planificaci\u00f3n del sprint se realizar\u00e1 en la clase de pr\u00e1cticas del 27 de noviembre. Se seleccionar\u00e1n las historias de usuario a realizar en el sprint y se completar\u00e1n sus descripciones.","title":"Planificaci\u00f3n del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum.html#seleccion-del-backlog","text":"Al comienzo de la pr\u00e1ctica el equipo seleccionar\u00e1 las historias de usuario a realizar en la iteraci\u00f3n, de forma que el tama\u00f1o total de las historias seleccionadas sea de 18 puntos (6 puntos por persona). Podr\u00e1n escogerse cualquiera de las historias definidas en el taller de mapping de historias de usuario realizado en clase, o idear alguna nueva. El resultado del taller de mapping de historias de usuario est\u00e1 recogido en el siguiente tablero: https://trello.com/b/V4zRe1Hi/historias-de-usuario-todolist Todos los miembros deber\u00e1n tomar el papel product owner y aportar ideas y sugerencias para definir las historias de usuario. Las historias seleccionadas se incluir\u00e1n en la columna Backlog del tablero Trello del equipo. Cada historia se analizar\u00e1, especificando claramente su descripci\u00f3n y su alcance. En la tarjeta de Trello se escribir\u00e1 el t\u00edtulo, el tama\u00f1o (etiqueta) y unas notas r\u00e1pidas con alguna aclaraci\u00f3n. Tambi\u00e9n se enlazar\u00e1 un documento Google Docs en el que el responsable de la historia deber\u00e1 especificarla con m\u00e1s detalle.","title":"Selecci\u00f3n del backlog"},{"location":"04-iteracion-scrum/iteracion-scrum.html#responsables-de-historia-de-usuario","text":"Una vez seleccionadas todas las historias los miembros del equipo elegir\u00e1n responsables para cada historia, se crear\u00e1 su p\u00e1gina Google Docs, y se detallar\u00e1 all\u00ed las condiciones de satisfacci\u00f3n y el borrador de la interfaz de usuario. Se crear\u00e1 el issue (o issues) correspondiente a la historia de usuario y se a\u00f1adir\u00e1 el responsable al issue. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno.","title":"Responsables de historia de usuario"},{"location":"04-iteracion-scrum/iteracion-scrum.html#desarrollo-del-sprint","text":"Se deber\u00e1n realizar los siguientes eventos definidos por Scrum, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: Scrum diario (al menos simular 2 reuniones: la segunda y tercera semana). En nuestro \"tiempo simulado\" en las pr\u00e1cticas, una semana es como un d\u00eda de trabajo completo en una empresa. 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Retrospectiva del sprint (en la semana final)","title":"Desarrollo del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum.html#desarrollo-de-issues-e-historias","text":"Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en master. Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Seguimos usando Travis para la integraci\u00f3n continua. Como hemos hecho hasta ahora, cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Una vez terminados todos los issues de una historia de usuario, el responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a En prueba y el miembro del equipo responsable del producto realizar\u00e1 las pruebas manuales especificadas en sus COS sobre la \u00faltima imagen subida a Docker. Cuando se hayan superado todas las pruebas se pasar\u00e1 la historia a Terminada . Si se detectara alg\u00fan fallo, se volver\u00e1 la historia a En marcha y se abrir\u00e1 un issue de tipo bug para resolver el problema.","title":"Desarrollo de issues e historias"},{"location":"04-iteracion-scrum/iteracion-scrum.html#publicacion-de-nueva-version","text":"Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama master , y subir a DockerHub la imagen resultante con la etiqueta 1.4.0 .","title":"Publicaci\u00f3n de nueva versi\u00f3n"},{"location":"04-iteracion-scrum/iteracion-scrum.html#documentacion-del-desarrollo","text":"Documentar los dailys , para incluir un informe en el documento. Documentar las sesiones de pair programming . Documentar la evoluci\u00f3n semanal de los tableros Trello y GitHub y calcular alguna m\u00e9trica del desarrollo (pull requests por semana, velocidad de la semana, gr\u00e1fica de burndown, etc.).","title":"Documentaci\u00f3n del desarrollo"},{"location":"04-iteracion-scrum/iteracion-scrum.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 20 minutos en las clases de teor\u00eda y pr\u00e1ctica del 18 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint y las nuevas funcionalidades introducidas. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima imagen docker subida a Docker Hub. La fecha de entrega de la pr\u00e1ctica ser\u00e1 el domingo 22 de diciembre . En esa fecha se deber\u00e1 tener disponible: Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub. Deber\u00e1 contener: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog : historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en la Wiki). Funcionalidades implementadas : breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica. Informe sobre la metodolog\u00eda seguida : ejemplos de evoluci\u00f3n del tablero, alguna m\u00e9trica del desarrollo realizado en el sprint, etc. Informes sobre las reuniones de Scrum : planificaci\u00f3n del sprint, scrum diario, revisi\u00f3n y sobre las sesiones de pair programming . Resultado de la retrospectiva: qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. Versi\u00f3n 1.4.0 de la m\u00e1quina Docker en Docker Hub (es la m\u00e1quina que voy a usar para revisar la ejecuci\u00f3n de la pr\u00e1ctica). El repositorio GitHub deber\u00e1 incluir el tablero con el backlog del sprint con los PR completados. El tablero de Trello deber\u00e1 incluir el backlog del producto con las historias de usuario que se deb\u00edan implementar en el sprint y los enlaces a los documentos Google Docs con sus detalles. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de la asignatura. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Entrega y evaluaci\u00f3n"}]}