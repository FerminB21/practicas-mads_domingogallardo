{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante. Pr\u00e1ctica 0 Introducci\u00f3n a Spring Boot para MADS Comandos Git Enunciado pr\u00e1ctica 0 Construido con MkDocs Versi\u00f3n HTML compilada usando el tema Material de MkDocs . Repositorio en GitHub .","title":"Home"},{"location":"01-intro-spring-boot/comandos-git.html","text":"Resumen de comandos Git Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi). Comandos b\u00e1sicos Configurar el usuario y direcci\u00f3n de correo en git: 1 2 $ git config --global user.name John Doe $ git config --global user.email johndoe@example.com Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name lt ; nombre-usuario gt ; $ git config --global user.email lt ; email gt ; $ git init $ git add . $ git commit -m Versi\u00f3n inicial Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin https://github.com/ lt ; usuario gt ; / lt ; nombre-repo gt ; .git $ git push -u origin master El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama master (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add lt ; fichero o directorio gt ; El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m Mensaje Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD lt ; fichero gt ; Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m Mensaje Se puede abreviar como 1 $ git commit -am Mensaje ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd ( si se ha a\u00f1adido alg\u00fan fichero ) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [ --oneline ] [ --graph ] [ --all ] Comprobar las diferencias entre dos commits: 1 $ git diff lt ; hash-previo gt ; lt ; hash-nuevo gt ; Devuelve las cambios que se han introducido desde el commit identificado por y hasta el . Ramas Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt ( si hay cambios en el espacio de trabajo se llevan a la nueva rama ) Switched to a new branch nueva-rama Listar todas las ramas de un repositorio (incluyendo ramas remotas) 1 2 3 4 $ git branch -av master * nueva-rama $ git commit -a -m Confirmamos los cambios en la nueva rama Moverse a otra rama: 1 2 $ git checkout master Switched to branch master Mostrar un fichero de una rama (o commit) dado: 1 $ git show lt ; commit o rama gt ; : lt ; nombre-fichero gt ; Comparar dos ramas: 1 $ git diff master nueva-rama El comando git diff master nueva-rama devuelve las diferencias entre las ramas master y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama master . Merge de ramas : Mezclar la rama nueva-rama en la rama master (a\u00f1ade a la master los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout master $ git merge [ --no-ff ] nueva-rama -m Mensaje de commit La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT ( content ) : Merge conflict in hola.txt Automatic merge failed ; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m Arreglado el conflicto en el merge $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama master ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m Cambios en experiment $ git checkout master # hacemos cambios $ git commit -a -m Cambios en master $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama master ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama master y tener una historia lineal: 1 2 3 4 $ git checkout master $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase master CONFLICT ( content ) : Merge conflict in lt ; some-file gt ; # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use git reset HEAD lt;some-file gt;... to unstage) # (use git add/rm lt;some-file gt;... as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add lt ; some-file gt ; $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama ( was c241d7b ) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin lt ; rama gt ; Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b lt ; rama gt ; origin/ lt ; rama gt ; Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete lt ; branchName gt ; Modificar la historia Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [ --m Nuevo mensaje ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout lt ; hash gt ; ( o tag, por ejemplo v2.0 ) You are in detached HEAD state. # Ahora est\u00e1s en un detached HEAD $ git branch * ( HEAD detached at 594b606 ) master $ git checkout -b v2.0.1 Switched to a new branch v2.0.1 $ git branch master * v2.0.1 $ git checkout master Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard lt ; hash gt ; M\u00e1s informaci\u00f3n Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"Comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#resumen-de-comandos-git","text":"Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).","title":"Resumen de comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#comandos-basicos","text":"Configurar el usuario y direcci\u00f3n de correo en git: 1 2 $ git config --global user.name John Doe $ git config --global user.email johndoe@example.com Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name lt ; nombre-usuario gt ; $ git config --global user.email lt ; email gt ; $ git init $ git add . $ git commit -m Versi\u00f3n inicial Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin https://github.com/ lt ; usuario gt ; / lt ; nombre-repo gt ; .git $ git push -u origin master El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama master (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add lt ; fichero o directorio gt ; El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m Mensaje Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD lt ; fichero gt ; Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m Mensaje Se puede abreviar como 1 $ git commit -am Mensaje ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd ( si se ha a\u00f1adido alg\u00fan fichero ) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [ --oneline ] [ --graph ] [ --all ] Comprobar las diferencias entre dos commits: 1 $ git diff lt ; hash-previo gt ; lt ; hash-nuevo gt ; Devuelve las cambios que se han introducido desde el commit identificado por y hasta el .","title":"Comandos b\u00e1sicos"},{"location":"01-intro-spring-boot/comandos-git.html#ramas","text":"Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt ( si hay cambios en el espacio de trabajo se llevan a la nueva rama ) Switched to a new branch nueva-rama Listar todas las ramas de un repositorio (incluyendo ramas remotas) 1 2 3 4 $ git branch -av master * nueva-rama $ git commit -a -m Confirmamos los cambios en la nueva rama Moverse a otra rama: 1 2 $ git checkout master Switched to branch master Mostrar un fichero de una rama (o commit) dado: 1 $ git show lt ; commit o rama gt ; : lt ; nombre-fichero gt ; Comparar dos ramas: 1 $ git diff master nueva-rama El comando git diff master nueva-rama devuelve las diferencias entre las ramas master y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama master . Merge de ramas : Mezclar la rama nueva-rama en la rama master (a\u00f1ade a la master los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout master $ git merge [ --no-ff ] nueva-rama -m Mensaje de commit La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT ( content ) : Merge conflict in hola.txt Automatic merge failed ; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m Arreglado el conflicto en el merge $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama master ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m Cambios en experiment $ git checkout master # hacemos cambios $ git commit -a -m Cambios en master $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama master ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama master y tener una historia lineal: 1 2 3 4 $ git checkout master $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase master CONFLICT ( content ) : Merge conflict in lt ; some-file gt ; # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use git reset HEAD lt;some-file gt;... to unstage) # (use git add/rm lt;some-file gt;... as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add lt ; some-file gt ; $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama ( was c241d7b ) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin lt ; rama gt ; Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b lt ; rama gt ; origin/ lt ; rama gt ; Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete lt ; branchName gt ;","title":"Ramas"},{"location":"01-intro-spring-boot/comandos-git.html#modificar-la-historia","text":"Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [ --m Nuevo mensaje ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout lt ; hash gt ; ( o tag, por ejemplo v2.0 ) You are in detached HEAD state. # Ahora est\u00e1s en un detached HEAD $ git branch * ( HEAD detached at 594b606 ) master $ git checkout -b v2.0.1 Switched to a new branch v2.0.1 $ git branch master * v2.0.1 $ git checkout master Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard lt ; hash gt ;","title":"Modificar la historia"},{"location":"01-intro-spring-boot/comandos-git.html#mas-informacion","text":"Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"M\u00e1s informaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html","text":"Introducci\u00f3n a Spring Boot para las pr\u00e1cticas de MADS Descarga de la aplicaci\u00f3n ejemplo Empieza descargando una sencilla aplicaci\u00f3n ejemplo Spring Boot desde este enlace de GitHub . Puedes hacerlo usando Git: 1 $ git clone https://github.com/domingogallardo/spring-boot-demoapp.git La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona. Ejecuci\u00f3n de aplicaciones Spring Boot Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java: 1 2 $ mvn package $ java -jar target/clientesapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: 1 $ mvn spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito Desarrollo y ejecuci\u00f3n con IntelliJ Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para importar un proyecto Spring Boot en IntelliJ basta con importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File New Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ importa el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc: Conceptos de Spring Boot Estructura de la aplicaci\u00f3n Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId es.ua.mads /groupId artifactId demoapp /artifactId version 0.0.1-SNAPSHOT /version parent groupId org.springframework.boot /groupId artifactId spring-boot-starter-parent /artifactId version 2.1.6.RELEASE /version /parent dependencies dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-web /artifactId /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-thymeleaf /artifactId /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-test /artifactId scope test /scope /dependency /dependencies build plugins plugin groupId org.springframework.boot /groupId artifactId spring-boot-maven-plugin /artifactId /plugin /plugins /build /project En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties 1 spring.application.name = demoapp Controladores Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { private final SaludoService service ; @Autowired public SaludoController ( SaludoService service ) { this . service = service ; } @RequestMapping ( /saludo/{nombre} ) public @ResponseBody String saludo ( @PathVariable ( value = nombre ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: 1 2 3 4 5 6 HTTP / 1 . 1 200 Content-Type : text / plain ; charset = UTF-8 Content-Length : 8 Date : Mon , 02 Sep 2019 14 : 59 : 04 GMT Hola Ana Clases de Servicio Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java 1 2 3 4 5 6 7 8 9 10 package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return Hola + nombre ; } } Inyecci\u00f3n de dependencias en Spring Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. En este caso lo hacemos anotando el constructor. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable service que se pasa como par\u00e1metro al constructor. Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection Alcance de los objetos inyectados Por defecto el alcance ( scope ) de todas las anotaciones de Spring ( @service , @controller , @component , etc.) es un Singleton . Existe una \u00fanica instancia de ese objeto que es la que se inyecta en las variables. Al estar funcionando en una aplicaci\u00f3n web, el singleton que hace de controlador recibir\u00e1 m\u00faltiples peticiones concurrentemente. Cada petici\u00f3n ir\u00e1 en su propio hilo de Java, por lo que m\u00faltiples hilos podr\u00e1n estar ejecutando el mismo c\u00f3digo del controlador. Por ello hay que tener cuidado en no definir variables de instancia mutables (con estado) dentro del controlador, porque podr\u00edan producirse errores debidos a condiciones de carrera (un hilo modifica la misma variable que otro est\u00e1 leyendo). Es conveniente que todos los beans (controladores, servicios, etc.) sean objetos sin estado. Tambi\u00e9n es posible definir otros alcances, como @RequestScope o @SessionScope . En el primer caso se crea una instancia nueva del objeto para cada petici\u00f3n HTTP y en el segundo se crea una instancia nueva en cada sesi\u00f3n HTTP. Puedes encontrar m\u00e1s informaci\u00f3n y ejemplos en este enlace . Plantillas Thymeleaf La aplicaci\u00f3n devuelve p\u00e1ginas HTML, vistas que se construyen utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html 1 2 3 4 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org h1 th:text = Saludo: + ${mensaje} / h1 / html El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { private final SaludoService service ; @Autowired public SaludoControllerPlantilla ( SaludoService service ) { this . service = service ; } @RequestMapping ( /saludoplantilla/{nombre} ) public String saludo ( @PathVariable ( value = nombre ) String nombre , Model model ) { model . addAttribute ( mensaje , service . saluda ( nombre )); return saludo ; } } Tests En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: 1 $ mvn test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ. Tests sobre clases de servicio Podemos realizar pruebas sobre la capa de servicio, obteniendo una instancia del servicio mediante inyecci\u00f3n de dependencias. En el siguiente ejemplo se muestra c\u00f3mo se prueba el m\u00e9todo de servicio saluda . Fichero src/test/java/demoapp/ServiceTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package demoapp ; import demoapp.service.SaludoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class ServiceTest { @Autowired SaludoService saludo ; @Test public void contexLoads () throws Exception { assertThat ( saludo ). isNotNull (); } @Test public void serviceSaludo () throws Exception { assertThat ( saludo . saluda ( Domingo )). isEqualTo ( Hola Domingo ); } } Tests sobre capa web Es posible realizar tests sobre la capa de presentaci\u00f3n sin lanzar realmente el servidor web ni ejecutar realmente las peticiones HTTP. Se obtiene por inyecci\u00f3n de dependencias un mock de la clase MockMvc y se usan m\u00e9todos como perform(get(\"/\")) . En el ejemplo siguiente se comprueba que una petici\u00f3n GET a la URL / devuelve un c\u00f3digo HTTP OK (200) y una p\u00e1gina HTML con la cadena esperada. En este test lo \u00fanico que se moquea es el servidor web, y se ejecuta el c\u00f3digo real del servicio, del controlador y de la plantilla. Fichero src/test/demoapp/AutoConfigureWebMockTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package demoapp ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @RunWith ( SpringRunner . class ) @SpringBootTest @AutoConfigureMockMvc public class AutoConfigureWebMockTest { @Autowired private MockMvc mockMvc ; @Test public void shouldReturnDefaultMessage () throws Exception { this . mockMvc . perform ( get ( / )) . andDo ( print ()) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( Hello World ))); } } Tambi\u00e9n es posible realizar un test \u00fanicamente del controlador y la plantilla de presentaci\u00f3n, moqueando el servicio. Se muestra en el siguiente ejemplo. Fichero src/test/java/WebMockTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package demoapp ; import demoapp.controller.SaludoController ; import demoapp.service.SaludoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest ; import org.springframework.boot.test.mock.mockito.MockBean ; import org.springframework.test.context.junit4.SpringRunner ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.mockito.Mockito.when ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @RunWith ( SpringRunner . class ) @WebMvcTest ( SaludoController . class ) public class WebMockTest { @Autowired private MockMvc mockMvc ; @MockBean private SaludoService service ; @Test public void greetingShouldReturnMessageFromService () throws Exception { when ( service . saluda ( Domingo )). thenReturn ( Hola Mock Domingo ); this . mockMvc . perform ( get ( /saludo/Domingo )) . andDo ( print ()) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( Hola Mock Domingo ))); } } Tests sobre la aplicaci\u00f3n en funcionamiento Por \u00faltimo, tambi\u00e9n podemos realizar tests sobre la aplicaci\u00f3n funcionando completamente, realizando una petici\u00f3n al servidor web y comprobando que se devuelve lo esperado. Fichero src/test/java/demoapp/HttpRequestTest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package demoapp ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.context.SpringBootTest.WebEnvironment ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.web.server.LocalServerPort ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest ( webEnvironment = WebEnvironment . RANDOM_PORT ) public class HttpRequestTest { @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; @Test public void greetingShouldReturnDefaultMessage () throws Exception { assertThat ( this . restTemplate . getForObject ( http://localhost: + port + / , String . class )). contains ( Hello World ); } } Referencias Getting Started Guide Building an Application with Spring Boot Getting Started Guide Serving Web Content with Spring MVC Spring Boot Reference Guide 2.2.0.BUILD-SNAPSHOT ( HTML , PDF )","title":"Introducci\u00f3n a Sprign Boot para MADS"},{"location":"01-intro-spring-boot/intro-spring-boot.html#introduccion-a-spring-boot-para-las-practicas-de-mads","text":"","title":"Introducci\u00f3n a Spring Boot para las pr\u00e1cticas de MADS"},{"location":"01-intro-spring-boot/intro-spring-boot.html#descarga-de-la-aplicacion-ejemplo","text":"Empieza descargando una sencilla aplicaci\u00f3n ejemplo Spring Boot desde este enlace de GitHub . Puedes hacerlo usando Git: 1 $ git clone https://github.com/domingogallardo/spring-boot-demoapp.git La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona.","title":"Descarga de la aplicaci\u00f3n ejemplo"},{"location":"01-intro-spring-boot/intro-spring-boot.html#ejecucion-de-aplicaciones-spring-boot","text":"Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java: 1 2 $ mvn package $ java -jar target/clientesapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: 1 $ mvn spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito","title":"Ejecuci\u00f3n de aplicaciones Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#desarrollo-y-ejecucion-con-intellij","text":"Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para importar un proyecto Spring Boot en IntelliJ basta con importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File New Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ importa el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:","title":"Desarrollo y ejecuci\u00f3n con IntelliJ"},{"location":"01-intro-spring-boot/intro-spring-boot.html#conceptos-de-spring-boot","text":"","title":"Conceptos de Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#estructura-de-la-aplicacion","text":"Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId es.ua.mads /groupId artifactId demoapp /artifactId version 0.0.1-SNAPSHOT /version parent groupId org.springframework.boot /groupId artifactId spring-boot-starter-parent /artifactId version 2.1.6.RELEASE /version /parent dependencies dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-web /artifactId /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-thymeleaf /artifactId /dependency dependency groupId org.springframework.boot /groupId artifactId spring-boot-starter-test /artifactId scope test /scope /dependency /dependencies build plugins plugin groupId org.springframework.boot /groupId artifactId spring-boot-maven-plugin /artifactId /plugin /plugins /build /project En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties 1 spring.application.name = demoapp","title":"Estructura de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html#controladores","text":"Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { private final SaludoService service ; @Autowired public SaludoController ( SaludoService service ) { this . service = service ; } @RequestMapping ( /saludo/{nombre} ) public @ResponseBody String saludo ( @PathVariable ( value = nombre ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: 1 2 3 4 5 6 HTTP / 1 . 1 200 Content-Type : text / plain ; charset = UTF-8 Content-Length : 8 Date : Mon , 02 Sep 2019 14 : 59 : 04 GMT Hola Ana","title":"Controladores"},{"location":"01-intro-spring-boot/intro-spring-boot.html#clases-de-servicio","text":"Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java 1 2 3 4 5 6 7 8 9 10 package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return Hola + nombre ; } }","title":"Clases de Servicio"},{"location":"01-intro-spring-boot/intro-spring-boot.html#inyeccion-de-dependencias-en-spring","text":"Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. En este caso lo hacemos anotando el constructor. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable service que se pasa como par\u00e1metro al constructor. Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection","title":"Inyecci\u00f3n de dependencias en Spring"},{"location":"01-intro-spring-boot/intro-spring-boot.html#plantillas-thymeleaf","text":"La aplicaci\u00f3n devuelve p\u00e1ginas HTML, vistas que se construyen utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html 1 2 3 4 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org h1 th:text = Saludo: + ${mensaje} / h1 / html El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { private final SaludoService service ; @Autowired public SaludoControllerPlantilla ( SaludoService service ) { this . service = service ; } @RequestMapping ( /saludoplantilla/{nombre} ) public String saludo ( @PathVariable ( value = nombre ) String nombre , Model model ) { model . addAttribute ( mensaje , service . saluda ( nombre )); return saludo ; } }","title":"Plantillas Thymeleaf"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests","text":"En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: 1 $ mvn test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ.","title":"Tests"},{"location":"01-intro-spring-boot/intro-spring-boot.html#referencias","text":"Getting Started Guide Building an Application with Spring Boot Getting Started Guide Serving Web Content with Spring MVC Spring Boot Reference Guide 2.2.0.BUILD-SNAPSHOT ( HTML , PDF )","title":"Referencias"},{"location":"01-intro-spring-boot/practica0.html","text":"Pr\u00e1ctica 0 - Primera aplicaci\u00f3n con Spring Boot En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot. Tambi\u00e9n usaremos Git. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub. Instalaci\u00f3n de software Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows usaremos el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior Maven IntelliJ Ultimate Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Instalaci\u00f3n b\u00e1sica Linux Para instalar el software en Linux. Instalar Git, Java y Maven: 1 2 3 $ sudo apt install git $ sudo apt install default-jdk $ sudo apt install maven Instalar IntelliJ Ultimate macOS Git y Java vienen instalados con el sistema operativo. Recomendamos usar Homebrew para instalar Maven: 1 $ brew install maven Instalar IntelliJ Ultimate Windows Es recomendable instalar git for Windows , que adem\u00e1s de Git instala Git BASH, un terminal Bash integrado en Windows. Adem\u00e1s, hay que instalar Java, Maven e IntelliJ Ultimate . Despu\u00e9s de la instalaci\u00f3n b\u00e1sica Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: 1 2 $ git --version $ mvn --version ( imprime la versi\u00f3n de Maven y de Java ) Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero $HOME/.bashrc (linux y Git Bash Windows) o $HOME/.bash_profile (macOS) : 1 2 3 4 parse_git_branch() { git branch 2 /dev/null | sed -e /^[^*]/d -e s/* \\(.*\\)/ (\\1)/ } export PS1= \\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed . Repositorio GitHub Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. 1 2 $ git config --global user.name Pepe Perez $ git config --global user.email pepe.perez@example.com lt ; Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings Profile y actualizando el campo Name . Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio practica-0- usuario en la organizaci\u00f3n mads-ua . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Tambi\u00e9n el profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua . Documentaci\u00f3n a consultar Spring Boot es un framework ligero que permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Puedes encontrar la documentaci\u00f3n de referencia de estos dos frameworks en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . Para realizar la pr\u00e1ctica debes leer la Introducci\u00f3n a Spring Boot para las pr\u00e1cticas de MADS y las siguientes gu\u00edas: Building an Application with Spring Boot Serving Web Content with Spring MVC Validating Form Input Enunciado de la pr\u00e1ctica Haremos una primera pr\u00e1ctica sencilla en la que pondremos en marcha una aplicaci\u00f3n inicial en Spring Boot y a\u00f1adiremos alguna funcionalidad. Trabajamos con la aplicaci\u00f3n Demo de Spring Boot Debemos hacer lo siguiente: Descargar la aplicaci\u00f3n Demo de Spring Boot usando el comando git clone. Importarla en IntelliJ Probar que se pasan todos los tests usando Maven e IntelliJ Ejecutarla desde l\u00ednea de comando y desde IntelliJ Hacer alg\u00fan peque\u00f1o cambio A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n Debemos a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n que realice lo siguiente: Leer datos de un formulario usando Thymeleaf. Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Incluir al menos 2 tests: 1 de la capa de servicio 1 de la capa de presentaci\u00f3n usando MockMvc y moqueando el servicio Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Comandos Git Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en documento comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura. Entrega Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits conforme se van realizando. Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho mvn clean para eliminar los binarios compilados. Fecha l\u00edmite de entrega: 17 de septiembre (1 semana)","title":"Pr\u00e1ctica 0"},{"location":"01-intro-spring-boot/practica0.html#practica-0-primera-aplicacion-con-spring-boot","text":"En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot. Tambi\u00e9n usaremos Git. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub.","title":"Pr\u00e1ctica 0 - Primera aplicaci\u00f3n con Spring Boot"},{"location":"01-intro-spring-boot/practica0.html#instalacion-de-software","text":"Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows usaremos el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior Maven IntelliJ Ultimate Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.","title":"Instalaci\u00f3n de software"},{"location":"01-intro-spring-boot/practica0.html#instalacion-basica","text":"","title":"Instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica0.html#despues-de-la-instalacion-basica","text":"Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: 1 2 $ git --version $ mvn --version ( imprime la versi\u00f3n de Maven y de Java ) Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero $HOME/.bashrc (linux y Git Bash Windows) o $HOME/.bash_profile (macOS) : 1 2 3 4 parse_git_branch() { git branch 2 /dev/null | sed -e /^[^*]/d -e s/* \\(.*\\)/ (\\1)/ } export PS1= \\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed .","title":"Despu\u00e9s de la instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica0.html#repositorio-github","text":"Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. 1 2 $ git config --global user.name Pepe Perez $ git config --global user.email pepe.perez@example.com lt ; Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings Profile y actualizando el campo Name . Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio practica-0- usuario en la organizaci\u00f3n mads-ua . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Tambi\u00e9n el profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua .","title":"Repositorio GitHub"},{"location":"01-intro-spring-boot/practica0.html#documentacion-a-consultar","text":"Spring Boot es un framework ligero que permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Puedes encontrar la documentaci\u00f3n de referencia de estos dos frameworks en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . Para realizar la pr\u00e1ctica debes leer la Introducci\u00f3n a Spring Boot para las pr\u00e1cticas de MADS y las siguientes gu\u00edas: Building an Application with Spring Boot Serving Web Content with Spring MVC Validating Form Input","title":"Documentaci\u00f3n a consultar"},{"location":"01-intro-spring-boot/practica0.html#enunciado-de-la-practica","text":"Haremos una primera pr\u00e1ctica sencilla en la que pondremos en marcha una aplicaci\u00f3n inicial en Spring Boot y a\u00f1adiremos alguna funcionalidad.","title":"Enunciado de la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica0.html#trabajamos-con-la-aplicacion-demo-de-spring-boot","text":"Debemos hacer lo siguiente: Descargar la aplicaci\u00f3n Demo de Spring Boot usando el comando git clone. Importarla en IntelliJ Probar que se pasan todos los tests usando Maven e IntelliJ Ejecutarla desde l\u00ednea de comando y desde IntelliJ Hacer alg\u00fan peque\u00f1o cambio","title":"Trabajamos con la aplicaci\u00f3n Demo de Spring Boot"},{"location":"01-intro-spring-boot/practica0.html#anadimos-alguna-funcionalidad-sencilla-a-la-aplicacion","text":"Debemos a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n que realice lo siguiente: Leer datos de un formulario usando Thymeleaf. Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Incluir al menos 2 tests: 1 de la capa de servicio 1 de la capa de presentaci\u00f3n usando MockMvc y moqueando el servicio Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub.","title":"A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica0.html#comandos-git","text":"Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en documento comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura.","title":"Comandos Git"},{"location":"01-intro-spring-boot/practica0.html#entrega","text":"Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits conforme se van realizando. Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho mvn clean para eliminar los binarios compilados. Fecha l\u00edmite de entrega: 17 de septiembre (1 semana)","title":"Entrega"},{"location":"01-intro-spring-boot/practica1.html","text":"Enunciado pr\u00e1ctica 1 Objetivos En la primera pr\u00e1ctica de la asignatura vamos a tomar contacto con el framework de desarrollo de aplicaciones web en Java Spring Boot , trabajando sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Igual que en la pr\u00e1ctica 0, debes leer la introducci\u00f3n a Spring Boot para las pr\u00e1cticas de MADS para entender los conceptos fundamentales del framework. Aplicaci\u00f3n inicial La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los usuarios de la aplicaci\u00f3n. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List . Metodolog\u00eda de desarrollo En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues , labels , milestones , etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues , tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java. Git Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto. Flujo de trabajo Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama master haciendo un pull request . Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama master haciendo un pull request . Cuando se mezcle el PR en master el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues y pull requests de ese milestone ). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue o PR: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Important Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . Mientras que el tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues , en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Note Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack , Confluence o incluso Trello . Pero lo que nos ofrece GitHub es suficiente para lo que vamos a realizar en la asignatura y tiene la ventaja de estar integrado en una misma plataforma. La aplicaci\u00f3n ToDoList La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 0. Entre otros, tiene los siguientes elementos: Gestiona distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo y prueba. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos. Configuraci\u00f3n de la aplicaci\u00f3n Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : 1 2 3 4 5 6 7 spring . application . name = madstodolist spring . datasource . url = jdbc : h2 : mem : dev spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = update logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - dev . sql spring . datasource . initialization - mode = always Se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2) y el fichero que contiene los datos iniciales que se van a cargar en la base de datos al arrancar la aplicaci\u00f3n, el fichero datos-dev.sql . Tambi\u00e9n se define la caracter\u00edstica de JPA spring.jpa.hibernate.ddl-auto que define c\u00f3mo se debe inicializar el esquema de datos de la aplicaci\u00f3n cuando haya un cambio en el c\u00f3digo fuente que define las entidades. En este caso tenemos un valor de update para indicar que se el esquema de datos debe actualizarse. En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n. Otras configuraciones Es posible definir otras configuraciones e indicar en el comando de ejecuci\u00f3n de la aplicaci\u00f3n Spring Boot qu\u00e9 fichero de configuraci\u00f3n usar. Lo veremos en la pr\u00e1ctica 2. En esta pr\u00e1ctica se define otra configuraci\u00f3n en el directorio de test, que es la que se carga cuando se lanzan los tests: Fichero src/test/resources/application.properties : 1 2 3 4 5 6 spring . datasource . url = jdbc : h2 : mem : test spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = create logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - test . sql spring . datasource . initialization - mode = always La diferencia con el fichero de configuraci\u00f3n de desarrollo es el nombre de la fuente de datos, el modo del spring.jpa.hibernate.ddl-auto , que es create y el fichero de datos iniciales que se carga al ejecutar los tests. Gesti\u00f3n de persistencia con JPA Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate 5.3.10. Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades. Definici\u00f3n del modelo de datos El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario que se lista a continuaci\u00f3n define la tabla usuario en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia @GeneratedValue(strategy = GenerationType.IDENTITY) que define una columna que se autoincrementa en cada operaci\u00f3n de inserci\u00f3n de un nuevo registro en la tabla. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario, unos getters y setters y los m\u00e9todos equals y hashCode para comparar usuarios. Fichero src/main/java/madstodolist/model/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.Date ; import java.util.List ; import java.util.Objects ; @Entity @Table ( name = usuarios ) public class Usuario implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String email ; private String nombre ; private String password ; @Column ( name = fecha_nacimiento ) @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = usuario , fetch = FetchType . EAGER ) List Tarea tareas = new ArrayList Tarea (); // Constructor vac\u00edo necesario para JPA/Hibernate. // Lo hacemos privado para que no se pueda usar desde el c\u00f3digo de la aplicaci\u00f3n. Para crear un // usuario en la aplicaci\u00f3n habr\u00e1 que llamar al constructor p\u00fablico. Hibernate s\u00ed que lo puede usar, a pesar // de ser privado. private Usuario () {} // Constructor p\u00fablico con los atributos obligatorios. En este caso el correo electr\u00f3nico. public Usuario ( String email ) { this . email = email ; } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getNombre () { return nombre ; } public void setNombre ( String nombre ) { this . nombre = nombre ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public Date getFechaNacimiento () { return fechaNacimiento ; } public void setFechaNacimiento ( Date fechaNacimiento ) { this . fechaNacimiento = fechaNacimiento ; } public List Tarea getTareas () { return tareas ; } public void setTareas ( List Tarea tareas ) { this . tareas = tareas ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Usuario usuario = ( Usuario ) o ; if ( id != null usuario . id != null ) // Si tenemos los ID, comparamos por ID return Objects . equals ( id , usuario . id ); // sino comparamos por campos obligatorios return email . equals ( usuario . email ); } @Override public int hashCode () { // Generamos un hash basado en los campos obligatorios return Objects . hash ( email ); } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La definici\u00f3n de Tarea es la siguiente: Fichero src/main/java/madstodolist/model/Tarea.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.Objects ; @Entity @Table ( name = tareas ) public class Tarea implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String titulo ; @NotNull // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = usuario_id ) private Usuario usuario ; // Constructor vac\u00edo necesario para JPA/Hibernate. // Lo hacemos privado para que no se pueda usar desde el c\u00f3digo de la aplicaci\u00f3n. Para crear un // usuario en la aplicaci\u00f3n habr\u00e1 que llamar al constructor p\u00fablico. Hibernate s\u00ed que lo puede usar, a pesar // de ser privado. private Tarea () {} // Al crear una tarea la asociamos autom\u00e1ticamente a un // usuario. Actualizamos por tanto la lista de tareas del // usuario. public Tarea ( Usuario usuario , String titulo ) { this . usuario = usuario ; this . titulo = titulo ; usuario . getTareas (). add ( this ); } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getTitulo () { return titulo ; } public void setTitulo ( String titulo ) { this . titulo = titulo ; } public Usuario getUsuario () { return usuario ; } public void setUsuario ( Usuario usuario ) { this . usuario = usuario ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Tarea tarea = ( Tarea ) o ; return titulo . equals ( tarea . titulo ) usuario . equals ( tarea . usuario ); } @Override public int hashCode () { return Objects . hash ( titulo , usuario ); } } Recuperaci\u00f3n eager y lazy de las colecciones En la aplicaci\u00f3n se define la relaci\u00f3n uno-a-muchos entre usuarios y tareas: un usuario tiene muchas tareas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Entity public class Usuario { ... // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = usuario , fetch = FetchType . EAGER ) List Tarea tareas = new ArrayList Tarea (); ... } @Entity public class Tarea { ... // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = usuario_id ) private Usuario usuario ; ... } Relaciones lazy Por defecto, todas las relaciones a-muchos en JPA se definen de tipo LAZY . La caracter\u00edstica de los atributos marcados como lazy en JPA es que no se traen a memoria cuando se recupera la entidad, sino cuando se consultan. Pero para que se traigan a memoria la conexi\u00f3n con la base de datos debe estar abierta . Si ya se ha cerrado esa conexi\u00f3n (por ejemplo, se ha cerrado la transacci\u00f3n en el m\u00e9todo de servicio y se quiere acceder a la una lista de tareas de un usuario devuelto por el propio m\u00e9todo estando en el controller) se producir\u00e1 un error. Relaciones eager Frente a la recuperaci\u00f3n lazy de colecciones, tambi\u00e9n existe la posibilidad de definir una colecci\u00f3n como de tipo EAGER . En este caso JPA se traer\u00e1 siempre a memoria todos los elementos. Es el caso de la relaci\u00f3n entre un usuario y sus tareas. En general, no es conveniente definir una relaci\u00f3n como eager porque puede provocar problemas de rendimiento en el caso en que haya muchos elementos relacionados. Pero si no hay muchos datos en la relaci\u00f3n y los vamos a usar con frecuencia, s\u00ed que es aconsejable usar el tipo EAGER para facilitar el manejo de la entidad. Clases Repository Spring define la clase gen\u00e9rica CrudRepository que contienen m\u00e9todos por defecto para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. 1 2 3 4 5 6 7 8 9 public interface CrudRepository T , ID extends Serializable extends Repository T , ID { S extends T S save ( S entity ); Optional T findById ( ID primaryKey ); Iterable T findAll (); long count (); void delete ( T entity ); boolean existsById ( ID primaryKey ); // \u2026 more functionality omitted. } Para usar estos m\u00e9todos con nuestras entidades basta con definir interfaces que extienden esta clase gen\u00e9rica. Por ejemplo, la interfaz TareaRepository : Fichero src/main/java/madstodolist/model/TareaRepository.java : 1 2 3 4 5 package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; public interface TareaRepository extends CrudRepository Tarea , Long {} Una vez definida la interfaz, ya podemos inyectar una instancia de repository y usarla en las clases de servicio. Por ejemplo, mostramos el m\u00e9todo de servicio que modifica el t\u00edtulo de una tarea: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Service public class TareaService { private UsuarioRepository usuarioRepository ; private TareaRepository tareaRepository ; @Autowired public TareaService ( UsuarioRepository usuarioRepository , TareaRepository tareaRepository ) { this . usuarioRepository = usuarioRepository ; this . tareaRepository = tareaRepository ; } ... @Transactional public Tarea modificaTarea ( Long idTarea , String nuevoTitulo ) { Tarea tarea = tareaRepository . findById ( idTarea ). orElse ( null ); if ( tarea == null ) { throw new TareaServiceException ( No existe tarea con id + idTarea ); } tarea . setTitulo ( nuevoTitulo ); tareaRepository . save ( tarea ); return tarea ; } ... } La anotaci\u00f3n @Transactional hace que las acciones sobre la base de datos se ejecuten de forma transaccional. Se abre la transacci\u00f3n al del m\u00e9todo y se cierra al final. Si sucede alguna excepci\u00f3n durante su ejecuci\u00f3n la transacci\u00f3n se deshace. En el cuerpo del m\u00e9todo se llama al m\u00e9todo findById del repositorio que realiza una b\u00fasqueda en la base de datos y al m\u00e9todo save que actualiza el valor de la entidad. La interfaz UsuarioRepository es similar. Fichero src/main/java/madstodolist/model/UsuarioRepository.java : 1 2 3 4 5 6 7 8 9 package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; import java.util.Optional ; public interface UsuarioRepository extends CrudRepository Usuario , Long { Optional Usuario findByEmail ( String s ); } La diferencia es que se a\u00f1ade un m\u00e9todo findByEmail que hace que Spring construya autom\u00e1ticamente una consulta sobre la base de datos. Al usar como nombre del m\u00e9todo el nombre de la propiedad de la entidad ( email ), Spring puede generar autom\u00e1ticamente la consulta. Servicios La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Fichero src/main/java/madstodolist/service/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } private UsuarioRepository usuarioRepository ; @Autowired public UsuarioService ( UsuarioRepository usuarioRepository ) { this . usuarioRepository = usuarioRepository ; } @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional Usuario usuario = usuarioRepository . findByEmail ( eMail ); if (! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if (! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional Usuario usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( El usuario + usuario . getEmail () + ya est\u00e1 registrado ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( El usuario no tiene email ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( El usuario no tiene password ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Controllers Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 package madstodolist.controller ; import madstodolist.authentication.ManagerUserSesion ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import org.springframework.web.servlet.mvc.support.RedirectAttributes ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSesion managerUserSesion ; @GetMapping ( /login ) public String loginForm ( Model model ) { model . addAttribute ( loginData , new LoginData ()); return formLogin ; } @PostMapping ( /login ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , RedirectAttributes flash , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSesion . logearUsuario ( session , usuario . getId ()); return redirect:/usuarios/ + usuario . getId () + /tareas ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( error , No existe usuario ); return formLogin ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( error , Contrase\u00f1a incorrecta ); return formLogin ; } return formLogin ; } @GetMapping ( /registro ) public String registroForm ( Model model ) { model . addAttribute ( registroData , new RegistroData ()); return formRegistro ; } @PostMapping ( /registro ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return registroForm ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( registroData , registroData ); model . addAttribute ( error , El usuario + registroData . geteMail () + ya existe ); return formRegistro ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return redirect:/login ; } @GetMapping ( /logout ) public String logout ( HttpSession session ) { session . setAttribute ( idUsuarioLogeado , null ); return redirect:/login ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Peticiones y rutas Las rutas que se definen en los controllers para realizar las acciones de la aplicaci\u00f3n son: LoginController GET /login : devuelve el formulario de login POST /login : realiza el login GET /registro : devuelve el formulario de registro POST /registro : realiza el registro GET /logout : realiza la salida del usuario de la aplicaci\u00f3n TareaController GET /usuarios/{id}/tareas/nueva : devuelve el formulario para a\u00f1adir una tarea al usuario con identificador {id} POST /usuarios/{id}/tareas/nueva : a\u00f1ade una tarea nueva a un usuario GET /usuarios/{id}/tareas : devuelve el listado de tareas de un usuario GET /tareas/{id}/editar\" : devuelve el formulario para editar una tarea POST /tareas/{id}/editar : a\u00f1ade una tarea modificada DELETE /tareas/{id} : realiza el borrado de una tarea Vistas Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org head th:fragment = head (titulo) meta charset = UTF-8 / title th:text = ${titulo} / title link rel = stylesheet th:href = @{/css/bootstrap.min.css} / head div th:fragment = javascript script th:src = @{/js/jquery.min.js} / script script th:src = @{/js/popper.min.js.css} / script script th:src = @{/js/bootstrap.min.js} / script span th:text = ${scripts} / span / div /html Vemos que las vistas usan el framework CSS Bootstrap y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal es el listado de tareas. Fichero src/main/resources/templates/listaTareas.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org head th:replace = fragments :: head (titulo= Login ) / head body div class = container-fluid div class = row mt-3 div class = col h2 th:text = Listado de tareas de + ${usuario.nombre} / h2 / div / div div class = row mt-3 div class = col table class = table table-striped thead tr th Id / th th Tarea / th th Acci\u00f3n / th / tr / thead tbody tr th:each = tarea: ${tareas} td th:text = ${tarea.id} / td td th:text = ${tarea.titulo} / td td a class = btn btn-primary btn-xs th:href = @{/tareas/{id}/editar(id=${tarea.id})} / editar / a a class = btn btn-danger btn-xs href = # onmouseover = style = cursor: pointer; th:onclick = del(\\ /tareas/ + ${tarea.id} + \\ ) borrar / a / td / tr / tbody / table p a class = btn btn-primary th:href = @{/usuarios/{id}/tareas/nueva(id=${usuario.id})} Nueva tarea / a a class = btn btn-link href = /logout Salir / a / p / div / div div class = row mt-2 div class = col div class = alert alert-success alert-dismissible fade show role = alert th:if = ${!#strings.isEmpty(mensaje)} span th:text = ${mensaje} / span button type = button class = close data-dismiss = alert aria-label = Close span aria-hidden = true times; / span / button / div / div / div / div / div div th:replace = fragments::javascript / !-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea -- script type = text/javascript function del ( urlBorrar ) { if ( confirm ( \u00bfEst\u00e1s seguro/a de que quieres borrar la tarea? )) { $ . ajax ({ url : urlBorrar , type : DELETE , success : function ( results ) { //refresh the page location . reload (); } }); } } / script / body / html La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea. Autenticaci\u00f3n y control de acceso En la aplicaci\u00f3n se realiza una autenticaci\u00f3n y un control de acceso muy sencillo usando la sesi\u00f3n HTTP. Esta sesi\u00f3n se implementa en Spring Boot con una cookie que se pasa desde el navegador hasta el servidor en cada petici\u00f3n. El manejo de la sesi\u00f3n es muy sencillo: es un diccionario en el que podemos a\u00f1adir datos. En el servidor podemos obtener los datos de la sesi\u00f3n consultando el diccionario. La implementaci\u00f3n de la autenticaci\u00f3n y del control de acceso se realiza con en la clase ManagerUserSesion : Fichero src/main/java/madstodolist/authentication/ManagerUserSesion.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package madstodolist.authentication ; import org.springframework.stereotype.Component ; import javax.servlet.http.HttpSession ; @Component public class ManagerUserSesion { // A\u00f1adimos el id de usuario en la sesi\u00f3n HTTP para hacer // una autorizaci\u00f3n sencilla. En los m\u00e9todos de controllers // comprobamos si el id del usuario logeado coincide con el obtenido // desde la URL public void logearUsuario ( HttpSession session , Long idUsuario ) { session . setAttribute ( idUsuarioLogeado , idUsuario ); } // Si el usuario no est\u00e1 logeado se lanza una excepci\u00f3n public void comprobarUsuarioLogeado ( HttpSession session , Long idUsuario ) { Long idUsuarioLogeado = ( Long ) session . getAttribute ( idUsuarioLogeado ); if (! idUsuario . equals ( idUsuarioLogeado )) throw new UsuarioNoLogeadoException (); } } Se implementa como un componente Spring con la anotaci\u00f3n @Component , lo inyectamos en los controllers y lo mockeamos en los tests de los controllers. Pruebas manuales y autom\u00e1ticas Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/datos-dev.sql : 1 2 3 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( 1 , domingo@ua , Domingo Gallardo , 123 , 2001-02-10 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 1 , Lavar coche , 1 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 2 , Renovar DNI , 1 ); Para los tests autom\u00e1ticos se cargan los datos definidos en el fichero datos-tests.sql . Fichero src/test/resources/datos-test.sql : 1 2 3 4 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( 1 , ana.garcia@gmail.com , Ana Garc\u00eda , 12345678 , 2001-02-10 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 1 , Lavar coche , 1 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 2 , Renovar DNI , 1 ); Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : Tambi\u00e9n sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Y sobre las vistas: UsuarioWebTest.java TareaWebTest.java En los tests sobre repository se debe usar la anotaci\u00f3n @Transactional para definir el contexto transaccional en el que se realiza la llamada a las acciones sobre la base de datos. En los tests sobre las vistas se mockean los servicios para que devuelvan los datos que nos interesan. Hay que ser cuidadoso al hacer pruebas que afectan a la base de datos, porque podemos insertar o modificar datos que se comprueban en otros tests. Tenemos que tener cuidado en que cada test sea independiente de los dem\u00e1s. Antes de empezar la pr\u00e1ctica Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-2019- usuario en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la pr\u00e1ctica 0. Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Al igual que en la pr\u00e1ctica 0 es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Descarga el proyecto y comprueba que se compila y ejecuta correctamente: 1 2 3 $ git clone https://github.com/mads-ua/todolist-2019-usuario.git $ cd todolist-2019-usuario $ mvn spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: 1 2 spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: Crea un tablero Trello p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial . Desarrollo de la pr\u00e1ctica En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features : P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues , pull requests (con sus commits en los que se desarrolla paso a paso cada issue ) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0. Versi\u00f3n 1.0.1 La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de . Tablero Trello Utilizaremos el tablero Trello para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una tarjeta para cada caracter\u00edstica. Cada caracter\u00edstica deber\u00e1 tener un n\u00famero y un t\u00edtulo. A\u00f1ade la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de : Cuando empecemos a trabajar en la historia de usuario moveremos la tarjeta a En marcha y cuando la hayamos terminado de testear e integrar en la rama principal la moveremos a Terminadas . Tablero de GitHub Configura el tablero de GitHub, poniendo como nombre ToDoList y seleccionando como plantilla Automated kanban . Elimina las tarjetas en la columna To do y a\u00f1ade la columna In pull request entre In progress y Done . En las columnas deber\u00e1n aparecer los issues y pull requests del proyecto. GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. A continuaci\u00f3n mostramos la configuraci\u00f3n que usaremos: Deberemos mover manualmente las tarjetas en alg\u00fan caso, porque GitHub no podr\u00e1 detectar las condiciones. En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue ) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : Issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : Pull request creados. Cuando a\u00f1adimos el proyecto al pull request (en la p\u00e1gina del pull request ) GitHub lo coloca autom\u00e1ticamente en esta columna. Archivaremos el issue implementado por el pull request manualmente. Columna Done : Pull requests cerrados. GitHub lo detecta autom\u00e1ticamente. Issues A\u00f1ade las etiquetas que vamos a usar inicialmente. Crea el primer issue , correspondiente a la feature a desarrollar P\u00e1gina Acerca de . Crea el milestone 1.0.1. y a\u00f1ade el issue a \u00e9l. A\u00f1ade el issue al proyecto (desde la p\u00e1gina del issue ) y autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To do . Desarrollo Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama master . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y abriendo un terminal para trabajar con Git: En el terminal escribimos los comandos para crear la rama en la que desarrollaremos la feature y subirla: 1 2 (master) $ git checkout -b acerca-de (acerca-de) $ git push -u origin acerca-de Primer commit Hacemos un primer commit. Cambia en pom.xml el nombre del proyecto a mads-todolist- tu-nombre y la versi\u00f3n a 1.0.1-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.1 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: 1 2 3 4 5 (acerca-de) $ git status (comprobamos los ficheros que han cambiado) (acerca-de) $ git add pom.xml (acerca-de) $ git status (comprobamos que est\u00e1 listo para a\u00f1adirse en el commit) (acerca-de) $ git commit -m Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.1 (acerca-de) $ git push Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Segundo commit En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Acci\u00f3n en controller Vista A\u00f1ade los siguientes ficheros: **Controller HomeController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package madstodolist.controller ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.GetMapping ; @Controller public class HomeController { @GetMapping ( / ) public String home () { return redirect:/login ; } @GetMapping ( /about ) public String loginForm ( Model model ) { return about ; } } Vista about.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org head th:replace = fragments :: head (titulo= Login ) / head body div class = container-fluid div class = container-fluid h1 ToDo List / h1 ul li Desarrollada por Domingo Gallardo / li li Versi\u00f3n 1.0.0 (en desarrollo) / li li Fecha de release: pendiente de release / li / ul / div / div div th:replace = fragments::javascript / / body / html Prueba la p\u00e1gina accediendo a la url http://localhost:9000/about . Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : 1 2 3 4 (acerca-de) $ git add . (acerca-de) $ git status (comprueba que se han a\u00f1adido los ficheros) (acerca-de) $ git commit -m A\u00f1adida vista y controller about (acerca-de) $ git push Tercer commit En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero formLogin.html : 1 2 3 4 a class= btn btn-link href= /registro Ir a registro /a + a class= btn btn-link href= /about Acerca de /a + /div /form Prueba que funciona correctamente, haz el commit y s\u00fabelo a GitHub: 1 2 (acerca-de) $ git commit -am A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login (acerca-de) $ git push Pull request Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( master ). M\u00e1s adelante a\u00f1adiremos al pull request una comprobaci\u00f3n autom\u00e1tica de las pruebas y una revisi\u00f3n de c\u00f3digo por parte de compa\u00f1eros del equipo. Por ahora haremos nosotros ambas tareas. Vamos a verlo paso a paso. Empezamos por mezclar la rama de forma local con master , antes de hacer el pull request en GitHub, para probar que no se ha roto nada (todos los tests deben seguir pasando) y que los tests que hemos a\u00f1adido tambi\u00e9n funcionan correctamente (en este caso no hemos a\u00f1adido ninguno). En el terminal: 1 2 3 4 5 6 7 8 9 10 11 (acerca-de) $ git checkout master (master) $ git pull (bajamos cambios que se hayan subido master. En este caso no habr\u00e1 ninguno, pero lo habr\u00e1n cuando trabajemos en equipo) (master) $ git merge acerca-de Fast-forward pom.xml | 4 ++-- src/main/java/madstodolist/controller/HomeController.java | 20 ++++++++++++++++++++ src/main/resources/templates/about.html | 22 ++++++++++++++++++++++ src/main/resources/templates/formLogin.html | 2 ++ 4 files changed, 46 insertions(+), 2 deletions(-) Lanzamos los tests (lo podemos hacer en el terminal o en IntelliJ): 1 2 3 4 5 6 7 8 9 (master) $ mvn test ... [INFO] [INFO] Tests run: 31, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 21.879 s Una vez que hemos comprobado que todo funciona bien, deshacemos el merge que acabamos de realizar en la rama master , ya que actualizaremos despu\u00e9s la rama con el resultado del pull request en GitHub: 1 2 3 4 5 6 (master) $ git log --oneline --graph (muestra la historia de commits y las ramas) (master) $ git reset --hard origin/master HEAD is now at 51ebf62 Initial commit (master) $ git checkout acerca-de Switched to branch acerca-de Your branch is up to date with origin/acerca-de . Ya podemos crear el pull request en GitHub. Accede a la rama y comprueba que est\u00e1n todos los cambios pulsando Compare . Aparecer\u00e1 la siguiente p\u00e1gina, con la informaci\u00f3n de los cambios que introducen todos los commits de la rama: Pulsa despu\u00e9s el bot\u00f3n Create pull request para crear el pull request . Introduce el nombre del pull request , el comentario, el milestone , la etiqueta y el proyecto. En el comentario escribe 1 Closes #1 De esta forma, cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue . El n\u00famero #1 lo convierte GitHub en un enlace al issue correspondiente. De esta forma podemos examinar el issue resuelto por el PR. En el proyecto el pull request se colocar\u00e1 autom\u00e1ticamente la columna In pull request . Entra en el proyecto y archiva la tarjeta con el issue , ya que la actividad de desarrollar la feature queda representada por el pull request . En este momento se deber\u00eda hacer una revisi\u00f3n del c\u00f3digo del pull request y comprobar de forma autom\u00e1tica que la integraci\u00f3n con master no introduce errores en los tests. Lo haremos en siguientes pr\u00e1cticas. GitHub informa de que no hay conflictos con la rama master y que es posible hacer el merge. Pulsa el bot\u00f3n de Merge y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Este merge lo has hecho en GitHub. Debes por \u00faltimo integrarlo en tu repositorio local. En el terminal: 1 2 3 4 5 6 7 8 9 10 11 12 (acerca-de) $ git checkout master (master) $ git pull (bajamos los cambios) (master) $ git branch -d acerca-de (borramos la rama) (master) $ git remote prune origin (borramos referencias a rama remota) (master) $ git log --oneline --graph --all * 9527ae2 (HEAD - master, origin/master, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login | * 3fdfb83 A\u00f1adida ruta, vista y controller about | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request . De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. En el tablero de proyecto debe haber cambiado la tarjeta con el PR a la columna Done . Actualizamos tablero Trello Actualizamos el tablero Trello moviendo la historia de usuario a la columna Terminadas . Versi\u00f3n 1.0.1 Por \u00faltimo creamos el release 1.0.1. Haremos un commit directamente sobre la rama master (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release , cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros pom.xml y about.html Fichero pom.xml : 1 2 3 4 groupId es.ua.mads /groupId artifactId mads-todolist-dgallardo /artifactId - version 1.0.1-SNAPSHOT /version + version 1.0.1 /version Fichero about.html : 1 2 3 4 5 6 7 8 9 10 11 h1 ToDo List /h1 ul h1 ToDo List /h1 ul li Desarrollada por Domingo Gallardo /li - li Versi\u00f3n 1.0.1 (en desarrollo) /li - li Fecha de release: pendiente de release /li + li Versi\u00f3n 1.0.1 /li + li Fecha de release: 17/9/2018 /li /ul } A\u00f1adimos el commit y lo subimos a GitHub 1 2 3 (master) $ git add . (master) $ git commit -m Cambio de versi\u00f3n a 1.0.1 (master) $ git push Y, por \u00faltimo, creamos la versi\u00f3n 1.0.1 en GitHub pulsando en el enlace release en la p\u00e1gina principal (pesta\u00f1a Code ). Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. Tambi\u00e9n a\u00f1adiremos enlaces a la p\u00e1gina de la Wiki en la que se describe la caracter\u00edstica. El resultado ser\u00e1: Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0) El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. En alguna de las caracter\u00edsticas deber\u00e1s tambi\u00e9n realizar alg\u00fan test de la vista. Barra de men\u00fa La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login y registro. La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar . de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n nombre usuario : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login. Listado de usuarios Si se introduce la URL /usuarios aparecer\u00e1 un listado de los usuarios registrados (identificador y correo electr\u00f3nico). Descripci\u00f3n de usuario En la lista de usuarios habr\u00e1 un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un usuario aparecer\u00e1n todos sus datos, menos la contrase\u00f1a. La ruta para obtener la descripci\u00f3n de un usuario ser\u00e1 /usuarios/:id . Usuario administrador (opcional) Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador acceder\u00e1 directamente a la lista de usuarios. Protecci\u00f3n de listado de usuario y descripci\u00f3n de usuario (opcional) Proteger las p\u00e1ginas con el listado de usuarios y la descripci\u00f3n de usuario para que s\u00f3lo las pueda consultar el administrador. Bloqueo de usuarios por usuario administrador (opcional) A\u00f1adir en el listado de usuarios un bot\u00f3n para que el administrador pueda bloquear o habilitar el acceso a cada uno de los usuarios. Si el usuario tiene bloqueado el acceso cuando intente logearse aparecer\u00e1 un mensaje de error indic\u00e1ndoselo. Documentaci\u00f3n, entrega y evaluaci\u00f3n No es necesario, pero si quieres resaltar o documentar alguna cosa que hayas hecho en la pr\u00e1ctica puedes crear la p\u00e1gina /doc/practica1.md y escribir la documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 15 de octubre. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Pr\u00e1ctica 1"},{"location":"01-intro-spring-boot/practica1.html#enunciado-practica-1","text":"","title":"Enunciado pr\u00e1ctica 1"},{"location":"01-intro-spring-boot/practica1.html#objetivos","text":"En la primera pr\u00e1ctica de la asignatura vamos a tomar contacto con el framework de desarrollo de aplicaciones web en Java Spring Boot , trabajando sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Igual que en la pr\u00e1ctica 0, debes leer la introducci\u00f3n a Spring Boot para las pr\u00e1cticas de MADS para entender los conceptos fundamentales del framework.","title":"Objetivos"},{"location":"01-intro-spring-boot/practica1.html#aplicacion-inicial","text":"La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los usuarios de la aplicaci\u00f3n. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List .","title":"Aplicaci\u00f3n inicial"},{"location":"01-intro-spring-boot/practica1.html#metodologia-de-desarrollo","text":"En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues , labels , milestones , etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues , tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java.","title":"Metodolog\u00eda de desarrollo"},{"location":"01-intro-spring-boot/practica1.html#git","text":"Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto.","title":"Git"},{"location":"01-intro-spring-boot/practica1.html#flujo-de-trabajo","text":"Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama master haciendo un pull request . Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama master haciendo un pull request . Cuando se mezcle el PR en master el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues y pull requests de ese milestone ). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue o PR: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Important Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . Mientras que el tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues , en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Note Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack , Confluence o incluso Trello . Pero lo que nos ofrece GitHub es suficiente para lo que vamos a realizar en la asignatura y tiene la ventaja de estar integrado en una misma plataforma.","title":"Flujo de trabajo"},{"location":"01-intro-spring-boot/practica1.html#la-aplicacion-todolist","text":"La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 0. Entre otros, tiene los siguientes elementos: Gestiona distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo y prueba. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos.","title":"La aplicaci\u00f3n ToDoList"},{"location":"01-intro-spring-boot/practica1.html#configuracion-de-la-aplicacion","text":"Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : 1 2 3 4 5 6 7 spring . application . name = madstodolist spring . datasource . url = jdbc : h2 : mem : dev spring . jpa . properties . hibernate . dialect = org . hibernate . dialect . H2Dialect spring . jpa . hibernate . ddl - auto = update logging . level . org . hibernate . SQL = debug spring . datasource . data = classpath : datos - dev . sql spring . datasource . initialization - mode = always Se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2) y el fichero que contiene los datos iniciales que se van a cargar en la base de datos al arrancar la aplicaci\u00f3n, el fichero datos-dev.sql . Tambi\u00e9n se define la caracter\u00edstica de JPA spring.jpa.hibernate.ddl-auto que define c\u00f3mo se debe inicializar el esquema de datos de la aplicaci\u00f3n cuando haya un cambio en el c\u00f3digo fuente que define las entidades. En este caso tenemos un valor de update para indicar que se el esquema de datos debe actualizarse. En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#gestion-de-persistencia-con-jpa","text":"Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate 5.3.10. Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades.","title":"Gesti\u00f3n de persistencia con JPA"},{"location":"01-intro-spring-boot/practica1.html#servicios","text":"La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Fichero src/main/java/madstodolist/service/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } private UsuarioRepository usuarioRepository ; @Autowired public UsuarioService ( UsuarioRepository usuarioRepository ) { this . usuarioRepository = usuarioRepository ; } @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional Usuario usuario = usuarioRepository . findByEmail ( eMail ); if (! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if (! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional Usuario usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( El usuario + usuario . getEmail () + ya est\u00e1 registrado ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( El usuario no tiene email ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( El usuario no tiene password ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } }","title":"Servicios"},{"location":"01-intro-spring-boot/practica1.html#controllers","text":"Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 package madstodolist.controller ; import madstodolist.authentication.ManagerUserSesion ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import org.springframework.web.servlet.mvc.support.RedirectAttributes ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSesion managerUserSesion ; @GetMapping ( /login ) public String loginForm ( Model model ) { model . addAttribute ( loginData , new LoginData ()); return formLogin ; } @PostMapping ( /login ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , RedirectAttributes flash , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSesion . logearUsuario ( session , usuario . getId ()); return redirect:/usuarios/ + usuario . getId () + /tareas ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( error , No existe usuario ); return formLogin ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( error , Contrase\u00f1a incorrecta ); return formLogin ; } return formLogin ; } @GetMapping ( /registro ) public String registroForm ( Model model ) { model . addAttribute ( registroData , new RegistroData ()); return formRegistro ; } @PostMapping ( /registro ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return registroForm ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( registroData , registroData ); model . addAttribute ( error , El usuario + registroData . geteMail () + ya existe ); return formRegistro ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return redirect:/login ; } @GetMapping ( /logout ) public String logout ( HttpSession session ) { session . setAttribute ( idUsuarioLogeado , null ); return redirect:/login ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } }","title":"Controllers"},{"location":"01-intro-spring-boot/practica1.html#vistas","text":"Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org head th:fragment = head (titulo) meta charset = UTF-8 / title th:text = ${titulo} / title link rel = stylesheet th:href = @{/css/bootstrap.min.css} / head div th:fragment = javascript script th:src = @{/js/jquery.min.js} / script script th:src = @{/js/popper.min.js.css} / script script th:src = @{/js/bootstrap.min.js} / script span th:text = ${scripts} / span / div /html Vemos que las vistas usan el framework CSS Bootstrap y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal es el listado de tareas. Fichero src/main/resources/templates/listaTareas.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 !DOCTYPE html html xmlns:th = http://www.thymeleaf.org head th:replace = fragments :: head (titulo= Login ) / head body div class = container-fluid div class = row mt-3 div class = col h2 th:text = Listado de tareas de + ${usuario.nombre} / h2 / div / div div class = row mt-3 div class = col table class = table table-striped thead tr th Id / th th Tarea / th th Acci\u00f3n / th / tr / thead tbody tr th:each = tarea: ${tareas} td th:text = ${tarea.id} / td td th:text = ${tarea.titulo} / td td a class = btn btn-primary btn-xs th:href = @{/tareas/{id}/editar(id=${tarea.id})} / editar / a a class = btn btn-danger btn-xs href = # onmouseover = style = cursor: pointer; th:onclick = del(\\ /tareas/ + ${tarea.id} + \\ ) borrar / a / td / tr / tbody / table p a class = btn btn-primary th:href = @{/usuarios/{id}/tareas/nueva(id=${usuario.id})} Nueva tarea / a a class = btn btn-link href = /logout Salir / a / p / div / div div class = row mt-2 div class = col div class = alert alert-success alert-dismissible fade show role = alert th:if = ${!#strings.isEmpty(mensaje)} span th:text = ${mensaje} / span button type = button class = close data-dismiss = alert aria-label = Close span aria-hidden = true times; / span / button / div / div / div / div / div div th:replace = fragments::javascript / !-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea -- script type = text/javascript function del ( urlBorrar ) { if ( confirm ( \u00bfEst\u00e1s seguro/a de que quieres borrar la tarea? )) { $ . ajax ({ url : urlBorrar , type : DELETE , success : function ( results ) { //refresh the page location . reload (); } }); } } / script / body / html La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea.","title":"Vistas"},{"location":"01-intro-spring-boot/practica1.html#pruebas-manuales-y-automaticas","text":"Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/datos-dev.sql : 1 2 3 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( 1 , domingo@ua , Domingo Gallardo , 123 , 2001-02-10 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 1 , Lavar coche , 1 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 2 , Renovar DNI , 1 ); Para los tests autom\u00e1ticos se cargan los datos definidos en el fichero datos-tests.sql . Fichero src/test/resources/datos-test.sql : 1 2 3 4 INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( 1 , ana.garcia@gmail.com , Ana Garc\u00eda , 12345678 , 2001-02-10 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 1 , Lavar coche , 1 ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( 2 , Renovar DNI , 1 ); Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : Tambi\u00e9n sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Y sobre las vistas: UsuarioWebTest.java TareaWebTest.java En los tests sobre repository se debe usar la anotaci\u00f3n @Transactional para definir el contexto transaccional en el que se realiza la llamada a las acciones sobre la base de datos. En los tests sobre las vistas se mockean los servicios para que devuelvan los datos que nos interesan. Hay que ser cuidadoso al hacer pruebas que afectan a la base de datos, porque podemos insertar o modificar datos que se comprueban en otros tests. Tenemos que tener cuidado en que cada test sea independiente de los dem\u00e1s.","title":"Pruebas manuales y autom\u00e1ticas"},{"location":"01-intro-spring-boot/practica1.html#antes-de-empezar-la-practica","text":"Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-2019- usuario en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la pr\u00e1ctica 0. Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Al igual que en la pr\u00e1ctica 0 es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Descarga el proyecto y comprueba que se compila y ejecuta correctamente: 1 2 3 $ git clone https://github.com/mads-ua/todolist-2019-usuario.git $ cd todolist-2019-usuario $ mvn spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: 1 2 spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: Crea un tablero Trello p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial .","title":"Antes de empezar la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#desarrollo-de-la-practica","text":"En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features : P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues , pull requests (con sus commits en los que se desarrolla paso a paso cada issue ) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.","title":"Desarrollo de la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#version-101","text":"La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de .","title":"Versi\u00f3n 1.0.1"},{"location":"01-intro-spring-boot/practica1.html#resto-de-la-practica-version-110","text":"El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. En alguna de las caracter\u00edsticas deber\u00e1s tambi\u00e9n realizar alg\u00fan test de la vista.","title":"Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0)"},{"location":"01-intro-spring-boot/practica1.html#documentacion-entrega-y-evaluacion","text":"No es necesario, pero si quieres resaltar o documentar alguna cosa que hayas hecho en la pr\u00e1ctica puedes crear la p\u00e1gina /doc/practica1.md y escribir la documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 15 de octubre. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"01-introduccion-play/comandos-git.html","text":"Resumen de comandos Git Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi). Comandos b\u00e1sicos Configurar el usuario y direcci\u00f3n de correo en git: 1 2 $ git config --global user.name John Doe $ git config --global user.email johndoe@example.com Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name lt ; nombre-usuario gt ; $ git config --global user.email lt ; email gt ; $ git init $ git add . $ git commit -m Versi\u00f3n inicial Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin https://github.com/ lt ; usuario gt ; / lt ; nombre-repo gt ; .git $ git push -u origin master El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama master (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add lt ; fichero o directorio gt ; El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m Mensaje Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD lt ; fichero gt ; Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m Mensaje Se puede abreviar como 1 $ git commit -am Mensaje ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd ( si se ha a\u00f1adido alg\u00fan fichero ) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [ --oneline ] [ --graph ] [ --all ] Comprobar las diferencias entre dos commits: 1 $ git diff lt ; hash-previo gt ; lt ; hash-nuevo gt ; Devuelve las cambios que se han introducido desde el commit identificado por y hasta el . Ramas Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt ( si hay cambios en el espacio de trabajo se llevan a la nueva rama ) Switched to a new branch nueva-rama Listar las ramas de un repositorio: 1 2 3 4 $ git branch master * nueva-rama $ git commit -a -m Confirmamos los cambios en la nueva rama Moverse a otra rama: 1 2 $ git checkout master Switched to branch master Mostrar un fichero de una rama (o commit) dado: 1 $ git show lt ; commit o rama gt ; : lt ; nombre-fichero gt ; Comparar dos ramas: 1 $ git diff master nueva-rama El comando git diff master nueva-rama devuelve las diferencias entre las ramas master y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama master . Merge de ramas : Mezclar la rama nueva-rama en la rama master (a\u00f1ade a la master los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout master $ git merge [ --no-ff ] nueva-rama -m Mensaje de commit La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT ( content ) : Merge conflict in hola.txt Automatic merge failed ; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m Arreglado el conflicto en el merge $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama master ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m Cambios en experiment $ git checkout master # hacemos cambios $ git commit -a -m Cambios en master $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama master ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama master y tener una historia lineal: 1 2 3 4 $ git checkout master $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase master CONFLICT ( content ) : Merge conflict in lt ; some-file gt ; # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use git reset HEAD lt;some-file gt;... to unstage) # (use git add/rm lt;some-file gt;... as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add lt ; some-file gt ; $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama ( was c241d7b ) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin lt ; rama gt ; Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b lt ; rama gt ; origin/ lt ; rama gt ; Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete lt ; branchName gt ; Modificar la historia Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [ --m Nuevo mensaje ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout lt ; hash gt ; ( o tag, por ejemplo v2.0 ) You are in detached HEAD state. # Ahora est\u00e1s en un detached HEAD $ git branch * ( HEAD detached at 594b606 ) master $ git checkout -b v2.0.1 Switched to a new branch v2.0.1 $ git branch master * v2.0.1 $ git checkout master Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard lt ; hash gt ; M\u00e1s informaci\u00f3n Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"Comandos git"},{"location":"01-introduccion-play/comandos-git.html#resumen-de-comandos-git","text":"Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).","title":"Resumen de comandos Git"},{"location":"01-introduccion-play/comandos-git.html#comandos-basicos","text":"Configurar el usuario y direcci\u00f3n de correo en git: 1 2 $ git config --global user.name John Doe $ git config --global user.email johndoe@example.com Inicializar git en un directorio: 1 2 3 4 5 6 $ cd /ruta/a/mi/directorio $ git config --global user.name lt ; nombre-usuario gt ; $ git config --global user.email lt ; email gt ; $ git init $ git add . $ git commit -m Versi\u00f3n inicial Publicar por primera vez el repositorio local en el remoto (en GitHub): 1 2 $ git remote add origin https://github.com/ lt ; usuario gt ; / lt ; nombre-repo gt ; .git $ git push -u origin master El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama master (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: 1 $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: 1 $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): 1 $ git add lt ; fichero o directorio gt ; El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : 1 $ git commit -m Mensaje Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): 1 $ git reset HEAD lt ; fichero gt ; Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: 1 $ git commit -a -m Mensaje Se puede abreviar como 1 $ git commit -am Mensaje ` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: 1 2 $ git reset --hard HEAD $ git clean -fd ( si se ha a\u00f1adido alg\u00fan fichero ) Publicar los cambios en el repositorio remoto: 1 $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). 1 $ git log [ --oneline ] [ --graph ] [ --all ] Comprobar las diferencias entre dos commits: 1 $ git diff lt ; hash-previo gt ; lt ; hash-nuevo gt ; Devuelve las cambios que se han introducido desde el commit identificado por y hasta el .","title":"Comandos b\u00e1sicos"},{"location":"01-introduccion-play/comandos-git.html#ramas","text":"Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: 1 2 3 $ git checkout -b nueva-rama M hola.txt ( si hay cambios en el espacio de trabajo se llevan a la nueva rama ) Switched to a new branch nueva-rama Listar las ramas de un repositorio: 1 2 3 4 $ git branch master * nueva-rama $ git commit -a -m Confirmamos los cambios en la nueva rama Moverse a otra rama: 1 2 $ git checkout master Switched to branch master Mostrar un fichero de una rama (o commit) dado: 1 $ git show lt ; commit o rama gt ; : lt ; nombre-fichero gt ; Comparar dos ramas: 1 $ git diff master nueva-rama El comando git diff master nueva-rama devuelve las diferencias entre las ramas master y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama master . Merge de ramas : Mezclar la rama nueva-rama en la rama master (a\u00f1ade a la master los commits adicionales de la rama nueva-rama ): 1 2 $ git checkout master $ git merge [ --no-ff ] nueva-rama -m Mensaje de commit La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. 1 2 3 4 5 6 $ git merge nueva-rama CONFLICT ( content ) : Merge conflict in hola.txt Automatic merge failed ; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m Arreglado el conflicto en el merge $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama master ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git checkout -b experiment # hacemos cambios $ git commit -m Cambios en experiment $ git checkout master # hacemos cambios $ git commit -a -m Cambios en master $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama master ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. IMPORTANTE : No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama master y tener una historia lineal: 1 2 3 4 $ git checkout master $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : 1 2 3 4 5 6 7 8 9 10 11 $ git rebase master CONFLICT ( content ) : Merge conflict in lt ; some-file gt ; # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use git reset HEAD lt;some-file gt;... to unstage) # (use git add/rm lt;some-file gt;... as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add lt ; some-file gt ; $ git rebase --continue IMPORTANTE : Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: 1 $ git log --graph --oneline Borrar una rama: 1 2 $ git branch -d nueva-rama Deleted branch nueva-rama ( was c241d7b ) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: 1 $ git branch -D rama Subir una rama al repositorio remoto: 1 $ git push -u origin lt ; rama gt ; Para no tener que escribir la contrase\u00f1a del repositorio remoto cada vez puedes utilizar el siguiente comando que la guarda en una cach\u00e9: 1 $ git config --global credential.helper cache. Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) 1 2 $ git fetch $ git checkout -b lt ; rama gt ; origin/ lt ; rama gt ; Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) 1 $ git remote show origin Subir todas las ramas y etiquetas: 1 $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: 1 $ git push origin --delete lt ; branchName gt ;","title":"Ramas"},{"location":"01-introduccion-play/comandos-git.html#modificar-la-historia","text":"Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: 1 $ git commit --amend [ --m Nuevo mensaje ] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): 1 $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: 1 $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: 1 2 3 4 5 6 7 8 9 10 11 12 $ git checkout lt ; hash gt ; ( o tag, por ejemplo v2.0 ) You are in detached HEAD state. # Ahora est\u00e1s en un detached HEAD $ git branch * ( HEAD detached at 594b606 ) master $ git checkout -b v2.0.1 Switched to a new branch v2.0.1 $ git branch master * v2.0.1 $ git checkout master Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) 1 $ git reset --hard lt ; hash gt ;","title":"Modificar la historia"},{"location":"01-introduccion-play/comandos-git.html#mas-informacion","text":"Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"M\u00e1s informaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria.html","text":"Introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS Vamos a ver c\u00f3mo lanzar y desarrollar una aplicaci\u00f3n Play Framework en Java. Presentaremos las principales caracter\u00edsticas de este framework de desarrollo de aplicaciones web mediante ejemplos concretos de c\u00f3digo que vamos a utilizar en las pr\u00e1cticas de la asignatura. Aplicaci\u00f3n play-proyecto-inicial Descarga de la aplicaci\u00f3n La aplicaci\u00f3n play-proyecto-inicial se encuentra en GitHub: https://github.com/domingogallardo/play-proyecto-inicial . Es un esqueleto de aplicaci\u00f3n Play con ejemplos b\u00e1sicos del funcionamiento del framework. Puedes descargarla usando el comando git clone : 1 $ git clone https://github.com/domingogallardo/play-proyecto-inicial.git Se crear\u00e1 el directorio play-proyecto-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n Play. Uso de IntelliJ para trabajar con la aplicaci\u00f3n Play Aunque es posible trabajar con editores como Visual Studio Code , vamos a explicar c\u00f3mo desarrollar las aplicaciones Play usando el IDE IntelliJ IDEA. Las aplicaciones Play se pueden escribir en Java y en Scala. Nosotros usaremos Java. Una parte importante de las librer\u00edas del framework est\u00e1n escritas en Scala, por lo que debe estar instalado el plugin de Scala en IntelliJ. Se debe importar el proyecto usando la opci\u00f3n sbt , la herramienta de build que usa Play. Sbt es una herramienta similar a Maven para Java, es la herramienta que se usa para construir proyectos Scala. El fichero de configuraci\u00f3n de un proyecto sbt es el fichero build.sbt situado en el directorio ra\u00edz. Para compilar los proyectos tambi\u00e9n es necesario tener instalado JDK. Nos aseguramos de que aparece en el panel de importaci\u00f3n. Si no, seleccionamos el directorio donde se encuentra la versi\u00f3n del JDK que vamos a utilizar. Es conveniente activar la auto-importaci\u00f3n del proyecto sbt. De esta forma, si IntelliJ detecta alg\u00fan cambio en la configuraci\u00f3n sbt realiza la importaci\u00f3n de forma autom\u00e1tica. Si se pincha en el icono de la esquina inferior izquierda de la ventana de IntelliJ podremos activar o desactivar la visualizaci\u00f3n de los nombres de los paneles en los bordes de la ventana. Es recomendable dejarlos visibles. Utilizaremos el panel Terminal para trabajar con sbt y con git . Es recomendable abrir dos tabs, uno para cada cosa. Uso de Visual Studio Code para trabajar con la aplicaci\u00f3n Play Si no es posible utilizar un editor avanzado como IntelliJ es posible usar en su lugar Visual Studio Code . Abre la carpeta con el directorio del proyecto y abre un terminal con la opci\u00f3n Ver Terminal integrado . En ese terminal lanzaremos el comando Docker para trabajar con sbt . Puedes abrir otro terminal pulsando en el s\u00edmbolo + para trabajar con Git. Lanzar la aplicaci\u00f3n Play Podemos ejecutar la aplicaci\u00f3n Play de tres formas. Utilizaremos las tres a lo largo de las pr\u00e1cticas. Usando una m\u00e1quina Docker. Usando el sbt shell que proporciona IntelliJ. Usando la configuraci\u00f3n de ejecuci\u00f3n de IntelliJ. M\u00e1quina Docker La m\u00e1quina docker domingogallardo/playframework contiene todo el software y librer\u00edas para ejecutar aplicaciones Play 2.5.18. La ventaja de utilizar la m\u00e1quina Docker es que Una vez descargada la m\u00e1quina ya no es necesario descargar librer\u00edas adicionales. Est\u00e1 instalada en los laboratorios de la EPS. Nos movemos al directorio de la aplicaci\u00f3n Play y desde el terminal lanzamos el comando docker run para ejecutar la m\u00e1quina sobre el directorio actual conectando el puerto 9000 en el mismo puerto de nuestra m\u00e1quina: 1 2 3 $ cd play-proyecto-inicial $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [play-java] $ Aparecer\u00e1 el prompt de sbt con el nombre del proyecto. Podremos lanzar comandos de sbt como run o test . Haciendo run se ejecuta la aplicaci\u00f3n web. Por defecto el puerto al que hay que atacar es el 9000. Accediendo a la URL http://localhost:9000 pondremos en marcha la aplicaci\u00f3n. Haciendo test se lanzan los tests incluidos en la aplicaci\u00f3n. Con exit se sale del prompt de sbt y autom\u00e1ticamente se para el contenedor y se elimina el contenedor de Docker. Shell sbt de IntelliJ Tambi\u00e9n es posible arrancar el shell de sbt en un panel propio que proporciona IntelliJ. Cuando lo ejecutamos por primera vez se descargan todas las librer\u00edas necesarias. Configuraci\u00f3n de ejecuci\u00f3n de IntelliJ Tambi\u00e9n podemos crear una configuraci\u00f3n de ejecuci\u00f3n de IntelliJ con la que podremos ejecutar y depurar los proyectos con la opci\u00f3n Run Edit Configurations.. . Una vez creada la configuraci\u00f3n podremos seleccionarla y realizar una ejecuci\u00f3n o una depuraci\u00f3n de la aplicaci\u00f3n pulsando los botones correspondientes en la parte superior de la ventana de IntelliJ. Fichero routes El routes , situado en el directorio conf , especifica el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Fichero conf/routes : 1 2 3 4 5 6 7 8 9 10 11 12 13 # Routes # This file defines all application routes (Higher priority routes first) # ~~~~ # An example controller showing a sample home page GET / controllers.HomeController.index # An example controller showing how to use dependency injection GET /count controllers.CountController.count # An example controller showing how to write asynchronous code GET /message controllers.AsyncController.message # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Por ejemplo, cuando se recibe la petici\u00f3n GET / (cuando en el navegador escribimos la URL http::/localhost/ ) se ejecutar\u00e1 el m\u00e9todo index de la clase controllers.HomeController . O cuando desde el navegador accedamos a la URL http://localhost/count se generar\u00e1 la petici\u00f3n GET /count y se ejecutar\u00e1 el m\u00e9todo count de la clase controllers.CountController . Controllers El c\u00f3digo a ejecutar cuando se realiza una petici\u00f3n HTTP se define en m\u00e9todos de clases que heredan de Controller . Se suelen colocar en el paquete controllers . Por ejemplo, en la clase controllers.HomeController se define el m\u00e9todo index . Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public class HomeController extends Controller { /** * An action that renders an HTML page with a welcome message. * The configuration in the code routes /code file means that * this method will be called when the application receives a * code GET /code request with a path of code / /code . */ public Result index () { return ok ( index . render ( Your new application is ready. )); } } Los m\u00e9todos de las clases Controller deben devolver un objeto Result que representa la respuesta HTTP a la petici\u00f3n. En el caso anterior se devuelve un OK (c\u00f3digo HTTP 200) junto con el c\u00f3digo HTML resultante de renderizar la vista index . Vistas Las p\u00e1ginas HTML que se devuelven se construyen mediante vistas . Las vistas se definen mediante plantillas Scala definidas en el directorio views . En la llamada a renderizar la vista se pueden pasar par\u00e1metros cuyos valores se utilizan en la propia vista. Por ejemplo, la vista anterior index se define en el fichero index.scala.html situado en el directorio views . Fichero views/index.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @* * This template takes a single argument, a String containing a * message to display. *@ @(message: String) @* * Call the `main` template with two arguments. The first * argument is a `String` with the title of the page, the second * argument is an `Html` object containing the body of the page. *@ @main( Welcome to Play ) { @* * Get an `Html` object by calling the built-in Play welcome * template and passing a `String` message. *@ @welcome(message, style = java ) } La vista recibe un par\u00e1metro String . En el cuerpo de la vista se puede escribir c\u00f3digo HTML, c\u00f3digo Scala, y tambi\u00e9n llamar a otras plantillas. Por ejemplo, en la vista anterior se llama a la plantilla main que se define en el fichero main.scala.html , pas\u00e1ndole como par\u00e1metro el c\u00f3digo HTML generado por la plantilla welcome , definida en el fichero welcome.scala.html . Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String)(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body @* And here s where we render the `Html` object containing * the page content. *@ @content / body / html Fichero views/welcome.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @(message: String, style: String = java ) @defining(play.core.PlayVersion.current) { version = link rel = stylesheet media = screen href = /@@documentation/resources/style/main.css section id = top div class = wrapper h1 a href = https://playframework.com/documentation/@version/Home @message / a / h1 / div / section div id = content class = wrapper doc article h1 Welcome to Play / h1 p Congratulations, you\u2019ve just created a new Play application. This page will help you with the next few steps. / p blockquote p You\u2019re using Play @version / p / blockquote ... } Para incorporar el valor del par\u00e1metro en la plantilla hay que preceder el par\u00e1metro con @ . En el ejemplo anterior se obtiene as\u00ed el mensaje, que se pinta en la parte superior de la p\u00e1gina. La p\u00e1gina HTML resultante mostrada en el navegador es la siguiente: La directiva @defining permite obtener un valor y asign\u00e1rselo a una variable que se utiliza en un bloque de c\u00f3digo. En el caso anterior se utiliza para obtener la versi\u00f3n de Play. Otro ejemplo de su utilizaci\u00f3n es el que aparece en la documentaci\u00f3n de Play sobre plantillas: 1 2 3 @defining(user.getFirstName() + + user.getLastName()) { fullName = div Hello @fullName / div } Inyecci\u00f3n de dependencias Play usa el framework Java de Google Guice para realizar inyecci\u00f3n de dependencias. La anotaci\u00f3n @Inject hace que Play inyecte en la variable anotada un objeto nuevo del tipo indicado por la variable. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Es posible definir singletons con la anotaci\u00f3n @Singleton . En la aplicaci\u00f3n ejemplo se define un servicio y un controller para implementar un contador que se incrementa en cada petici\u00f3n a la acci\u00f3n count . En el controller se inyecta el componente counter : Fichero controllers/CountController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package controllers ; import javax.inject.* ; import play.mvc.* ; import services.Counter ; @Singleton public class CountController extends Controller { private final Counter counter ; @Inject public CountController ( Counter counter ) { this . counter = counter ; } /** * An action that responds with the {@link Counter} s current * count. The result is plain text. This action is mapped to * code GET /code requests with a path of code /count /code * requests by an entry in the code routes /code config file. */ public Result count () { return ok ( Integer . toString ( counter . nextCount ())); } } El contador se define con una interfaz y una implementaci\u00f3n concreta. Fichero services/Counter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 package services ; /** * This interface demonstrates how to create a component that is injected * into a controller. The interface represents a counter that returns a * incremented number each time it is called. * * The {@link Modules} class binds this interface to the * {@link AtomicCounter} implementation. */ public interface Counter { int nextCount (); } Fichero services/AtomicCounter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package services ; import java.util.concurrent.atomic.AtomicInteger ; import javax.inject.* ; /** * This class is a concrete implementation of the {@link Counter} trait. * It is configured for Guice dependency injection in the {@link Module} * class. * * This class has a {@link Singleton} annotation because we need to make * sure we only use one counter per application. Without this * annotation we would get a new instance every time a {@link Counter} is * injected. */ @Singleton public class AtomicCounter implements Counter { private final AtomicInteger atomicCounter = new AtomicInteger (); @Override public int nextCount () { return atomicCounter . getAndIncrement (); } } La definici\u00f3n de la clase concreta que se inyecta se realiza en el m\u00e9todo configure() de una clase llamada Module que debe extender AbstractModule y estar situada en el paquete ra\u00edz. Fichero Module.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import com.google.inject.AbstractModule ; import services.AtomicCounter ; import services.Counter ; /** * This class is a Guice module that tells Guice how to bind several * different types. This Guice module is created when the Play * application starts. * * Play will automatically use any class called `Module` that is in * the root package. You can create modules in other locations by * adding `play.modules.enabled` settings to the `application.conf` * configuration file. */ public class Module extends AbstractModule { @Override public void configure () { // Set AtomicCounter as the implementation for Counter. bind ( Counter . class ). to ( AtomicCounter . class ); } } Tests Los tests se encuentran en el directorio tests . Se utiliza JUnit como framework de testing. Desde los tests se puede comprobar los distintos componentes de la aplicaci\u00f3n, incluyendo plantillas y peticiones a controllers. Lanzamiento de los tests desde sbt Para lanzar los tests desde la consola sbt se debe usar el comando test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [play-java] $ test [info] Updating {file:/code/}root... [info] Resolving jline#jline;2.14.3 ... [info] Done updating. [info] Test run started [info] Test ApplicationTest.simpleCheck started [info] Test ApplicationTest.renderTemplate started [info] Test run finished: 0 failed, 0 ignored, 2 total, 1.337s [info] Test run started [info] Test IntegrationTest.test started [info] application - Creating Pool for datasource default [info] application - ApplicationTimer demo: Starting application at 2018-08-21T07:41:46.226Z [info] application - ApplicationTimer demo: Stopping application at 2018-08-21T07:41:52.807Z after 6s. [info] application - Shutting down connection pool. [info] Test run finished: 0 failed, 0 ignored, 1 total, 9.704s [info] Passed: Total 3, Failed 0, Errors 0, Passed 3 [success] Total time: 37 s, completed Aug 21, 2018 7:41:53 AM Podemos lanzar una parte de los tests con el comando testOnly seguido del nombre completo de la clase (incluyendo el paquete en el que est\u00e9 incluida): 1 2 3 4 5 6 7 8 [play-java] $ testOnly ApplicationTest [info] Test run started [info] Test ApplicationTest.simpleCheck started [info] Test ApplicationTest.renderTemplate started [info] Test run finished: 0 failed, 0 ignored, 2 total, 1.405s [info] Passed: Total 2, Failed 0, Errors 0, Passed 2 [success] Total time: 12 s, completed Aug 21, 2018 9:58:57 AM [play-java] $ Lanzamiento de los tests de IntelliJ Tambi\u00e9n es posible lanzar los tests desde el entorno IntelliJ pulsando con el bot\u00f3n derecho la opci\u00f3n Run sobre la clase de test seleccionada. Aplicaci\u00f3n mads-todolist-inicial La aplicaci\u00f3n mads-todolist-inicial es una versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista anteriormente. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP en el fichero de rutas: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban sobre todo la capa de servicios. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo, integraci\u00f3n y stage (similar a producci\u00f3n). A continuaci\u00f3n se muestran dos de sus pantallas. Pantalla de login Pantalla con listado de tareas Descarga de la aplicaci\u00f3n mads-todolist-inicial Se encuentra en GitHub: https://github.com/domingogallardo/mads-todolist-inicial . Puedes descargarla con el comando git clone : 1 $ git clone https://github.com/domingogallardo/mads-todolist-inicial.git Se crear\u00e1 el directorio mads-todolist-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n. Importaci\u00f3n en IntellJ IDEA Al importar la aplicaci\u00f3n en IntelliJ IDEA aparece el aviso de que se ha detectado el framework JPA y da la opci\u00f3n de configurarlo. La configuraci\u00f3n es sencilla, s\u00f3lo hay que aceptar la localizaci\u00f3n del fichero persistence.xml que nos muestra la ventana de di\u00e1logo. Hablaremos m\u00e1s adelante de JPA. Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos en memoria Si ejecutamos la aplicaci\u00f3n usando el comando docker run ya visto se utilizar\u00e1 la base de datos H2 en memoria. Los datos almacenados en ella s\u00f3lo durar\u00e1n mientras que est\u00e1 en marcha el contenedor. 1 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework Base de datos MySQL con Docker Si queremos que los datos introducidos persistan a distintas activaciones de la aplicaci\u00f3n web debemos usar una base de datos externa. Esto es necesario cuando la aplicaci\u00f3n est\u00e9 en producci\u00f3n, pero tambi\u00e9n puede ser \u00fatil para realizar pruebas manuales en desarrollo. Podemos utilizar Docker para poner en marcha un servidor MySQL con el siguiente comando: 1 $ docker run -d -p 3316:3306 --name db-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 El comando pone en marcha un servidor MySQL escuchando en el puerto 3316 del host con el nombre docker db-mysql , con la contrase\u00f1a de root indicada y creando la base de datos mads . El puerto del host 3316 se mapea con el puerto interno del contenedor 3306. Ponemos el puerto 3316 para evitar posibles conflictos con un posible servidor de MySQL que tengamos funcionando en el host. Cuidado En los laboratorios de la EPS est\u00e1 instalada la imagen 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Podemos comprobar que el contenedor est\u00e1 funcionando con el comando docker container ls : 1 2 3 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7c1bed0b5b7e mysql docker-entrypoint... 6 seconds ago Up 4 seconds 0.0.0.0:3316- 3306/tcp db-mysql Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop container-id y docker start container-id . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls lista los contenedores en marcha, y con la opci\u00f3n -a tambi\u00e9n los parados. 1 2 3 4 5 6 7 8 9 10 11 $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060/tcp, 0.0.0.0:3316- 3306/tcp db-mysql $ docker container stop bd057639b6ac $ docker container ls -a CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited (0) 7 seconds ago db-mysql $ docker container start bd057639b6ac $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060/tcp, 0.0.0.0:3316- 3306/tcp db-mysql Podemos usar el identificador o el nombre del contenedor para pararlo: 1 $ docker container stop db-mysql Para borrar un contenedor debe estar parado y debemos usar el comando 1 docker container rm container-id o container-name Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos MySQL Desde Docker Lanzamos la aplicaci\u00f3n con Docker, definiendo en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000:9000 -e \\ DB_URL= jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf (lo explicamos m\u00e1s adelante). 1 2 [mads-todolist-2018] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-2018] $ run Desde el run/debug de IntelliJ Tambi\u00e9n es posible definir una configuraci\u00f3n de run/debug en IntelliJ en la que se inicialice la preferencia config.file y las variables de entorno para conectarse con la base de datos, en el puerto del host en el que est\u00e1 escuchando (3331, si hemos lanzado el servicio de base de datos usando Docker como hemos visto anteriormente): Cuidado Si est\u00e1s lanzando MySQL usando Docker Toolbox debes modificar la DB_URL indicando el host al que conectarse (no ser\u00e1 localhost ). La direcci\u00f3n IP ser\u00e1 la que aparece en la consola de docker al arrancar. Por ejemplo jdbd:mysql://192.168.99.100/mads . Panel Database de IntelliJ Desde el panel Database de IntelliJ (en la esquina superior derecha) es posible crear una conexi\u00f3n a la base de datos que nos permitir\u00e1 verificar c\u00f3mo se guardan los datos de la aplicaci\u00f3n. Hay que a\u00f1adir una base de datos de tipo MySQL y configurarla con los siguientes par\u00e1metros: Cuidado Igual que en el apartado anterior, si est\u00e1s lanzando MySQL usando Docker Toolbox debes indicar el host al que conectarse (no ser\u00e1 localhost ) escribiendo la direcci\u00f3n IP que aparece en la consola de docker al arrancar. Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto: Configuraci\u00f3n de la aplicaci\u00f3n Los distintos par\u00e1metros de la aplicaci\u00f3n Play se configuran en un fichero de propiedades. Configuraci\u00f3n por defecto El fichero de configuraci\u00f3n que carga la aplicaci\u00f3n por defecto es conf/application.conf . Por ejemplo, las propiedades relacionadas con la definici\u00f3n de la base de datos que se definen en el fichero son las siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Default persistenceUnit for JPA jpa.default = develop db { # You can declare as many datasources as you want. # By convention, the default datasource is named `default` # https://www.playframework.com/documentation/latest/Developing-with-the-H2-Database # Memory H2 database default.driver = org.h2.Driver default.url = jdbc:h2:mem:play;MODE=MYSQL #default.username = sa #default.password = # Definiemos el nombre JNDI de la BD que va a usar la aplicaci\u00f3n default.jndiName=DBTodoList # You can turn on SQL logging for any datasource # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements # default.logSql=true } En el fichero por defecto se define una conexi\u00f3n con la base de datos de memoria H2 en la fuente de datos llamada default (la fuente de datos que usa por defecto la aplicaci\u00f3n). Se definen las siguientes propiedades: jpa.default : Nombre de la unidad de persistencia JPA que se usar\u00e1 en la aplicaci\u00f3n. db.default.driver : Driver de la base de datos. db.default.url : URL de conexi\u00f3n a la base de datos. db.default.jndiName : Nombre l\u00f3gico JNDI que se asigna a la base de datos. db.default.logSql : Si se descomenta se mostrar\u00e1 en la consola el log de todas las operaciones sobre la base de datos. Otras configuraciones Como ya hemos visto, modificando la propiedad del sistema Java config.file podemos definir un fichero de configuraci\u00f3n distinto. Se definen tambi\u00e9n los siguientes ficheros adicionales que se usar\u00e1n para lanzar la aplicaci\u00f3n en distintas configuraciones: develop-mysql.conf : configuraci\u00f3n de desarrollo con base de datos externa. La aplicaci\u00f3n trabaja sobre una base de datos MySQL externa cuyo esquema se actualiza autom\u00e1ticamente al modificar y a\u00f1adir nuevas entidades a la aplicaci\u00f3n. production.conf : configuraci\u00f3n de producci\u00f3n. La aplicaci\u00f3n trabaja sobre una base de datos MySQL externa, cuyo esquema es validado para que se corresponda con las entidades de la aplicaci\u00f3n. Fichero conf/develop-mysql.conf : 1 2 3 4 5 6 include application.conf db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Fichero conf/production.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Los dos ficheros de configuraci\u00f3n incluyen el fichero application.conf y despu\u00e9s modifican las propiedades necesarias. Los valores de los par\u00e1metros de configuraci\u00f3n de la base de datos url , username y password se obtienen de las variables de entorno. Gesti\u00f3n de persistencia con JPA Para la gesti\u00f3n de la persistencia de los datos en una aplicaci\u00f3n Play usaremos JPA ( Java Persistence API ), en concreto la implementaci\u00f3n 5.2.5 de Hibernate. Definici\u00f3n del modelo de datos El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario define una tabla Usuario en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia AUTO . Cuando un usuario creado en memoria se haga persistente en la base de datos, este atributo se actualizar\u00e1 con el valor obtenido por Hibernate. La estrategia AUTO se basa en obtener el valor de la clave primaria usando una tabla auxiliar hibernate_sequence que guarda el siguiente valor a asignar a una nueva clave primaria. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario, unos getters y setters y los m\u00e9todos equals y hashCode para comparar usuarios. Fichero models/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @Entity public class Usuario { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String login ; private String email ; private String password ; private String nombre ; private String apellidos ; @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany ( mappedBy = usuario , fetch = FetchType . EAGER ) private Set Tarea tareas = new HashSet (); @ManyToMany ( mappedBy = usuarios , fetch = FetchType . EAGER ) private Set Equipo equipos = new HashSet (); // Un constructor vac\u00edo necesario para JPA public Usuario () { } // El constructor principal con los campos obligatorios public Usuario ( String login , String email ) { this . login = login ; this . email = email ; } // Getters y setters necesarios para JPA ... // Funci\u00f3n para imprimr los datos de un usuario public String toString () { String fechaStr = null ; if ( fechaNacimiento != null ) { SimpleDateFormat formateador = new SimpleDateFormat ( dd-MM-yyyy ); fechaStr = formateador . format ( fechaNacimiento ); } return String . format ( Usuario id: %s login: %s password: %s nombre: %s + apellidos: %s e-mail: %s fechaNacimiento: %s , id , login , password , nombre , apellidos , email , fechaNacimiento ); } // Funciones hashCode y equals para poder comparar usuarios y // necesarias para poder crear un Set de usuarios @Override public int hashCode () { // Devolvemos el hash de los campos obligatorios return Objects . hash ( login , email ); } // Si el usuario tiene un ID (se ha obtenido de la BD) // la comparaci\u00f3n se basa en ese ID. Si el ID no existe (el usuario // se ha creado en memoria y todav\u00eda no se ha sincronizado con la BD) // la comparaci\u00f3n se basa en los atributos obligatorios. @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( getClass () != obj . getClass ()) return false ; Usuario other = ( Usuario ) obj ; if ( id != null other . id != null ) { // Si tenemos los ID, comparamos por ID return ( id == other . id ); } // sino comparamos por campos obligatorios else { if ( login == null ) { if ( other . login != null ) return false ; } else if (! login . equals ( other . login )) return false ; if ( email == null ) { if ( other . email != null ) return false ; } else if (! email . equals ( other . email )) return false ; } return true ; } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos) y puede participar en Equipo s (relaci\u00f3n muchos-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La relaci\u00f3n muchos-a-muchos se representa en la base de datos con una tabla auxiliar con dos claves ajenas. El atributo mappedBy indica que la definici\u00f3n de esa tabla se encuentra en el atributo usuario de la entidad Equipo . Las definiciones de Tarea y Equipo son las siguientes: Fichero models/Tarea.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Entity public class Tarea { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String titulo ; // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = usuarioId ) public Usuario usuario ; public Tarea () { } // Constructor, getters y setters, equals y hashCode } Fichero models/Equipo.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Entity public class Equipo { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; private String nombre ; @ManyToMany @JoinTable ( name = Equipo_Usuario , joinColumns = { @JoinColumn ( name = fk_equipo ) }, inverseJoinColumns = { @JoinColumn ( name = fk_usuario )}) private Set Usuario usuarios = new HashSet (); // Un constructor vac\u00edo necesario para JPA public Equipo () { } // Constructor, getters y setters, equals y hashCode // M\u00e9todos de actualizaci\u00f3n de la relaci\u00f3n muchos-a-muchos con usuario public void addUsuario ( Usuario usuario ) { usuarios . add ( usuario ); usuario . getEquipos (). add ( this ); } public void removeUsuario ( Usuario usuario ) { usuarios . remove ( usuario ); usuario . getEquipos (). remove ( this ); } } Fichero de configuraci\u00f3n de JPA El fichero conf/META-INF/persistence.xml es necesario para que JPA funcione correctamente. Es el fichero de configuraci\u00f3n en el que se definen distintos elementos necesarios para la configuraci\u00f3n de JPA. Nombre JNDI de la fuente de datos con la que se conectar\u00e1 la aplicaci\u00f3n: DBTodoList , definida en el fichero de configuraci\u00f3n de la aplicaci\u00f3n Play ( /conf/application.conf ). Clases entidad que se definen en la aplicaci\u00f3n. Propiedad hibernate.hbm2ddl.auto que indica c\u00f3mo JPA va a gestionar las tablas en la base de datos. Si el valor es update , al arrancar la aplicaci\u00f3n las tablas de la base de datos se actualizan (o se crean, si la base de datos est\u00e1 vac\u00eda) para que se correspondan con las entidades. Se suele utilizar este valor cuando estamos desarrollando la aplicaci\u00f3n. Si el valor es validate , al arrancar la aplicaci\u00f3n se comprueba si la base de datos contiene tablas que se corresponden con las definiciones de las entidades. Si no es as\u00ed, JPA lanza una excepci\u00f3n y deja de funcionar. Se suele utilizar este valor en el funcionamiento de la aplicaci\u00f3n en producci\u00f3n. Definimos dos configuraciones, una denominada develop y otra denominada production . La \u00fanica diferencia entre ellas es el valor de la propiedad hibernate.hbm2ddl.auto . Fichero conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 persistence xmlns= http://xmlns.jcp.org/xml/ns/persistence xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd version= 2.1 !-- MySQL Persistence Unit - Develop: hbm2ddl.auto = UPDATE -- persistence-unit name= develop transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit !-- MySQL Persistence Unit - Production: hbm2ddl.auto = VALIDATE -- persistence-unit name= production transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit /persistence Actualizaci\u00f3n de los datos Se definen clases repository que definen m\u00e9todos para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. Fichero models/UsuarioRepository.java : 1 2 3 4 5 6 7 public interface UsuarioRepository { Usuario add ( Usuario usuario ); // Queries Usuario findById ( Long id ); Usuario findByLogin ( String login ); } Fichero models/TareaRepository.java : 1 2 3 4 5 6 7 8 public interface TareaRepository { Tarea add ( Tarea tarea ); Tarea update ( Tarea tarea ); void delete ( Tarea tarea ); // Queries Tarea findById ( Long idTarea ); } Fichero models/EquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public interface EquipoRepository { Equipo add ( Equipo equipo ); Equipo update ( Equipo equipo ); void delete ( Equipo equipo ); void addUsuarioEquipo ( Usuario usuario , Equipo equipo ); void deleteUsuarioEquipo ( Usuario usuario , Equipo equipo ); // Queries Equipo findById ( Long idEquipo ); Equipo findByNombre ( String nombre ); List Equipo findAll (); List Usuario findUsuariosEquipo ( String nombreEquipo ); } La implementaci\u00f3n utiliza JPA para realizar las actualizaciones y consultas sobre las entidades. Cada m\u00e9todo abre y cierra una transacci\u00f3n en la que se propaga el cambio a la base de datos. Para trabajar con JPA en Play se debe usar un objeto JPAApi que se obtiene por inyecci\u00f3n de dependencias. Play guarda en la variable jpaApi una instancia con la que podemos, entre otras cosas, abrir y cerrar transacciones. Por ejemplo, la implementaci\u00f3n de la parte de la interfaz EquipoRepository que trata de la actualizaci\u00f3n de la entidad en la base de datos es la siguiente: Fichero models/JPAEquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public class JPAEquipoRepository implements EquipoRepository { JPAApi jpaApi ; @Inject public JPAEquipoRepository ( JPAApi api ) { this . jpaApi = api ; } @Override public Equipo add ( Equipo equipo ) { return jpaApi . withTransaction ( entityManager - { entityManager . persist ( equipo ); entityManager . flush (); entityManager . refresh ( equipo ); return equipo ; }); } @Override public Equipo update ( Equipo equipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . merge ( equipo ); }); } @Override public void delete ( Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . getReference ( Equipo . class , equipo . getId ()); entityManager . remove ( equipoBD ); }); } @Override public void addUsuarioEquipo ( Usuario usuario , Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . merge ( equipo ); Usuario usuarioBD = entityManager . merge ( usuario ); equipoBD . addUsuario ( usuarioBD ); }); } @Override public void deleteUsuarioEquipo ( Usuario usuario , Equipo equipo ) { jpaApi . withTransaction ( () - { EntityManager entityManager = jpaApi . em (); Equipo equipoBD = entityManager . merge ( equipo ); Usuario usuarioBD = entityManager . merge ( usuario ); equipoBD . removeUsuario ( usuarioBD ); }); } Todos los m\u00e9todos trabajan con un EntityManager , que es la clase de JPA que gestiona las actualizaciones y queries sobre la base de datos. Y las queries se implementan de la siguiente manera: Fichero models/JPAEquipoRepository.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Override public Equipo findById ( Long idEquipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . find ( Equipo . class , idEquipo ); }); } @Override public Equipo findByNombre ( String nombre ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Equipo query = entityManager . createQuery ( select e from Equipo e where e.nombre = :nombre , Equipo . class ); try { Equipo equipo = query . setParameter ( nombre , nombre ). getSingleResult (); return equipo ; } catch ( NoResultException ex ) { return null ; } }); } @Override public List Equipo findAll () { return jpaApi . withTransaction ( entityManager - { TypedQuery Equipo query = entityManager . createQuery ( select e from Equipo e , Equipo . class ); return query . getResultList (); }); } public List Usuario findUsuariosEquipo ( String nombreEquipo ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Usuario query = entityManager . createQuery ( select u from Usuario u join u.equipos e where e.nombre = :nombreEquipo , Usuario . class ); try { return query . setParameter ( nombreEquipo , nombreEquipo ). getResultList (); } catch ( NoResultException ex ) { return null ; } }); } } Recuperaci\u00f3n eager y lazy de las colecciones En la aplicaci\u00f3n se definen relaciones a-muchos entre las entidades: Relaci\u00f3n uno-a-muchos entre usuarios y tareas: un usuario tiene muchas tareas Relaci\u00f3n muchos-a-muchos entre usuarios y equipos: un equipo tiene muchos usuarios y un usuario participa en varios equipos. En las entidades estas relaciones se definen de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Entity public class Usuario { ... // Relaci\u00f3n uno-a-muchos entre usuario y tarea @OneToMany ( mappedBy = usuario , fetch = FetchType . EAGER ) private Set Tarea tareas = new HashSet (); @ManyToMany ( mappedBy = usuarios , fetch = FetchType . EAGER ) private Set Equipo equipos = new HashSet (); ... } @Entity public class Tarea { ... // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = usuarioId ) public Usuario usuario ; ... } public class Equipo { ... @ManyToMany @JoinTable ( name = Equipo_Usuario , joinColumns = { @JoinColumn ( name = fk_equipo ) }, inverseJoinColumns = { @JoinColumn ( name = fk_usuario )}) private Set Usuario usuarios = new HashSet (); ... } Relaciones lazy Por defecto, todas las relaciones a-muchos en JPA se definen de tipo LAZY . La caracter\u00edstica de los atributos marcados como lazy en JPA es que no se traen a memoria cuando se recupera la entidad, sino cuando se consultan. Por ejemplo, en el caso de equipos y usuarios, la lista de usuarios de un equipo es un atributo lazy . Veamos el m\u00e9todo findById de un equipo que devuelve una entidad Equipo a partir de su identificador: 1 2 3 4 5 public Equipo findById ( Long idEquipo ) { return jpaApi . withTransaction ( entityManager - { return entityManager . find ( Equipo . class , idEquipo ); }); } El m\u00e9todo jpaApi.withTransaction abre y cierra una conexi\u00f3n con la base de datos que es gestionada por el entity manager . La conexi\u00f3n est\u00e1 abierta mientras se ejecuta el c\u00f3digo dentro del withTransaction (la llamada a find que recupera el equipo). Pero cuando se hace el return esa conexi\u00f3n se cierra y se devuelve un equipo cuya lista de usuarios no se ha cargado a memoria. Si intentamos acceder a una colecci\u00f3n lazy sin estar en el \u00e1mbito del entity manager se producir\u00e1 un error porque no se puede inicializar esa colecci\u00f3n. Por ejemplo, el siguiente test produce un error cuando se llama al m\u00e9todo size() y se intenta contar los elementos de la conexi\u00f3n lazy : 1 2 3 4 5 6 7 8 9 10 11 @Test public void errorLazy () { EquipoRepository equipoRepository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = equipoRepository . findById ( 1005L ); assertEquals ( 1 , equipo . getUsuarios (). size ()); } // Se produce el siguiente error: // Test models.EquipoTest.errorLazy failed: // org.hibernate.LazyInitializationException: failed to lazily initialize a collection // of role: models.Equipo.usuarios, could not initialize proxy - no Session \u00bfC\u00f3mo podemos solucionar esto? La clave es que s\u00f3lo podremos recuperar una colecci\u00f3n lazy estando en un entity manager abierto . Por ejemplo, podemos hacer un m\u00e9todo espec\u00edfico que devuelve la colecci\u00f3n de usuarios de un equipo: 1 2 3 4 5 6 7 8 9 // Versi\u00f3n en la que se obtienen los usuarios accediendo a la colecci\u00f3n lazy public List Usuario findUsuariosEquipo ( Long idEquipo ) { return jpaApi . withTransaction ( entityManager - { Equipo equipo = entityManager . find ( Equipo . class , idEquipo ); equipo . getUsuarios (). size (); List Usuario usuarios = new ArrayList ( equipo . getUsuarios ()); return usuarios ; }); } La llamada a size() en la l\u00ednea 5 accede a la colecci\u00f3n estando el entity manager abierto y trae a memoria sus elementos de la base de datos. Por ello la colecci\u00f3n de usuarios que se devuelve ya contiene todos los usuarios del equipo. Otra forma de recuperar colecciones lazy es haciendo directamente una query: 1 2 3 4 5 6 7 8 9 10 11 12 // Versi\u00f3n en la que obtienen los usuarios mediante una query public List Usuario findUsuariosEquipo ( Long idEquipo ) { return jpaApi . withTransaction ( entityManager - { TypedQuery Usuario query = entityManager . createQuery ( select u from Usuario u join u.equipos e where e.id = :idEquipo , Usuario . class ); try { return query . setParameter ( idEquipo , idEquipo ). getResultList (); } catch ( NoResultException ex ) { return null ; } }); } Relaciones eager Frente a la recuperaci\u00f3n lazy de colecciones, tambi\u00e9n existe la posibilidad de definir una colecci\u00f3n como de tipo EAGER . En este caso JPA se traer\u00e1 siempre a memoria todos los elementos. Es el caso de la relaci\u00f3n entre un usuario y sus tareas. En general, no es conveniente definir una relaci\u00f3n como eager porque puede provocar problemas de rendimiento en el caso en que haya muchos elementos relacionados. Pero si no hay muchos datos en la relaci\u00f3n y los vamos a usar con frecuencia, s\u00ed que es aconsejable usar el tipo EAGER para facilitar el manejo de la entidad. Servicios La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Fichero services/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class UsuarioService { UsuarioRepository repository ; // Play proporcionar\u00e1 autom\u00e1ticamente el UsuarioRepository necesario // usando inyecci\u00f3n de dependencias @Inject public UsuarioService ( UsuarioRepository repository ) { this . repository = repository ; } public Usuario creaUsuario ( String login , String email , String password ) { if ( repository . findByLogin ( login ) != null ) { throw new UsuarioServiceException ( Login ya existente ); } Usuario usuario = new Usuario ( login , email ); usuario . setPassword ( password ); return repository . add ( usuario ); } public Usuario findUsuarioPorLogin ( String login ) { return repository . findByLogin ( login ); } public Usuario findUsuarioPorId ( Long id ) { return repository . findById ( id ); } public Usuario login ( String login , String password ) { Usuario usuario = repository . findByLogin ( login ); if ( usuario != null usuario . getPassword (). equals ( password )) { return usuario ; } else { return null ; } } } Fichero services/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 9 public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException () { } public UsuarioServiceException ( String message ) { super ( message ); } } Controllers Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen tres clases controller: UsuarioController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. EquipoController : con m\u00e9todos para crear, a\u00f1adir usuarios y listar equipos. Por ejemplo, la clase EquipoController define las acciones relacionadas con crear equipos de usuarios. En este controlador se obtienen los datos del formulario de la petici\u00f3n HTTP usando un DynamicForm que contiene todos los valores (Strings) asociados a los datos del formulario. Tambi\u00e9n es posible realizar un mapping autom\u00e1tico entre los datos de un formulario y un objeto Java usando un objeto Form . En el UsuarioController se puede ver un ejemplo que usa las clases Login y Registro . En este caso es posible definir restricciones en los atributos y realizar una validaci\u00f3n en el servidor. Fichero controllers/EquipoController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; public class EquipoController extends Controller { @Inject FormFactory formFactory ; @Inject EquipoService equipoService ; @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioNuevoEquipo () { return ok ( formNuevoEquipo . render ( )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result creaNuevoEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String nombre = requestData . get ( nombre ); if ( nombre == null || nombre . equals ( )) { return badRequest ( formNuevoEquipo . render ( Debes rellenar el nombre )); } equipoService . addEquipo ( nombre ); return ok ( Equipo + nombre + a\u00f1adido correctamente ); } public Result listaEquipos () { List Equipo equipos = equipoService . allEquipos (); return ok ( listaEquipos . render ( equipos )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioAddUsuarioEquipo () { return ok ( formEquipoUsuario . render ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result addUsuarioEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String equipo = requestData . get ( equipo ); String usuario = requestData . get ( usuario ); try { equipoService . addUsuarioEquipo ( usuario , equipo ); return ok ( Usuario + usuario + a\u00f1adido al equipo + equipo ); } catch ( EquipoServiceException exception ) { return notFound ( No existe usuario / equipo ); } } } La clase UsuarioController se encarga de las acciones de registro y login. Fichero controllers/UsuarioController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package controllers ; public class UsuarioController extends Controller { @Inject FormFactory formFactory ; // Play injecta un usuarioService junto con todas las dependencias necesarias: // UsuarioRepository y JPAApi @Inject UsuarioService usuarioService ; public Result saludo ( String mensaje ) { return ok ( saludo . render ( El mensaje que he recibido es: + mensaje )); } public Result formularioRegistro () { return ok ( formRegistro . render ( formFactory . form ( Registro . class ), )); } public Result registroUsuario () { Form Registro form = formFactory . form ( Registro . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formRegistro . render ( form , Hay errores en el formulario )); } Registro datosRegistro = form . get (); if ( usuarioService . findUsuarioPorLogin ( datosRegistro . login ) != null ) { return badRequest ( formRegistro . render ( form , Login ya existente: escoge otro )); } if (! datosRegistro . password . equals ( datosRegistro . confirmacion )) { return badRequest ( formRegistro . render ( form , No coinciden la contrase\u00f1a y la confirmaci\u00f3n )); } Usuario usuario = usuarioService . creaUsuario ( datosRegistro . login , datosRegistro . email , datosRegistro . password ); return redirect ( controllers . routes . UsuarioController . formularioLogin ()); } public Result formularioLogin () { return ok ( formLogin . render ( formFactory . form ( Login . class ), )); } public Result loginUsuario () { Form Login form = formFactory . form ( Login . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formLogin . render ( form , Hay errores en el formulario )); } Login login = form . get (); Usuario usuario = usuarioService . login ( login . username , login . password ); if ( usuario == null ) { return notFound ( formLogin . render ( form , Login y contrase\u00f1a no existentes )); } else { // A\u00f1adimos el id del usuario a la clave `connected` de // la sesi\u00f3n de Play // https://www.playframework.com/documentation/2.5.x/JavaSessionFlash // Esa clave es la usada en la autenticaci\u00f3n session ( connected , usuario . getId (). toString ()); return redirect ( controllers . routes . TareasController . listaTareas ( usuario . getId ())); } } // Comprobamos si hay alguien logeado con @Security.Authenticated(ActionAuthenticator.class) // https://alexgaribay.com/2014/06/15/authentication-in-play-framework-using-java/ @Security.Authenticated ( ActionAuthenticator . class ) public Result logout () { session (). remove ( connected ); return redirect ( controllers . routes . UsuarioController . loginUsuario ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result detalleUsuario ( Long id ) { String connectedUserStr = session ( connected ); Long connectedUser = Long . valueOf ( connectedUserStr ); if ( connectedUser != id ) { return unauthorized ( Lo siento, no est\u00e1s autorizado ); } else { Usuario usuario = usuarioService . findUsuarioPorId ( id ); if ( usuario == null ) { return notFound ( Usuario no encontrado ); } else { Logger . debug ( Encontrado usuario + usuario . getId () + : + usuario . getLogin ()); return ok ( detalleUsuario . render ( usuario )); } } } } Para mapear los datos de los formularios se usan las clases Login y Registro . Fichero controllers/Login.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package controllers ; import play.data.validation.Constraints ; public class Login { @Constraints.Required public String username ; @Constraints.Required public String password ; public String getUsername () { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Fichero controllers/Registro.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; import play.data.validation.Constraints ; public class Registro { @Constraints.Required public String login ; @Constraints.Required @Constraints.Email public String email ; @Constraints.Required public String password ; @Constraints.Required public String confirmacion ; public String getLogin () { return login ; } public void setLogin ( String login ) { this . login = login ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getConfirmacion () { return confirmacion ; } public void setConfirmacion ( String confirmacion ) { this . confirmacion = confirmacion ; } } Vistas Todas las vistas de la aplicaci\u00f3n usan como plantilla base la vista main.scala.html , en la que se carga el framework CSS Bootstrap y la librer\u00eda JavaScript JQuery . Ambos se encuentran en el directorio public , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Play. Es importante hacer notar que se obtiene la ruta absoluta a los ficheros est\u00e1ticos llamando a routes.Assets.versioned con su ruta relativa. De esta forma se modificar el directorio por defecto en el que se guardan los recursos est\u00e1ticos sin afectar a la aplicaci\u00f3n. A la plantilla main se le pasa el t\u00edtulo de la p\u00e1gina, scripts JavaScript (por defecto vac\u00edo) y un contenido HTML que se inserta en el cuerpo principal. Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String, scripts: Html = Html( ))(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link href = @routes.Assets.versioned( bootstrap / css / bootstrap . min . css ) rel = stylesheet media = screen link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body div class = container @content / div script src = @routes.Assets.versioned( javascripts / jquery . min . js ) type = text/javascript / script script src = @routes.Assets.versioned( bootstrap / js / bootstrap . min . js ) type = text/javascript / script @scripts / body / html Un ejemplo del uso de esta plantilla es la plantilla principal del listado de tareas. Se trata de una plantilla compleja, con bastantes ejemplos de c\u00f3mo usar los distintos elementos de Play: La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n for para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se usan enlaces a las URLs definidas por rutas inversas. Fichero views/listaTareas.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @(tareas: List[Tarea], usuario: Usuario, mensaje: String) @scripts = { script type = text/javascript function del ( urlBorrar ) { $ . ajax ({ url : urlBorrar , type : DELETE , success : function ( results ) { //refresh the page location . reload (); } }); } / script } @main( Tareas del usuario @usuario.getLogin() , scripts) { h2 Listado de tareas de @usuario.getLogin() / h2 table class = table table-striped tr th Tareas / th th Acci\u00f3n / th / tr @for(tarea - tareas ) { tr td @tarea.getTitulo() / td td a href = @routes.TareasController.formularioEditaTarea(tarea.getId()) span class = glyphicon glyphicon-pencil / span nbsp; / a a onmouseover = style = cursor: pointer; onclick = del( @routes.TareasController.borraTarea(tarea.getId()) ) span class = glyphicon glyphicon-trash aria-hidden = true / span / a / td / tr } tr td a href = @routes.TareasController.formularioNuevaTarea(usuario.getId()) span class = glyphicon glyphicon-plus / / a / td td a href = @routes.UsuarioController.logout() Salir / a / td / tr / table @if(mensaje != null) { div class = alert alert-success role = alert button type = button class = close data-dismiss = alert aria-label = Close span aria-hidden = true times; / span / button @mensaje / div } } Tests La mayor\u00eda de los tests que contiene la aplicaci\u00f3n son tests de integraci\u00f3n, en los que no se usan mocks , sino que se comprueba el funcionamiento de la capa de servicio y la de repositorio. Como framework de testing se usa JUnit . Los datos de prueba en las tablas de la base de datos se definen y se cargan usando DBUnit . Por ejemplo, la clase models.EquipoTest contiene tests para el modelo Equipo y el EquipoRepository . Los tests se realizar\u00e1n utilizando la base de datos definida en el fichero de configuraci\u00f3n. En el fichero de configuraci\u00f3n por defecto ( conf/application.conf ) se define la base de datos de memoria H2 . Tests con la base de datos de memoria H2 Ejemplo de ejecuci\u00f3n de los tests sobre la base de datos de memoria: 1 2 3 4 5 6 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [mads-todolist-inicial] $ test .. [info] Test run finished: 0 failed, 0 ignored, 5 total, 1.753s [info] Passed: Total 36, Failed 0, Errors 0, Passed 36 [success] Total time: 51 s, completed Aug 21, 2018 10:56:42 AM Podemos lanzar una clase de test en concreto: 1 2 3 4 5 [mads-todolist-inicial] $ testOnly models.EquipoTest ... [info] Test run finished: 0 failed, 0 ignored, 6 total, 11.377s [info] Passed: Total 6, Failed 0, Errors 0, Passed 6 [success] Total time: 38 s, completed Aug 22, 2018 7:41:09 AM Tests con la base de datos MySQL La otra configuraci\u00f3n que vamos a usar en los tests es conf/develop-mysql.conf , en la que se utiliza una base de datos MySQL. Como ya vimos anteriormente, para utilizar esta configuraci\u00f3n hay que lanzar el servicio de MySQL usando docker y definir en la ejecuci\u00f3n del contenedor de Play las variables de entorno DB_URL , DB_USER_NAME y DB_USER_PASSWD con los datos correctos para acceder a la base de datos MySQL. 1 2 3 4 5 6 7 8 9 $ docker run -d --rm -p 3306:3306 --name db-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql $ docker run --link db-mysql --rm -it -p 9000:9000 -e \\ DB_URL= jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME= root -e \\ DB_USER_PASSWD= mads -v ${PWD}:/code domingogallardo/playframework [mads-todolist-inicial] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-inicial] $ test ... [success] Total time: 44 s, completed Aug 22, 2018 7:48:32 AM [mads-todolist-inicial] $ Ejemplos de tests de la aplicaci\u00f3n En la aplicaci\u00f3n se definen tests sobre los modelos (clases entidad y clases repositorio) y sobre los servicios. Como hemos mencionado antes se tratan de unos tests de integraci\u00f3n que se prueban directamente sobre la base de datos activa en el fichero de configuraci\u00f3n. Aunque Play proporciona facilidades para el uso de mocks no los hemos utilizado por simplificar la realizaci\u00f3n de los tests. Se utiliza DBUnit para rellenar las tablas con los datos de pruebas. El m\u00e9todo initData() limpia las tablas e inicializa estos datos con los existentes en test/resources/test_dataset.xml comienzo de la ejecuci\u00f3n de cada test. DBUnit rellena las tablas f\u00edsicas de la base de datos, no usa JPA. Hay que utilizar los nombres de las tablas y de las columnas de la propia base de datos, no los de las entidades JPA. Hay que incluir en el fichero de dataset todas las tablas de la aplicaci\u00f3n, incluyendo las tablas auxiliares de las relaciones muchos-a-muchos, para que se inicialicen los de datos de prueba (por ejemplo, la tabla Equipo_Usuario ). Por \u00faltimo, se debe tener cuidado con las claves ajenas. No es posible borrar una tabla si hay claves ajenas que referencian a algunos de sus elementos. Para esto hay que considerar que DBUnit inserta los datos de arriba a abajo y los borra de abajo a arriba. Fichero test/resources/test_dataset.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ?xml version= 1.0 encoding= UTF-8 ? dataset Usuario id= 1000 login= juangutierrez nombre= Juan apellidos= Gutierrez password= 123456789 eMail= juan.gutierrez@gmail.com fechaNacimiento= 1993-12-10 / Usuario id= 1005 login= anagarcia nombre= Ana apellidos= Garcia password= 123456789 eMail= ana.garcia@gmail.com fechaNacimiento= 1993-02-08 / Tarea id= 1001 titulo= Renovar DNI usuarioId= 1000 / Tarea id= 1002 titulo= Pr\u00e1ctica 1 MADS usuarioId= 1000 / Equipo id= 1003 nombre= Equipo A / Equipo id= 1004 nombre= Equipo B / Equipo id= 1005 nombre= Equipo C / Equipo_Usuario fk_equipo= 1003 fk_usuario= 1000 / Equipo_Usuario fk_equipo= 1003 fk_usuario= 1005 / Equipo_Usuario fk_equipo= 1004 fk_usuario= 1000 / /dataset En cuanto a los tests propiamente dichos hay que resaltar algunos puntos. Los objetos definidos con inyecci\u00f3n de dependencias (la anotaci\u00f3n @Inject ) se instancian mediante el Injector de la aplicaci\u00f3n Play. La aplicaci\u00f3n se construye leyendo el fichero de configuraci\u00f3n por defecto (se puede modificar con la variable config.file de las opciones Java al lanzar el test). De esta forma los objetos instanciados utilizar\u00e1n la fuente de datos definida en la configuraci\u00f3n de la aplicaci\u00f3n (H2 o MySQL). Los tests sobre los modelos contienen pruebas sobre las entidades (por ejemplo, se comprueba el m\u00e9todo equal con entidades con y sin identificador) y sobre el repositorio del modelo, en los que se comprueba que las operaciones sobre la base de datos funcionan correctamente. Los tests sobre los servicios contienen pruebas sobre los m\u00e9todos de negocio de la clase servicio, incluyendo comprobaciones de que se lanzan excepciones si hay alg\u00fan error. Fichero test/Models/EquipoTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 package models ; public class EquipoTest { static Database db ; static private Injector injector ; // Se ejecuta s\u00f3lo una vez, al principio de todos los tests @BeforeClass static public void initApplication () { // Creamos la aplicaci\u00f3n a partir del fichero de configuraci\u00f3n. // El fichero de configuraci\u00f3n se puede cambiar en el comando // para lanzar sbt y los tests: // sbt ; set javaOptions += -Dconfig.file=conf/develop-mysql.conf ; testOnly models.EquipoTest* GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); // Obtenemos la base de datos utilizada por la aplicaci\u00f3n db = injector . instanceOf ( Database . class ); // Necesario para inicializar JPA injector . instanceOf ( JPAApi . class ); } @Before public void initData () throws Exception { // Creamos la base de datos de test y le asignamos el nombre JNDI DBTodoList JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTodoList ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/test_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } @Test public void testEqualsEquiposConId () { Equipo equipo1 = new Equipo ( Equipo A ); Equipo equipo2 = new Equipo ( Equipo B ); Equipo equipo3 = new Equipo ( Equipo C ); equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); assertEquals ( equipo1 , equipo2 ); assertNotEquals ( equipo1 , equipo3 ); } @Test public void testEqualsEquiposSinId () { Equipo equipo1 = new Equipo ( Equipo A ); Equipo equipo2 = new Equipo ( Equipo A ); Equipo equipo3 = new Equipo ( Equipo B ); assertEquals ( equipo1 , equipo2 ); assertNotEquals ( equipo1 , equipo3 ); } @Test public void testAddEquipoJPARepositoryInsertsEquipoDatabase () { EquipoRepository equipoRepository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = new Equipo ( Equipo A ); equipo = equipoRepository . add ( equipo ); Logger . info ( N\u00famero de tarea: + Long . toString ( equipo . getId ())); assertNotNull ( equipo . getId ()); assertEquals ( Equipo A , getNombreFromEquipoDB ( equipo . getId ())); } private String getNombreFromEquipoDB ( Long equipoId ) { String titulo = db . withConnection ( connection - { String selectStatement = SELECT NOMBRE FROM Equipo WHERE ID = ? ; PreparedStatement prepStmt = connection . prepareStatement ( selectStatement ); prepStmt . setLong ( 1 , equipoId ); ResultSet rs = prepStmt . executeQuery (); rs . next (); return rs . getString ( NOMBRE ); }); return titulo ; } @Test public void testFindEquipoPorId () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = repository . findById ( 1003L ); assertEquals ( Equipo A , equipo . getNombre ()); } @Test public void testUpdateEquipo () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = new Equipo ( Equipo B ); equipo . setId ( 1003L ); repository . update ( equipo ); Equipo equipoActualizado = repository . findById ( 1003L ); assertEquals ( Equipo B , equipo . getNombre ()); } @Test public void testDeleteEquipo () { EquipoRepository repository = injector . instanceOf ( EquipoRepository . class ); Equipo equipo = repository . findById ( 1003L ); repository . delete ( equipo ); equipo = repository . findById ( 1003L ); assertNull ( equipo ); } @Test public void testAddUsuarioEquipo () { EquipoRepository equipoRepository = injector . instanceOf ( EquipoRepository . class ); UsuarioRepository usuarioRepository = injector . instanceOf ( UsuarioRepository . class ); Equipo equipo = equipoRepository . findById ( 1005L ); Usuario usuario = usuarioRepository . findById ( 1005L ); equipoRepository . addUsuarioEquipo ( usuario , equipo ); // Recuperamos las entidades de la base de datos y comprobamos // que los datos se han actualizado List Usuario usuarios = equipoRepository . findUsuariosEquipo ( equipo . getId ()); assertEquals ( 1 , usuarios . size ()); Usuario usuarioBD = usuarioRepository . findById ( 1005L ); assertEquals ( 2 , usuarioBD . getEquipos (). size ()); } } Fichero test/services/EquipoService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package services ; public class EquipoServiceTest { static private Injector injector ; @BeforeClass static public void initApplication () { GuiceApplicationBuilder guiceApplicationBuilder = new GuiceApplicationBuilder (). in ( Environment . simple ()); injector = guiceApplicationBuilder . injector (); injector . instanceOf ( JPAApi . class ); } @Before public void initData () throws Exception { JndiDatabaseTester databaseTester = new JndiDatabaseTester ( DBTodoList ); IDataSet initialDataSet = new FlatXmlDataSetBuilder (). build ( new FileInputStream ( test/resources/test_dataset.xml )); databaseTester . setDataSet ( initialDataSet ); databaseTester . setSetUpOperation ( DatabaseOperation . CLEAN_INSERT ); databaseTester . onSetup (); } @Test public void listaEquipos () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); List Equipo equipos = equipoService . allEquipos (); assertEquals ( 3 , equipos . size ()); } @Test public void addUsuarioEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . addUsuarioEquipo ( 1000L , 1005L ); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); List Equipo equipos = new ArrayList ( usuario . getEquipos ()); assertEquals ( 3 , equipos . size ()); } @Test public void getUsuariosEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); List Usuario usuarios = equipoService . findUsuariosEquipo ( 1003L ); assertEquals ( 2 , usuarios . size ()); Usuario usuario = usuarioService . findUsuarioPorLogin ( anagarcia ); assertEquals ( 1 , usuario . getEquipos (). size ()); } @Test public void deleteUsuarioEquipo () { EquipoService equipoService = injector . instanceOf ( EquipoService . class ); UsuarioService usuarioService = injector . instanceOf ( UsuarioService . class ); equipoService . deleteUsuarioEquipo ( 1000L , 1003L ); List Usuario usuarios = equipoService . findUsuariosEquipo ( 1003L ); assertEquals ( 1 , usuarios . size ()); Usuario usuario = usuarioService . findUsuarioPorLogin ( juangutierrez ); assertEquals ( 1 , usuario . getEquipos (). size ()); } } Tecnolog\u00edas usadas Play Framework Play Framework es un framework de desarrollo r\u00e1pido de aplicaciones web disponible en los lenguajes Java y Scala. Vamos a utilizar la versi\u00f3n Java. El framework proporciona un soporte de ejecuci\u00f3n que tiene como base el servidor Netty . Con este soporte es posible dise\u00f1ar y poner en marcha distintos tipos de aplicaciones: servicios HTTP, servicios HTTP as\u00edncronos basados en websockets, aplicaciones as\u00edncronas basadas en eventos, etc. Nosotros vamos a implementar una aplicaci\u00f3n tradicional que implementa un servicio HTTP. Vamos a utilizar la versi\u00f3n 2.5 en Java . Para entender el funcionamiento de esta primera pr\u00e1ctica es necesario consultar la siguiente documentaci\u00f3n del framework: Sobre el funcionamiento de Play: Using the Play console Anatomy of a Play application Sobre peticiones y respuestas HTTP: Actions, Controllers and Results HTTP routing Session and Flash scope Sobre plantillas: The template engine Common template use cases Sobre env\u00edo de datos de formularios: Handling form submission Rendering an element Sobre el acceso a base de datos y JPA Acceso a base de datos SQL Integrating with JPA Sobre la inyecci\u00f3n de dependencias Dependency Injection Sobre los tests en Play: Testing your application Sobre la configuraci\u00f3n de la aplicaci\u00f3n Play: Configuraci\u00f3n Java Persistence API (JPA) JPA es el API que utilizaremos para acceder a bases de datos y gestionar entidades persistentes usando un modelo ORM ( Object Relational Mapping ). Est\u00e1 integrado en Play, no es necesario instalar ninguna librer\u00eda adicional. JPA tambi\u00e9n es conocido por el nombre de una de sus implementaciones m\u00e1s populares, Hibernate. Es una tecnolog\u00eda muy usada y madura en el mundo Java. Permite gestionar la persistencia directamente con el modelo de objetos de la aplicaci\u00f3n (se denominan entidades ), independiz\u00e1ndola del modelo relacional basado en tablas y registros. La implementaci\u00f3n de JPA ObjectDB tiene unos tutoriales muy completos y accesibles: JPA Quick tour Entity classes Using JPA JPA Queries No es necesario estudiar todos los tutoriales. El objetivo de las pr\u00e1cticas no es aprender JPA, sino desarrollar de forma \u00e1gil una aplicaci\u00f3n. Vamos a utilizar lo m\u00e1s b\u00e1sico de JPA y en la mayor\u00eda de las ocasiones se va a proporcionar el c\u00f3digo necesario. Adem\u00e1s, en caso de duda, siempre podr\u00e1s realizar preguntas sobre c\u00f3mo implementar una determinada funcionalidad en el foro de Moodle. La implementaci\u00f3n de JPA que se utiliza en PlayFramework 2.5 es Hibernate 5.1.0.Final. Puedes encontrar toda la informaci\u00f3n sobre esta implementaci\u00f3n en la gu\u00eda de usuario: Hibernate ORM 5.1 User Guide Bootstrap Para hacer m\u00e1s atractivo el dise\u00f1o de las p\u00e1ginas HTML vamos a usuar el framework CSS Bootstrap . Es conveniente tener a mano su documentaci\u00f3n, en concreto la lista de componentes: Bootstrap components","title":"Introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS #"},{"location":"01-introduccion-play/intro-play-teoria.html#introduccion-a-play-framework-para-las-practicas-de-mads","text":"Vamos a ver c\u00f3mo lanzar y desarrollar una aplicaci\u00f3n Play Framework en Java. Presentaremos las principales caracter\u00edsticas de este framework de desarrollo de aplicaciones web mediante ejemplos concretos de c\u00f3digo que vamos a utilizar en las pr\u00e1cticas de la asignatura.","title":"Introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS"},{"location":"01-introduccion-play/intro-play-teoria.html#aplicacion-play-proyecto-inicial","text":"","title":"Aplicaci\u00f3n play-proyecto-inicial"},{"location":"01-introduccion-play/intro-play-teoria.html#descarga-de-la-aplicacion","text":"La aplicaci\u00f3n play-proyecto-inicial se encuentra en GitHub: https://github.com/domingogallardo/play-proyecto-inicial . Es un esqueleto de aplicaci\u00f3n Play con ejemplos b\u00e1sicos del funcionamiento del framework. Puedes descargarla usando el comando git clone : 1 $ git clone https://github.com/domingogallardo/play-proyecto-inicial.git Se crear\u00e1 el directorio play-proyecto-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n Play.","title":"Descarga de la aplicaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria.html#uso-de-intellij-para-trabajar-con-la-aplicacion-play","text":"Aunque es posible trabajar con editores como Visual Studio Code , vamos a explicar c\u00f3mo desarrollar las aplicaciones Play usando el IDE IntelliJ IDEA. Las aplicaciones Play se pueden escribir en Java y en Scala. Nosotros usaremos Java. Una parte importante de las librer\u00edas del framework est\u00e1n escritas en Scala, por lo que debe estar instalado el plugin de Scala en IntelliJ. Se debe importar el proyecto usando la opci\u00f3n sbt , la herramienta de build que usa Play. Sbt es una herramienta similar a Maven para Java, es la herramienta que se usa para construir proyectos Scala. El fichero de configuraci\u00f3n de un proyecto sbt es el fichero build.sbt situado en el directorio ra\u00edz. Para compilar los proyectos tambi\u00e9n es necesario tener instalado JDK. Nos aseguramos de que aparece en el panel de importaci\u00f3n. Si no, seleccionamos el directorio donde se encuentra la versi\u00f3n del JDK que vamos a utilizar. Es conveniente activar la auto-importaci\u00f3n del proyecto sbt. De esta forma, si IntelliJ detecta alg\u00fan cambio en la configuraci\u00f3n sbt realiza la importaci\u00f3n de forma autom\u00e1tica. Si se pincha en el icono de la esquina inferior izquierda de la ventana de IntelliJ podremos activar o desactivar la visualizaci\u00f3n de los nombres de los paneles en los bordes de la ventana. Es recomendable dejarlos visibles. Utilizaremos el panel Terminal para trabajar con sbt y con git . Es recomendable abrir dos tabs, uno para cada cosa.","title":"Uso de IntelliJ para trabajar con la aplicaci\u00f3n Play"},{"location":"01-introduccion-play/intro-play-teoria.html#uso-de-visual-studio-code-para-trabajar-con-la-aplicacion-play","text":"Si no es posible utilizar un editor avanzado como IntelliJ es posible usar en su lugar Visual Studio Code . Abre la carpeta con el directorio del proyecto y abre un terminal con la opci\u00f3n Ver Terminal integrado . En ese terminal lanzaremos el comando Docker para trabajar con sbt . Puedes abrir otro terminal pulsando en el s\u00edmbolo + para trabajar con Git.","title":"Uso de Visual Studio Code para trabajar con la aplicaci\u00f3n Play"},{"location":"01-introduccion-play/intro-play-teoria.html#lanzar-la-aplicacion-play","text":"Podemos ejecutar la aplicaci\u00f3n Play de tres formas. Utilizaremos las tres a lo largo de las pr\u00e1cticas. Usando una m\u00e1quina Docker. Usando el sbt shell que proporciona IntelliJ. Usando la configuraci\u00f3n de ejecuci\u00f3n de IntelliJ.","title":"Lanzar la aplicaci\u00f3n Play"},{"location":"01-introduccion-play/intro-play-teoria.html#fichero-routes","text":"El routes , situado en el directorio conf , especifica el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Fichero conf/routes : 1 2 3 4 5 6 7 8 9 10 11 12 13 # Routes # This file defines all application routes (Higher priority routes first) # ~~~~ # An example controller showing a sample home page GET / controllers.HomeController.index # An example controller showing how to use dependency injection GET /count controllers.CountController.count # An example controller showing how to write asynchronous code GET /message controllers.AsyncController.message # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Por ejemplo, cuando se recibe la petici\u00f3n GET / (cuando en el navegador escribimos la URL http::/localhost/ ) se ejecutar\u00e1 el m\u00e9todo index de la clase controllers.HomeController . O cuando desde el navegador accedamos a la URL http://localhost/count se generar\u00e1 la petici\u00f3n GET /count y se ejecutar\u00e1 el m\u00e9todo count de la clase controllers.CountController .","title":"Fichero routes"},{"location":"01-introduccion-play/intro-play-teoria.html#controllers","text":"El c\u00f3digo a ejecutar cuando se realiza una petici\u00f3n HTTP se define en m\u00e9todos de clases que heredan de Controller . Se suelen colocar en el paquete controllers . Por ejemplo, en la clase controllers.HomeController se define el m\u00e9todo index . Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 public class HomeController extends Controller { /** * An action that renders an HTML page with a welcome message. * The configuration in the code routes /code file means that * this method will be called when the application receives a * code GET /code request with a path of code / /code . */ public Result index () { return ok ( index . render ( Your new application is ready. )); } } Los m\u00e9todos de las clases Controller deben devolver un objeto Result que representa la respuesta HTTP a la petici\u00f3n. En el caso anterior se devuelve un OK (c\u00f3digo HTTP 200) junto con el c\u00f3digo HTML resultante de renderizar la vista index .","title":"Controllers"},{"location":"01-introduccion-play/intro-play-teoria.html#vistas","text":"Las p\u00e1ginas HTML que se devuelven se construyen mediante vistas . Las vistas se definen mediante plantillas Scala definidas en el directorio views . En la llamada a renderizar la vista se pueden pasar par\u00e1metros cuyos valores se utilizan en la propia vista. Por ejemplo, la vista anterior index se define en el fichero index.scala.html situado en el directorio views . Fichero views/index.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @* * This template takes a single argument, a String containing a * message to display. *@ @(message: String) @* * Call the `main` template with two arguments. The first * argument is a `String` with the title of the page, the second * argument is an `Html` object containing the body of the page. *@ @main( Welcome to Play ) { @* * Get an `Html` object by calling the built-in Play welcome * template and passing a `String` message. *@ @welcome(message, style = java ) } La vista recibe un par\u00e1metro String . En el cuerpo de la vista se puede escribir c\u00f3digo HTML, c\u00f3digo Scala, y tambi\u00e9n llamar a otras plantillas. Por ejemplo, en la vista anterior se llama a la plantilla main que se define en el fichero main.scala.html , pas\u00e1ndole como par\u00e1metro el c\u00f3digo HTML generado por la plantilla welcome , definida en el fichero welcome.scala.html . Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String)(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body @* And here s where we render the `Html` object containing * the page content. *@ @content / body / html Fichero views/welcome.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @(message: String, style: String = java ) @defining(play.core.PlayVersion.current) { version = link rel = stylesheet media = screen href = /@@documentation/resources/style/main.css section id = top div class = wrapper h1 a href = https://playframework.com/documentation/@version/Home @message / a / h1 / div / section div id = content class = wrapper doc article h1 Welcome to Play / h1 p Congratulations, you\u2019ve just created a new Play application. This page will help you with the next few steps. / p blockquote p You\u2019re using Play @version / p / blockquote ... } Para incorporar el valor del par\u00e1metro en la plantilla hay que preceder el par\u00e1metro con @ . En el ejemplo anterior se obtiene as\u00ed el mensaje, que se pinta en la parte superior de la p\u00e1gina. La p\u00e1gina HTML resultante mostrada en el navegador es la siguiente: La directiva @defining permite obtener un valor y asign\u00e1rselo a una variable que se utiliza en un bloque de c\u00f3digo. En el caso anterior se utiliza para obtener la versi\u00f3n de Play. Otro ejemplo de su utilizaci\u00f3n es el que aparece en la documentaci\u00f3n de Play sobre plantillas: 1 2 3 @defining(user.getFirstName() + + user.getLastName()) { fullName = div Hello @fullName / div }","title":"Vistas"},{"location":"01-introduccion-play/intro-play-teoria.html#inyeccion-de-dependencias","text":"Play usa el framework Java de Google Guice para realizar inyecci\u00f3n de dependencias. La anotaci\u00f3n @Inject hace que Play inyecte en la variable anotada un objeto nuevo del tipo indicado por la variable. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Es posible definir singletons con la anotaci\u00f3n @Singleton . En la aplicaci\u00f3n ejemplo se define un servicio y un controller para implementar un contador que se incrementa en cada petici\u00f3n a la acci\u00f3n count . En el controller se inyecta el componente counter : Fichero controllers/CountController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package controllers ; import javax.inject.* ; import play.mvc.* ; import services.Counter ; @Singleton public class CountController extends Controller { private final Counter counter ; @Inject public CountController ( Counter counter ) { this . counter = counter ; } /** * An action that responds with the {@link Counter} s current * count. The result is plain text. This action is mapped to * code GET /code requests with a path of code /count /code * requests by an entry in the code routes /code config file. */ public Result count () { return ok ( Integer . toString ( counter . nextCount ())); } } El contador se define con una interfaz y una implementaci\u00f3n concreta. Fichero services/Counter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 package services ; /** * This interface demonstrates how to create a component that is injected * into a controller. The interface represents a counter that returns a * incremented number each time it is called. * * The {@link Modules} class binds this interface to the * {@link AtomicCounter} implementation. */ public interface Counter { int nextCount (); } Fichero services/AtomicCounter.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package services ; import java.util.concurrent.atomic.AtomicInteger ; import javax.inject.* ; /** * This class is a concrete implementation of the {@link Counter} trait. * It is configured for Guice dependency injection in the {@link Module} * class. * * This class has a {@link Singleton} annotation because we need to make * sure we only use one counter per application. Without this * annotation we would get a new instance every time a {@link Counter} is * injected. */ @Singleton public class AtomicCounter implements Counter { private final AtomicInteger atomicCounter = new AtomicInteger (); @Override public int nextCount () { return atomicCounter . getAndIncrement (); } } La definici\u00f3n de la clase concreta que se inyecta se realiza en el m\u00e9todo configure() de una clase llamada Module que debe extender AbstractModule y estar situada en el paquete ra\u00edz. Fichero Module.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import com.google.inject.AbstractModule ; import services.AtomicCounter ; import services.Counter ; /** * This class is a Guice module that tells Guice how to bind several * different types. This Guice module is created when the Play * application starts. * * Play will automatically use any class called `Module` that is in * the root package. You can create modules in other locations by * adding `play.modules.enabled` settings to the `application.conf` * configuration file. */ public class Module extends AbstractModule { @Override public void configure () { // Set AtomicCounter as the implementation for Counter. bind ( Counter . class ). to ( AtomicCounter . class ); } }","title":"Inyecci\u00f3n de dependencias"},{"location":"01-introduccion-play/intro-play-teoria.html#tests","text":"Los tests se encuentran en el directorio tests . Se utiliza JUnit como framework de testing. Desde los tests se puede comprobar los distintos componentes de la aplicaci\u00f3n, incluyendo plantillas y peticiones a controllers.","title":"Tests"},{"location":"01-introduccion-play/intro-play-teoria.html#aplicacion-mads-todolist-inicial","text":"La aplicaci\u00f3n mads-todolist-inicial es una versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante todo el cuatrimestre en la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista anteriormente. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP en el fichero de rutas: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban sobre todo la capa de servicios. Distintos ficheros de configuraci\u00f3n para poder arrancar la aplicaci\u00f3n en distintos entornos: desarrollo, integraci\u00f3n y stage (similar a producci\u00f3n). A continuaci\u00f3n se muestran dos de sus pantallas. Pantalla de login Pantalla con listado de tareas","title":"Aplicaci\u00f3n mads-todolist-inicial"},{"location":"01-introduccion-play/intro-play-teoria.html#descarga-de-la-aplicacion-mads-todolist-inicial","text":"Se encuentra en GitHub: https://github.com/domingogallardo/mads-todolist-inicial . Puedes descargarla con el comando git clone : 1 $ git clone https://github.com/domingogallardo/mads-todolist-inicial.git Se crear\u00e1 el directorio mads-todolist-inicial en el que se habr\u00e1 descargado la aplicaci\u00f3n.","title":"Descarga de la aplicaci\u00f3n mads-todolist-inicial"},{"location":"01-introduccion-play/intro-play-teoria.html#importacion-en-intellj-idea","text":"Al importar la aplicaci\u00f3n en IntelliJ IDEA aparece el aviso de que se ha detectado el framework JPA y da la opci\u00f3n de configurarlo. La configuraci\u00f3n es sencilla, s\u00f3lo hay que aceptar la localizaci\u00f3n del fichero persistence.xml que nos muestra la ventana de di\u00e1logo. Hablaremos m\u00e1s adelante de JPA.","title":"Importaci\u00f3n en IntellJ IDEA"},{"location":"01-introduccion-play/intro-play-teoria.html#ejecucion-de-la-aplicacion-usando-la-base-de-datos-en-memoria","text":"Si ejecutamos la aplicaci\u00f3n usando el comando docker run ya visto se utilizar\u00e1 la base de datos H2 en memoria. Los datos almacenados en ella s\u00f3lo durar\u00e1n mientras que est\u00e1 en marcha el contenedor. 1 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework","title":"Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos en memoria"},{"location":"01-introduccion-play/intro-play-teoria.html#base-de-datos-mysql-con-docker","text":"Si queremos que los datos introducidos persistan a distintas activaciones de la aplicaci\u00f3n web debemos usar una base de datos externa. Esto es necesario cuando la aplicaci\u00f3n est\u00e9 en producci\u00f3n, pero tambi\u00e9n puede ser \u00fatil para realizar pruebas manuales en desarrollo. Podemos utilizar Docker para poner en marcha un servidor MySQL con el siguiente comando: 1 $ docker run -d -p 3316:3306 --name db-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 El comando pone en marcha un servidor MySQL escuchando en el puerto 3316 del host con el nombre docker db-mysql , con la contrase\u00f1a de root indicada y creando la base de datos mads . El puerto del host 3316 se mapea con el puerto interno del contenedor 3306. Ponemos el puerto 3316 para evitar posibles conflictos con un posible servidor de MySQL que tengamos funcionando en el host. Cuidado En los laboratorios de la EPS est\u00e1 instalada la imagen 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Podemos comprobar que el contenedor est\u00e1 funcionando con el comando docker container ls : 1 2 3 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7c1bed0b5b7e mysql docker-entrypoint... 6 seconds ago Up 4 seconds 0.0.0.0:3316- 3306/tcp db-mysql Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop container-id y docker start container-id . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls lista los contenedores en marcha, y con la opci\u00f3n -a tambi\u00e9n los parados. 1 2 3 4 5 6 7 8 9 10 11 $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060/tcp, 0.0.0.0:3316- 3306/tcp db-mysql $ docker container stop bd057639b6ac $ docker container ls -a CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited (0) 7 seconds ago db-mysql $ docker container start bd057639b6ac $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060/tcp, 0.0.0.0:3316- 3306/tcp db-mysql Podemos usar el identificador o el nombre del contenedor para pararlo: 1 $ docker container stop db-mysql Para borrar un contenedor debe estar parado y debemos usar el comando 1 docker container rm container-id o container-name","title":"Base de datos MySQL con Docker"},{"location":"01-introduccion-play/intro-play-teoria.html#ejecucion-de-la-aplicacion-usando-la-base-de-datos-mysql","text":"","title":"Ejecuci\u00f3n de la aplicaci\u00f3n usando la base de datos MySQL"},{"location":"01-introduccion-play/intro-play-teoria.html#panel-database-de-intellij","text":"Desde el panel Database de IntelliJ (en la esquina superior derecha) es posible crear una conexi\u00f3n a la base de datos que nos permitir\u00e1 verificar c\u00f3mo se guardan los datos de la aplicaci\u00f3n. Hay que a\u00f1adir una base de datos de tipo MySQL y configurarla con los siguientes par\u00e1metros: Cuidado Igual que en el apartado anterior, si est\u00e1s lanzando MySQL usando Docker Toolbox debes indicar el host al que conectarse (no ser\u00e1 localhost ) escribiendo la direcci\u00f3n IP que aparece en la consola de docker al arrancar. Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto:","title":"Panel Database de IntelliJ"},{"location":"01-introduccion-play/intro-play-teoria.html#configuracion-de-la-aplicacion","text":"Los distintos par\u00e1metros de la aplicaci\u00f3n Play se configuran en un fichero de propiedades.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"01-introduccion-play/intro-play-teoria.html#gestion-de-persistencia-con-jpa","text":"Para la gesti\u00f3n de la persistencia de los datos en una aplicaci\u00f3n Play usaremos JPA ( Java Persistence API ), en concreto la implementaci\u00f3n 5.2.5 de Hibernate.","title":"Gesti\u00f3n de persistencia con JPA"},{"location":"01-introduccion-play/intro-play-teoria.html#servicios","text":"La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es obtener o crear los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Fichero services/UsuarioService.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class UsuarioService { UsuarioRepository repository ; // Play proporcionar\u00e1 autom\u00e1ticamente el UsuarioRepository necesario // usando inyecci\u00f3n de dependencias @Inject public UsuarioService ( UsuarioRepository repository ) { this . repository = repository ; } public Usuario creaUsuario ( String login , String email , String password ) { if ( repository . findByLogin ( login ) != null ) { throw new UsuarioServiceException ( Login ya existente ); } Usuario usuario = new Usuario ( login , email ); usuario . setPassword ( password ); return repository . add ( usuario ); } public Usuario findUsuarioPorLogin ( String login ) { return repository . findByLogin ( login ); } public Usuario findUsuarioPorId ( Long id ) { return repository . findById ( id ); } public Usuario login ( String login , String password ) { Usuario usuario = repository . findByLogin ( login ); if ( usuario != null usuario . getPassword (). equals ( password )) { return usuario ; } else { return null ; } } } Fichero services/UsuarioServiceException.java : 1 2 3 4 5 6 7 8 9 public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException () { } public UsuarioServiceException ( String message ) { super ( message ); } }","title":"Servicios"},{"location":"01-introduccion-play/intro-play-teoria.html#controllers_1","text":"Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen tres clases controller: UsuarioController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. EquipoController : con m\u00e9todos para crear, a\u00f1adir usuarios y listar equipos. Por ejemplo, la clase EquipoController define las acciones relacionadas con crear equipos de usuarios. En este controlador se obtienen los datos del formulario de la petici\u00f3n HTTP usando un DynamicForm que contiene todos los valores (Strings) asociados a los datos del formulario. Tambi\u00e9n es posible realizar un mapping autom\u00e1tico entre los datos de un formulario y un objeto Java usando un objeto Form . En el UsuarioController se puede ver un ejemplo que usa las clases Login y Registro . En este caso es posible definir restricciones en los atributos y realizar una validaci\u00f3n en el servidor. Fichero controllers/EquipoController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; public class EquipoController extends Controller { @Inject FormFactory formFactory ; @Inject EquipoService equipoService ; @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioNuevoEquipo () { return ok ( formNuevoEquipo . render ( )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result creaNuevoEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String nombre = requestData . get ( nombre ); if ( nombre == null || nombre . equals ( )) { return badRequest ( formNuevoEquipo . render ( Debes rellenar el nombre )); } equipoService . addEquipo ( nombre ); return ok ( Equipo + nombre + a\u00f1adido correctamente ); } public Result listaEquipos () { List Equipo equipos = equipoService . allEquipos (); return ok ( listaEquipos . render ( equipos )); } @Security.Authenticated ( ActionAuthenticator . class ) public Result formularioAddUsuarioEquipo () { return ok ( formEquipoUsuario . render ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result addUsuarioEquipo () { DynamicForm requestData = formFactory . form (). bindFromRequest (); String equipo = requestData . get ( equipo ); String usuario = requestData . get ( usuario ); try { equipoService . addUsuarioEquipo ( usuario , equipo ); return ok ( Usuario + usuario + a\u00f1adido al equipo + equipo ); } catch ( EquipoServiceException exception ) { return notFound ( No existe usuario / equipo ); } } } La clase UsuarioController se encarga de las acciones de registro y login. Fichero controllers/UsuarioController.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package controllers ; public class UsuarioController extends Controller { @Inject FormFactory formFactory ; // Play injecta un usuarioService junto con todas las dependencias necesarias: // UsuarioRepository y JPAApi @Inject UsuarioService usuarioService ; public Result saludo ( String mensaje ) { return ok ( saludo . render ( El mensaje que he recibido es: + mensaje )); } public Result formularioRegistro () { return ok ( formRegistro . render ( formFactory . form ( Registro . class ), )); } public Result registroUsuario () { Form Registro form = formFactory . form ( Registro . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formRegistro . render ( form , Hay errores en el formulario )); } Registro datosRegistro = form . get (); if ( usuarioService . findUsuarioPorLogin ( datosRegistro . login ) != null ) { return badRequest ( formRegistro . render ( form , Login ya existente: escoge otro )); } if (! datosRegistro . password . equals ( datosRegistro . confirmacion )) { return badRequest ( formRegistro . render ( form , No coinciden la contrase\u00f1a y la confirmaci\u00f3n )); } Usuario usuario = usuarioService . creaUsuario ( datosRegistro . login , datosRegistro . email , datosRegistro . password ); return redirect ( controllers . routes . UsuarioController . formularioLogin ()); } public Result formularioLogin () { return ok ( formLogin . render ( formFactory . form ( Login . class ), )); } public Result loginUsuario () { Form Login form = formFactory . form ( Login . class ). bindFromRequest (); if ( form . hasErrors ()) { return badRequest ( formLogin . render ( form , Hay errores en el formulario )); } Login login = form . get (); Usuario usuario = usuarioService . login ( login . username , login . password ); if ( usuario == null ) { return notFound ( formLogin . render ( form , Login y contrase\u00f1a no existentes )); } else { // A\u00f1adimos el id del usuario a la clave `connected` de // la sesi\u00f3n de Play // https://www.playframework.com/documentation/2.5.x/JavaSessionFlash // Esa clave es la usada en la autenticaci\u00f3n session ( connected , usuario . getId (). toString ()); return redirect ( controllers . routes . TareasController . listaTareas ( usuario . getId ())); } } // Comprobamos si hay alguien logeado con @Security.Authenticated(ActionAuthenticator.class) // https://alexgaribay.com/2014/06/15/authentication-in-play-framework-using-java/ @Security.Authenticated ( ActionAuthenticator . class ) public Result logout () { session (). remove ( connected ); return redirect ( controllers . routes . UsuarioController . loginUsuario ()); } @Security.Authenticated ( ActionAuthenticator . class ) public Result detalleUsuario ( Long id ) { String connectedUserStr = session ( connected ); Long connectedUser = Long . valueOf ( connectedUserStr ); if ( connectedUser != id ) { return unauthorized ( Lo siento, no est\u00e1s autorizado ); } else { Usuario usuario = usuarioService . findUsuarioPorId ( id ); if ( usuario == null ) { return notFound ( Usuario no encontrado ); } else { Logger . debug ( Encontrado usuario + usuario . getId () + : + usuario . getLogin ()); return ok ( detalleUsuario . render ( usuario )); } } } } Para mapear los datos de los formularios se usan las clases Login y Registro . Fichero controllers/Login.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package controllers ; import play.data.validation.Constraints ; public class Login { @Constraints.Required public String username ; @Constraints.Required public String password ; public String getUsername () { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Fichero controllers/Registro.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package controllers ; import play.data.validation.Constraints ; public class Registro { @Constraints.Required public String login ; @Constraints.Required @Constraints.Email public String email ; @Constraints.Required public String password ; @Constraints.Required public String confirmacion ; public String getLogin () { return login ; } public void setLogin ( String login ) { this . login = login ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getConfirmacion () { return confirmacion ; } public void setConfirmacion ( String confirmacion ) { this . confirmacion = confirmacion ; } }","title":"Controllers"},{"location":"01-introduccion-play/intro-play-teoria.html#vistas_1","text":"Todas las vistas de la aplicaci\u00f3n usan como plantilla base la vista main.scala.html , en la que se carga el framework CSS Bootstrap y la librer\u00eda JavaScript JQuery . Ambos se encuentran en el directorio public , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Play. Es importante hacer notar que se obtiene la ruta absoluta a los ficheros est\u00e1ticos llamando a routes.Assets.versioned con su ruta relativa. De esta forma se modificar el directorio por defecto en el que se guardan los recursos est\u00e1ticos sin afectar a la aplicaci\u00f3n. A la plantilla main se le pasa el t\u00edtulo de la p\u00e1gina, scripts JavaScript (por defecto vac\u00edo) y un contenido HTML que se inserta en el cuerpo principal. Fichero views/main.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @* * This template is called from the `index` template. This template * handles the rendering of the page header and body tags. It takes * two arguments, a `String` for the title of the page and an `Html` * object to insert into the body of the page. *@ @(title: String, scripts: Html = Html( ))(content: Html) !DOCTYPE html html lang = en head @* Here s where we render the page title `String`. *@ title @title / title link href = @routes.Assets.versioned( bootstrap / css / bootstrap . min . css ) rel = stylesheet media = screen link rel = stylesheet media = screen href = @routes.Assets.versioned( stylesheets / main . css ) link rel = shortcut icon type = image/png href = @routes.Assets.versioned( images / favicon . png ) script src = @routes.Assets.versioned( javascripts / hello . js ) type = text/javascript / script / head body div class = container @content / div script src = @routes.Assets.versioned( javascripts / jquery . min . js ) type = text/javascript / script script src = @routes.Assets.versioned( bootstrap / js / bootstrap . min . js ) type = text/javascript / script @scripts / body / html Un ejemplo del uso de esta plantilla es la plantilla principal del listado de tareas. Se trata de una plantilla compleja, con bastantes ejemplos de c\u00f3mo usar los distintos elementos de Play: La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n for para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se usan enlaces a las URLs definidas por rutas inversas. Fichero views/listaTareas.scala.html : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @(tareas: List[Tarea], usuario: Usuario, mensaje: String) @scripts = { script type = text/javascript function del ( urlBorrar ) { $ . ajax ({ url : urlBorrar , type : DELETE , success : function ( results ) { //refresh the page location . reload (); } }); } / script } @main( Tareas del usuario @usuario.getLogin() , scripts) { h2 Listado de tareas de @usuario.getLogin() / h2 table class = table table-striped tr th Tareas / th th Acci\u00f3n / th / tr @for(tarea - tareas ) { tr td @tarea.getTitulo() / td td a href = @routes.TareasController.formularioEditaTarea(tarea.getId()) span class = glyphicon glyphicon-pencil / span nbsp; / a a onmouseover = style = cursor: pointer; onclick = del( @routes.TareasController.borraTarea(tarea.getId()) ) span class = glyphicon glyphicon-trash aria-hidden = true / span / a / td / tr } tr td a href = @routes.TareasController.formularioNuevaTarea(usuario.getId()) span class = glyphicon glyphicon-plus / / a / td td a href = @routes.UsuarioController.logout() Salir / a / td / tr / table @if(mensaje != null) { div class = alert alert-success role = alert button type = button class = close data-dismiss = alert aria-label = Close span aria-hidden = true times; / span / button @mensaje / div } }","title":"Vistas"},{"location":"01-introduccion-play/intro-play-teoria.html#tests_1","text":"La mayor\u00eda de los tests que contiene la aplicaci\u00f3n son tests de integraci\u00f3n, en los que no se usan mocks , sino que se comprueba el funcionamiento de la capa de servicio y la de repositorio. Como framework de testing se usa JUnit . Los datos de prueba en las tablas de la base de datos se definen y se cargan usando DBUnit . Por ejemplo, la clase models.EquipoTest contiene tests para el modelo Equipo y el EquipoRepository . Los tests se realizar\u00e1n utilizando la base de datos definida en el fichero de configuraci\u00f3n. En el fichero de configuraci\u00f3n por defecto ( conf/application.conf ) se define la base de datos de memoria H2 .","title":"Tests"},{"location":"01-introduccion-play/intro-play-teoria.html#tecnologias-usadas","text":"","title":"Tecnolog\u00edas usadas"},{"location":"01-introduccion-play/intro-play-teoria.html#play-framework","text":"Play Framework es un framework de desarrollo r\u00e1pido de aplicaciones web disponible en los lenguajes Java y Scala. Vamos a utilizar la versi\u00f3n Java. El framework proporciona un soporte de ejecuci\u00f3n que tiene como base el servidor Netty . Con este soporte es posible dise\u00f1ar y poner en marcha distintos tipos de aplicaciones: servicios HTTP, servicios HTTP as\u00edncronos basados en websockets, aplicaciones as\u00edncronas basadas en eventos, etc. Nosotros vamos a implementar una aplicaci\u00f3n tradicional que implementa un servicio HTTP. Vamos a utilizar la versi\u00f3n 2.5 en Java . Para entender el funcionamiento de esta primera pr\u00e1ctica es necesario consultar la siguiente documentaci\u00f3n del framework: Sobre el funcionamiento de Play: Using the Play console Anatomy of a Play application Sobre peticiones y respuestas HTTP: Actions, Controllers and Results HTTP routing Session and Flash scope Sobre plantillas: The template engine Common template use cases Sobre env\u00edo de datos de formularios: Handling form submission Rendering an element Sobre el acceso a base de datos y JPA Acceso a base de datos SQL Integrating with JPA Sobre la inyecci\u00f3n de dependencias Dependency Injection Sobre los tests en Play: Testing your application Sobre la configuraci\u00f3n de la aplicaci\u00f3n Play: Configuraci\u00f3n","title":"Play Framework"},{"location":"01-introduccion-play/intro-play-teoria.html#java-persistence-api-jpa","text":"JPA es el API que utilizaremos para acceder a bases de datos y gestionar entidades persistentes usando un modelo ORM ( Object Relational Mapping ). Est\u00e1 integrado en Play, no es necesario instalar ninguna librer\u00eda adicional. JPA tambi\u00e9n es conocido por el nombre de una de sus implementaciones m\u00e1s populares, Hibernate. Es una tecnolog\u00eda muy usada y madura en el mundo Java. Permite gestionar la persistencia directamente con el modelo de objetos de la aplicaci\u00f3n (se denominan entidades ), independiz\u00e1ndola del modelo relacional basado en tablas y registros. La implementaci\u00f3n de JPA ObjectDB tiene unos tutoriales muy completos y accesibles: JPA Quick tour Entity classes Using JPA JPA Queries No es necesario estudiar todos los tutoriales. El objetivo de las pr\u00e1cticas no es aprender JPA, sino desarrollar de forma \u00e1gil una aplicaci\u00f3n. Vamos a utilizar lo m\u00e1s b\u00e1sico de JPA y en la mayor\u00eda de las ocasiones se va a proporcionar el c\u00f3digo necesario. Adem\u00e1s, en caso de duda, siempre podr\u00e1s realizar preguntas sobre c\u00f3mo implementar una determinada funcionalidad en el foro de Moodle. La implementaci\u00f3n de JPA que se utiliza en PlayFramework 2.5 es Hibernate 5.1.0.Final. Puedes encontrar toda la informaci\u00f3n sobre esta implementaci\u00f3n en la gu\u00eda de usuario: Hibernate ORM 5.1 User Guide","title":"Java Persistence API (JPA)"},{"location":"01-introduccion-play/intro-play-teoria.html#bootstrap","text":"Para hacer m\u00e1s atractivo el dise\u00f1o de las p\u00e1ginas HTML vamos a usuar el framework CSS Bootstrap . Es conveniente tener a mano su documentaci\u00f3n, en concreto la lista de componentes: Bootstrap components","title":"Bootstrap"},{"location":"01-introduccion-play/introduccion-play.html","text":"Enunciado pr\u00e1ctica 1 1. Objetivos En la primera pr\u00e1ctica de la asignatura vamos a tomar contacto con el framework de desarrollo de aplicaciones web en Java Play Framework , trabajando sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Antes de comenzar la pr\u00e1ctica debes leer la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS . 1.1. Aplicaci\u00f3n inicial La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los empleados de una empresa. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. Tambi\u00e9n tiene unas funcionalidades iniciales b\u00e1sicas relacionadas con la gesti\u00f3n de equipos de usuarios, de las que s\u00f3lo se ha implementado el esqueleto, sin apenas interfaz de usuario. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List . 1.2. Metodolog\u00eda de desarrollo En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues , labels , milestones , etc. JUnit y DBUnit para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Algunos ejemplos de repositorios en GitHub: CartoDB Vapor Guice Play Framework swift-nio Git Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos ( Getting Started ) y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto. Flujo de trabajo Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos todos los instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: feature , bug y technical . Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama master haciendo un pull request . Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama master haciendo un pull request . Cuando se mezcle el PR en master el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues y pull requests de ese milestone ). Tablero de proyecto : Un tablero de proyecto nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue o PR: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar project boards . Wiki : Por \u00faltimo, GitHub ofrece una wiki en que utilizaremos para documentar las nuevas features (tambi\u00e9n llamadas funcionalidades o historias de usuario) a implementar. Consultar documenting your projects on GitHub . La documentaci\u00f3n en la Wiki, en los issues , en los PRs y en el propio README.md del proyecto hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack , Confluence o incluso Trello . Pero lo que nos ofrece GitHub es suficiente para lo que vamos a realizar en la asignatura y tiene la ventaja de estar integrado en una misma plataforma. 2. Entorno para realizar la pr\u00e1ctica Software necesario: Git Docker , para ejecutar la imagen (similar a una m\u00e1quina virtual) que contiene Java y Play Framework. En esta primera pr\u00e1ctica se utiliza para compilar y ejecutar los proyectos Play y para lanzar el servicio de base de datos MySQL. Como entorno de desarrollo proporcionamos dos opciones: Visual Studio Code : IDE para trabajar en el desarrollo del proyecto si no es posible usar IntelliJ. No tiene las funcionalidades de IntelliJ de autocompletar c\u00f3digo, depuraci\u00f3n, etc. IntelliJ IDEA : IDE recomendado para trabajar en el desarrollo del proyecto. Debes descargar la versi\u00f3n Ultimate . Es de pago, pero puedes conseguir una licencia educativa en https://www.jetbrains.com/student/ . Es necesario disponer del JDK Java 8 . En la instalaci\u00f3n se debe instalar el plugin de Scala . Docker Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Utilizaremos la imagen Docker domingogallardo/playframework , que lanza el comando sbt sobre el directorio actual necesario para compilar y ejecutar aplicaciones Play. Cada m\u00e1quina docker se define con un fichero Dockerfile . Puedes mirar el fichero Dockerfile de la imagen de la asignatura en este enlace . M\u00e1s adelante en la asignatura estudiaremos m\u00e1s sobre Docker. Tal y como hemos explicado en la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS para lanzar esta imagen tenemos que ejecutar el siguiente comando, estando en el directorio de la aplicaci\u00f3n Play: 1 2 $ cd /path/to/my/play/project $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework El comando docker run buscar\u00e1 la imagen domingogallardo/playframework en local y la descargar\u00e1 si no la encuentra. Despu\u00e9s la ejecutar\u00e1 montando el directorio actual en el directorio /code y mapeando el puerto 80 de la m\u00e1quina host en el puerto 9000 del contenedor. La imagen est\u00e1 configurada para lanzar el comando sbt sobre el directorio code . Como en este directorio est\u00e1 montado el directorio de la m\u00e1quina host en donde tienes el proyecto, podr\u00e1s editar y modificar los ficheros en la propia m\u00e1quina host y compilarlos y ejecutarlos desde el comando sbt en el contenedor. En la configuraci\u00f3n por defecto (fichero conf/application.conf ) la aplicaci\u00f3n trabaja con la base de datos en memoria. Existe otra configuraci\u00f3n ( conf/develop-mysql.conf ) para que la aplicaci\u00f3n trabaje con una base de datos MySQL. La utilizaremos tambi\u00e9n en la pr\u00e1ctica. Entorno de trabajo Es importante que el entorno de trabajo permita realizar con facilidad tanto el desarrollo de la aplicaci\u00f3n como las pruebas. Pruebas manuales y autom\u00e1ticas Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que hemos a\u00f1adido funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre la base de datos real MySQL . De esta forma podemos introducir datos y reutilizarlos en posteriores pruebas manuales. Para poner en marcha la base de datos MySQL recomendamos usar Docker. El siguiente comando lanza un contenedor llamado play-mysql con una base de datos MySQL trabajando en el puerto interno 3306 y en el puerto del host 3316 con el usuario root con la contrase\u00f1a mads : 1 $ docker run -d -p 3316 :3306 --name play-mysql -e MYSQL_ROOT_PASSWORD = mads -e MYSQL_DATABASE = mads mysql:5 Importante En los laboratorios de la EPS est\u00e1 instalada la imagen Docker 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Tambi\u00e9n durante el desarrollo hay que implementar y lanzar tests autom\u00e1ticos . Recomendamos en este caso usar la base de datos de memoria , en lugar de la base de datos MySQL, para que la ejecuci\u00f3n de los tests tenga m\u00e1s velocidad y para que no se borren los datos introducidos en las pruebas manuales. Debemos configurar el entorno de trabajo para que sea posible realizar los dos tipos de pruebas, manuales y autom\u00e1ticas, simult\u00e1neamente. Dependiendo de si utilizamos o no IntelliJ lo haremos de forma distinta. Configuraci\u00f3n de trabajo usando Visual Studio Code Si tu ordenador no tiene prestaciones suficientes para trabajar con IntelliJ IDEA puedes usar un editor como Visual Studio Code. Recomendamos trabajar con tres pesta\u00f1as de terminal abiertas en el editor: Terminal 1 : ejecuci\u00f3n de la aplicaci\u00f3n para hacer pruebas manuales sobre base de datos MySQL. Lanzamos en el shell el comando docker para lanzar la aplicaci\u00f3n usando la base de datos MySQL. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000 :9000 -e \\ DB_URL = jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME = root -e \\ DB_USER_PASSWD = mads -v ${ PWD } :/code domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf 1 2 [mads-todolist-dgallardo] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-dgallardo] $ run Terminal 2 : pruebas autom\u00e1ticas sobre la base de datos de memoria. Lanzamos en el shell el comando docker para lanzar sbt. No hace falta exportar el puerto 9000 porque s\u00f3lo se va a usar el contenedor para lanzar los tests: 1 2 $ docker run --rm -it -v ${ PWD } :/code domingogallardo/playframework [ mads-todolist-dgallardo ] $ test Terminal 3 : shell en el que usaremos git: 1 2 3 4 5 $ git status On branch master Your branch is up to date with origin/master . nothing to commit, working tree clean Configuraci\u00f3n de trabajo usando IntelliJ Si tenemos un ordenador con suficiente capacidad es recomendable usar IntelliJ IDEA como entorno de desarrollo. Recomendamos la siguiente configuraci\u00f3n: Pruebas manuales : para lanzar la aplicaci\u00f3n y poder realizar pruebas manuales usando la base de datos MySQL debemos crear una configuraci\u00f3n de run/debug que trabaje sobre MySQL y lanzar la ejecuci\u00f3n. Pruebas autom\u00e1ticas : se lanza sbt desde la propia pesta\u00f1a de IntelliJ o desde un terminal con el comando docker run . Como hemos comentado anteriormente, no es necesario mapear el puerto 9000 porque el contenedor s\u00f3lo se va a usar para lanzar los tests: 1 2 $ docker run --rm -it -v ${ PWD } :/code domingogallardo/playframework [ mads-todolist-dgallardo ] $ Y se lanza el comando test . Shell de git : es recomendable tener abierta una ventana de terminal adicional para trabajar con git. Cuidado en las m\u00e1quinas de la EPS En las m\u00e1quinas virtuales Ubuntu de la EPS, la aplicaci\u00f3n Docker se ejecuta con el usuario root . Si se lanza una ejecuci\u00f3n de la m\u00e1quina de docker con el directorio del proyecto antes de haberlo compilado con IntelliJ, se crear\u00e1n directorios de trabajo logs y target con propiedad de root . Esto provocar\u00e1 un error de permisos cuando vayamos a compilar desde IntelliJ y har\u00e1 imposible la compilaci\u00f3n desde el IDE. Para que funcione correctamente la compilaci\u00f3n desde IntelliJ debemos eliminar esos directorios y hacer que sea IntelliJ quien los cree. Por ejemplo, podemos borrarlos a mano con $ sudo rm -rf logs y $ sudo rm -rf target . O podemos volver a descargar el proyecto de GitHub y compilarlo por primera vez con IntelliJ. 3. Antes de empezar la pr\u00e1ctica Descarga e instala el software indicado en el apartado anterior. Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. 1 2 $ git config --global user.name Pepe Perez $ git config --global user.email pepe.perez@example.com lt ; Descarga la imagen de Docker para poder compilar y ejecutar los proyectos Play: 1 2 3 4 $ docker pull domingogallardo/playframework $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE domingogallardo/playframework latest 95c1eb17ecb4 5 weeks ago 530MB Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings Profile y actualizando el campo Name . Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-2018- usuario en la organizaci\u00f3n mads-ua-18 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base Play (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Tambi\u00e9n el profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-18 . Descarga el proyecto y comprueba que se compila y ejecuta correctamente con la imagen de Docker y usando la base de datos de memoria (muy \u00fatil para pruebas y lanzar los tests). 1 2 3 4 5 6 7 8 9 10 11 12 13 $ git clone https://github.com/mads-ua/todolist-2018-usuario.git $ cd todolist-2018-usuario $ docker run --rm -it -v ${ PWD } :/code -p 9000 :9000 domingogallardo/playframework [ info ] Loading project definition from /code/project [ info ] Updating { file:/code/project/ } code-build... [ info ] Resolving org.fusesource.jansi#jansi ; 1 .4 ... [ info ] Done updating. [ info ] Set current project to play-java ( in build file:/code/ ) [ mads-todolist-inicial ] $ test ... [ info ] Passed: Total 35 , Failed 0 , Errors 0 , Passed 35 [ success ] Total time: 35 s, completed Sep 4 , 2018 9 :34:04 AM [ mads-todolist-inicial ] $ run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:9000 en la m\u00e1quina host. Para salir del comando run de sbt debemos hacer CTRL+d . Podemos lanzar cualquier otro comando de sbt (consultar Using the SBT console . Para salir del contenedor podemos escribir el comando exit o hacer CTRL+c . Prueba que la aplicaci\u00f3n funciona correctamente trabajando con la base de datos MySQL (el funcionamiento real de la aplicaci\u00f3n y para hacer pruebas de integraci\u00f3n). Lanza MySQL con Docker: 1 $ docker run -d -p 3316 :3306 --name db-mysql -e MYSQL_ROOT_PASSWORD = mads -e MYSQL_DATABASE = mads mysql:5 Importante En los laboratorios de la EPS est\u00e1 instalada la imagen Docker 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop y docker start . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls -a lista todos los contenedores existentes (parados y en marcha): 1 2 3 4 5 6 7 8 9 $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060 /tcp, 0 .0.0.0:3316- gt ; 3306 /tcp db-mysql $ docker container stop bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited ( 0 ) 7 seconds ago db-mysql $ docker container start bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060 /tcp, 0 .0.0.0:3316- gt ; 3306 /tcp db-mysql Ahora ya podemos lanzar la aplicaci\u00f3n con docker para que trabaje con la base de datos del contenedor, definiendo ahora en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000 :9000 -e \\ DB_URL = jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME = root -e \\ DB_USER_PASSWD = mads -v ${ PWD } :/code domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf . 1 2 [mads-todolist-inicial] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-inicial] $ run Prueba que la aplicaci\u00f3n funciona correctamente. Puedes comprobar las tablas y los datos almacenados en la base de datos conect\u00e1ndote a la base de datos en el puerto 3316 desde cualquier cliente MySQL: En los laboratorios de la EPS, usando MySQL Workbench . En IntelliJ IDEA puedes usar la consola MySQL: Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto: Con todo lo hecho hasta ahora ya hemos comprobado que la aplicaci\u00f3n se compila correctamente y se ejecuta sin problema en las dos configuraciones m\u00e1s importantes con las que trabajaremos: base de datos en memoria y base de datos MySQL. Para el desarrollo de la pr\u00e1ctica que viene a continuaci\u00f3n es fundamental que entiendas el funcionamiento de Play Framework. Lo explicaremos r\u00e1pidamente en la clase de teor\u00eda usando el documento introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS . Pero es imprescindible que hagas t\u00fa un esfuerzo descargando, probando y modificando las dos aplicaciones: domingogallardo/play-proyecto-inicial y domingogallardo/mads-todolist-inicial (es la aplicaci\u00f3n que se ha copiado en tu repositorio). Puedes trabajar en estos proyectos sin miedo de estropearlos. Es m\u00e1s, cuanto m\u00e1s los estropees mejor, porque es la forma de aprender. No deber\u00e1s entregar nada de estos proyectos. 4. Desarrollo de la pr\u00e1ctica En esta primera pr\u00e1ctica vamos a desarrollar las siguientes dos historias de usuario o features : P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de equipos P\u00e1gina descripci\u00f3n de equipo La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : wiki, issues , pull requests (con sus commits en los que se desarrolla paso a paso cada issue ) y tablero del proyecto. Haremos paso a paso la primera caracter\u00edstica, creando la primera versi\u00f3n 1.0.0 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0. 4.1. Versi\u00f3n 1.0.0 La versi\u00f3n 1.0.0 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de . 4.1.1. Wiki Utilizaremos la Wiki del proyecto GitHub para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una p\u00e1gina para cada caracter\u00edstica. La p\u00e1gina principal de la Wiki ser\u00e1 el backlog del proyecto y deber\u00e1 tener los enlaces a todas las caracter\u00edsticas desarrolladas y pendientes de desarrollar. A\u00f1ade la p\u00e1gina principal, en la que organizar\u00e1s el listado de features desarrolladas en proyecto. Un posible ejemplo de organizaci\u00f3n es el siguiente: A\u00f1ade una p\u00e1gina con la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de : 4.1.2. Tablero del proyecto Configura el tablero del proyecto, poniendo como nombre ToDoList y seleccionando como plantilla Automated kanban . Elimina las tarjetas en la columna To do y a\u00f1ade la columna In pull request entre In progress y Done . En las columnas deber\u00e1n aparecer los issues y pull requests del proyecto. GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. A continuaci\u00f3n mostramos la configuraci\u00f3n que usaremos: Deberemos mover manualmente las tarjetas en alg\u00fan caso, porque GitHub no podr\u00e1 detectar las condiciones. En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue ) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : Issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : Pull request creados. Cuando a\u00f1adimos el proyecto al pull request (en la p\u00e1gina del pull request ) GitHub lo coloca autom\u00e1ticamente en esta columna. Archivaremos el issue implementado por el pull request manualmente. Columna Done : Pull requests cerrados. GitHub lo detecta autom\u00e1ticamente. 4.1.3. Issues A\u00f1ade el primer issue , correspondiente a la feature a desarrollar P\u00e1gina Acerca de . A\u00f1ade las etiquetas que inicialmente vamos a usar (ver la imagen) y el milestone 1.0.0. A\u00f1ade el issue al tablero (desde la p\u00e1gina del issue ) y autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To do . 4.1.4. Desarrollo Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama master . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y creando dos pesta\u00f1as en el panel Terminal : una para lanzar el proyecto con Docker y trabajar con Sbt y la otra para trabajar con Git. Creamos la rama en la que desarrollaremos la feature y la subimos a GitHub (en el panel Git ): 1 2 3 4 5 6 7 8 9 $ git checkout -b acerca-de Switched to a new branch acerca-de $ git push -u origin acerca-de Username for https://github.com : domingogallardo2 Password for https://domingogallardo2@github.com : Total 0 (delta 0), reused 0 (delta 0) To https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git * [new branch] acerca-de - acerca-de Branch acerca-de set up to track remote branch acerca-de from origin . Primer commit Hacemos un primer commit. Cambia en build.sbt el nombre del proyecto a mads-todolist- tu-nombre y la versi\u00f3n a 1.0.0-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.0 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ git add build.sbt $ git status On branch acerca-de Your branch is up to date with origin/acerca-de . Changes to be committed: (use git reset HEAD file ... to unstage) modified: build.sbt $ git commit -m Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 [acerca-de f6180cc] Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 1 file changed, 2 insertions(+), 2 deletions(-) $ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 367 bytes | 367.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. To https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git 6767016..a332017 acerca-de - acerca-de Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Si ahora vuelves a lanzar la m\u00e1quina Docker en el proyecto, ver\u00e1s que ha cambiado el nombre del proyecto (en el panel Sbt ): 1 2 3 4 $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework [info] Loading project definition from /code/project [info] Set current project to mads-todolist-dgallardo (in build file:/code/) [mads-todolist-dgallardo] $ Segundo commit En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Ruta Acci\u00f3n en controller Vista Realiza los siguientes cambios. Fichero conf/routes : 1 2 3 4 5 6 7 GET /equipos/addUsuario controllers.EquipoController.formularioAddUsuarioEquipo() POST /equipos/addUsuario controllers.EquipoController.addUsuarioEquipo() + GET /about controllers.HomeController.about() # Map static resources from the /public folder to the /assets URL path GET /assets/*file controllers.Assets.versioned(path= /public , file: Asset) Fichero app/controllers/HomeController.java : 1 2 3 4 5 6 7 8 public Result index() { return ok(index.render( Your new application is ready. )); } + public Result about() { + return ok(about.render()); + } } Fichero app/views/about.scala.html : 1 2 3 4 5 6 7 8 9 10 +@main( Acerca de ) { + div class= container-fluid + h1 ToDo List /h1 + ul + li Desarrollada por Domingo Gallardo /li + li Versi\u00f3n 1.0.0 (en desarrollo) /li + li Fecha de release: pendiente de release /li + /ul + /div +} Prueba la p\u00e1gina accediendo a la url http://localhost:9000/about . Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ git add . $ git status On branch acerca-de Your branch is up to date with origin/acerca-de . Changes to be committed: (use git reset HEAD file ... to unstage) modified: app/controllers/HomeController.java new file: app/views/about.scala.html modified: conf/routes $ git commit -m A\u00f1adida ruta, vista y controller about [acerca-de 2831312] A\u00f1adida ruta, vista y controller about 3 files changed, 14 insertions(+) create mode 100644 app/views/about.scala.html $ git push Tercer commit En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero app/views/formLogin.scala.html : 1 2 3 4 a class= btn btn-link href= @routes.UsuarioController.registroUsuario() Ir a registro /a /p + p a class= btn btn-link href= @routes.HomeController.about() Acerca de /a /p } Prueba que funciona correctamente, haz el commit y s\u00fabelo a GitHub: 1 2 3 4 $ git commit -am A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login [acerca-de 672c28f] A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login 1 file changed, 1 insertion(+) $ git push 4.1.5. Pull request Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( master ). M\u00e1s adelante a\u00f1adiremos al pull request una comprobaci\u00f3n autom\u00e1tica de las pruebas y una revisi\u00f3n de c\u00f3digo por parte de compa\u00f1eros del equipo. Por ahora haremos nosotros ambas tareas. Vamos a verlo paso a paso. Empezamos por mezclar la rama de forma local con master , antes de hacer el pull request en GitHub, para probar que no se ha roto nada (todos los tests deben seguir pasando) y que los tests que hemos a\u00f1adido tambi\u00e9n funcionan correctamente (en este caso no hemos a\u00f1adido ninguno). En el panel Git : 1 2 3 4 5 6 7 8 9 10 11 12 13 $ git checkout master Switched to branch master Your branch is up to date with origin/master . $ git merge acerca-de Updating 6767016..672c28f Fast-forward app/controllers/HomeController.java | 4 ++++ app/views/about.scala.html | 8 ++++++++ app/views/formLogin.scala.html | 1 + build.sbt | 4 ++-- conf/routes | 2 ++ 5 files changed, 17 insertions(+), 2 deletions(-) create mode 100644 app/views/about.scala.html En el panel Sbt : 1 2 3 4 5 [mads-todolist-dgallardo] $ test ... [info] Passed: Total 35, Failed 0, Errors 0, Passed 35 [success] Total time: 71 s, completed Sep 6, 2018 10:04:55 AM [mads-todolist-dgallardo] $ Una vez que hemos comprobado que todo funciona bien, deshacemos el merge que acabamos de realizar en la rama master , ya que actualizaremos despu\u00e9s la rama con el resultado del pull request en GitHub: 1 2 3 4 5 $ git reset --hard origin/master HEAD is now at 6767016 Commit inicial $ git checkout acerca-de Switched to branch acerca-de Your branch is up to date with origin/acerca-de . Ya podemos crear el pull request en GitHub. Accede a la rama y comprueba que est\u00e1n todos los cambios pulsando Compare . Pulsa despu\u00e9s el bot\u00f3n New pull request para crear el pull request . Introduce el nombre del pull request , el comentario, el milestone y la etiqueta. Copia los datos del issue , y en el comentario escribe 1 Closes #1 De esta forma, cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue . El n\u00famero #1 lo convierte GitHub en un enlace al issue correspondiente. De esta forma podemos examinar el issue resuelto por el PR. A\u00f1ade tambi\u00e9n el PR al tablero del proyecto. Se colocar\u00e1 autom\u00e1ticamente la columna In pull request . Entra en el proyecto y archiva la tarjeta con el issue , ya que la actividad de desarrollar la feature queda representada por el pull request . En este momento se deber\u00eda hacer una revisi\u00f3n del c\u00f3digo del pull request y comprobar de forma autom\u00e1tica que la integraci\u00f3n con master no introduce errores en los tests. Lo haremos en siguientes pr\u00e1cticas. GitHub informa de que no hay conflictos con la rama master y que es posible hacer el merge. Pulsa el bot\u00f3n de Merge y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Por \u00faltimo, este merge lo has hecho en GitHub, debes integrarlo en tu repositorio local. En la pesta\u00f1a de Git: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ git checkout master $ git fetch remote: Counting objects: 1, done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), done. From https://github.com/mads-ua-18/todolist-2018-domingogallardo2 6767016..9527ae2 master - origin/master $ git pull Updating 6767016..9527ae2 Fast-forward app/controllers/HomeController.java | 4 ++++ app/views/about.scala.html | 8 ++++++++ app/views/formLogin.scala.html | 1 + build.sbt | 4 ++-- conf/routes | 2 ++ 5 files changed, 17 insertions(+), 2 deletions(-) create mode 100644 app/views/about.scala.html $ git branch -d acerca-de Deleted branch acerca-de (was 672c28f). $ git remote prune origin Pruning origin URL: https://github.com/mads-ua-18/todolist-2018-domingogallardo2.git * [pruned] origin/acerca-de $ git log --oneline --graph --all * 9527ae2 (HEAD - master, origin/master, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina about en p\u00e1gina login | * 3fdfb83 A\u00f1adida ruta, vista y controller about | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request . De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. En el tablero de proyecto debe haber cambiado la tarjeta con el PR a la columna Done . 4.1.6. Versi\u00f3n 1.0.0 Por \u00faltimo creamos el release 1.0.0. Haremos un commit directamente sobre la rama master (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release , cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros build.sbt y about.scala.html Fichero build.sbt : 1 2 3 4 5 6 name := mads-todolist-dgallardo -version := 1.0.0-SNAPSHOT +version := 1.0.0 lazy val root = (project in file( . )).enablePlugins(PlayJava) Fichero app/views/about.scala.html : 1 2 3 4 5 6 7 8 9 h1 ToDo List /h1 ul li Desarrollada por Domingo Gallardo /li - li Versi\u00f3n 1.0.0 (en desarrollo) /li - li Fecha de release: pendiente de release /li + li Versi\u00f3n 1.0.0 /li + li Fecha de release: 6/9/2018 /li /ul } A\u00f1adimos el commit y lo subimos a GitHub 1 2 3 4 5 $ git add . $ git commit -m Cambio de versi\u00f3n a 1.0.0 [master 61d4ac8] Cambio de versi\u00f3n a 1.0.0 2 files changed, 3 insertions(+), 3 deletions(-) $ git push Y, por \u00faltimo, creamos la versi\u00f3n 1.0.0 en GitHub pulsando en el enlace release en la p\u00e1gina principal (pesta\u00f1a Code ). Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. Tambi\u00e9n a\u00f1adiremos enlaces a la p\u00e1gina de la Wiki en la que se describe la caracter\u00edstica. El resultado ser\u00e1: 4.2. Versi\u00f3n 1.1.0 El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 2 opcionales: Barra de men\u00fa, obligatoria. P\u00e1gina de equipos de un usuario, obligatoria. P\u00e1gina de descripci\u00f3n de un equipo con el listado de usuarios que participan en \u00e9l, obligatoria. (Opcional) Usuario administrador que gestiona los equipos Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio. Barra de men\u00fa La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login y registro. La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar . de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Equipos : enlace a la p\u00e1gina de equipos, con el listado de equipos al que pertenece el usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n nombre usuario : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login. Equipos de un usuario Cuando el usuario pinche en la opci\u00f3n Equipos del men\u00fa ir\u00e1 a una p\u00e1gina con un listado del equipo a los que pertenece. El listado de equipos ser\u00e1 una tabla similar al listado de tareas, pero sin acciones. La ruta para obtener el listado de los equipos de un usuario ser\u00e1 /usuarios/:id/equipos . Al igual que el listado de tareas, la ruta estar\u00e1 protegida para que s\u00f3lo pueda acceder un usuario logeado y siendo el usuario logeado el mismo que el id . Descripci\u00f3n de equipo En la lista de equipos de un usuario los equipos tendr\u00e1n un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un equipo aparecer\u00e1: su nombre y el listado de personas del equipo. La ruta para obtener la descripci\u00f3n de un equipo ser\u00e1 /equipos/:id . La ruta estar\u00e1 protegida para que s\u00f3lo pueda acceder un usuario logeado. Usuario administrador (opcional) Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador tendr\u00e1 una barra de men\u00fa en la que se a\u00f1adir\u00e1 la opci\u00f3n vac\u00eda Administraci\u00f3n (que iremos cambiando conforme a\u00f1adamos funcionalidades a realizar por el administrador). Gesti\u00f3n equipos por usuario administrador (opcional) El usuario administrador podr\u00e1 gestionar los equipos: a\u00f1adir y editar equipos (la opci\u00f3n de borrar la dejamos para m\u00e1s adelante). El administrador tendr\u00e1 una opci\u00f3n adicional del men\u00fa llamada Administraci\u00f3n de la que se desplegar\u00e1n la opci\u00f3n Equipos . En la administraci\u00f3n de equipos se entrar\u00e1 en una p\u00e1gina donde se mostrar\u00e1 un listado de todos los equipos existentes (como el listado de tareas) y se dar\u00e1 la opci\u00f3n de a\u00f1adir y editar. En la p\u00e1gina de edici\u00f3n de un equipo se podr\u00e1 modificar su nombre y aparecer\u00e1 una tabla con todos los usuarios. Se podr\u00e1 eliminar usuarios del equipo o a\u00f1adir nuevos usuarios al mismo. Los usuarios a a\u00f1adir se escoger\u00e1n de un desplegable en el que se mostrar\u00e1n todos los usuarios no pertenecientes al equipo que se est\u00e1 modificando. 5. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 9 de octubre. La parte obligatoria punt\u00faa sobre 7 y la opcional sobre 3 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 12% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean en sbt para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Enunciado pr\u00e1ctica 1"},{"location":"01-introduccion-play/introduccion-play.html#enunciado-practica-1","text":"","title":"Enunciado pr\u00e1ctica 1"},{"location":"01-introduccion-play/introduccion-play.html#1-objetivos","text":"En la primera pr\u00e1ctica de la asignatura vamos a tomar contacto con el framework de desarrollo de aplicaciones web en Java Play Framework , trabajando sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando la wiki del proyecto. Antes de comenzar la pr\u00e1ctica debes leer la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS .","title":"1. Objetivos"},{"location":"01-introduccion-play/introduccion-play.html#11-aplicacion-inicial","text":"La aplicaci\u00f3n inicial es una aplicaci\u00f3n para gestionar listas de tareas pendientes de los empleados de una empresa. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. Tambi\u00e9n tiene unas funcionalidades iniciales b\u00e1sicas relacionadas con la gesti\u00f3n de equipos de usuarios, de las que s\u00f3lo se ha implementado el esqueleto, sin apenas interfaz de usuario. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es ToDo List .","title":"1.1. Aplicaci\u00f3n inicial"},{"location":"01-introduccion-play/introduccion-play.html#12-metodologia-de-desarrollo","text":"En cuanto a la metodolog\u00eda de desarrollo, en esta primera pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues , labels , milestones , etc. JUnit y DBUnit para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Algunos ejemplos de repositorios en GitHub: CartoDB Vapor Guice Play Framework swift-nio","title":"1.2. Metodolog\u00eda de desarrollo"},{"location":"01-introduccion-play/introduccion-play.html#2-entorno-para-realizar-la-practica","text":"Software necesario: Git Docker , para ejecutar la imagen (similar a una m\u00e1quina virtual) que contiene Java y Play Framework. En esta primera pr\u00e1ctica se utiliza para compilar y ejecutar los proyectos Play y para lanzar el servicio de base de datos MySQL. Como entorno de desarrollo proporcionamos dos opciones: Visual Studio Code : IDE para trabajar en el desarrollo del proyecto si no es posible usar IntelliJ. No tiene las funcionalidades de IntelliJ de autocompletar c\u00f3digo, depuraci\u00f3n, etc. IntelliJ IDEA : IDE recomendado para trabajar en el desarrollo del proyecto. Debes descargar la versi\u00f3n Ultimate . Es de pago, pero puedes conseguir una licencia educativa en https://www.jetbrains.com/student/ . Es necesario disponer del JDK Java 8 . En la instalaci\u00f3n se debe instalar el plugin de Scala .","title":"2. Entorno para realizar la pr\u00e1ctica"},{"location":"01-introduccion-play/introduccion-play.html#docker","text":"Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Utilizaremos la imagen Docker domingogallardo/playframework , que lanza el comando sbt sobre el directorio actual necesario para compilar y ejecutar aplicaciones Play. Cada m\u00e1quina docker se define con un fichero Dockerfile . Puedes mirar el fichero Dockerfile de la imagen de la asignatura en este enlace . M\u00e1s adelante en la asignatura estudiaremos m\u00e1s sobre Docker. Tal y como hemos explicado en la introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS para lanzar esta imagen tenemos que ejecutar el siguiente comando, estando en el directorio de la aplicaci\u00f3n Play: 1 2 $ cd /path/to/my/play/project $ docker run --rm -it -v ${PWD}:/code -p 9000:9000 domingogallardo/playframework El comando docker run buscar\u00e1 la imagen domingogallardo/playframework en local y la descargar\u00e1 si no la encuentra. Despu\u00e9s la ejecutar\u00e1 montando el directorio actual en el directorio /code y mapeando el puerto 80 de la m\u00e1quina host en el puerto 9000 del contenedor. La imagen est\u00e1 configurada para lanzar el comando sbt sobre el directorio code . Como en este directorio est\u00e1 montado el directorio de la m\u00e1quina host en donde tienes el proyecto, podr\u00e1s editar y modificar los ficheros en la propia m\u00e1quina host y compilarlos y ejecutarlos desde el comando sbt en el contenedor. En la configuraci\u00f3n por defecto (fichero conf/application.conf ) la aplicaci\u00f3n trabaja con la base de datos en memoria. Existe otra configuraci\u00f3n ( conf/develop-mysql.conf ) para que la aplicaci\u00f3n trabaje con una base de datos MySQL. La utilizaremos tambi\u00e9n en la pr\u00e1ctica.","title":"Docker"},{"location":"01-introduccion-play/introduccion-play.html#entorno-de-trabajo","text":"Es importante que el entorno de trabajo permita realizar con facilidad tanto el desarrollo de la aplicaci\u00f3n como las pruebas.","title":"Entorno de trabajo"},{"location":"01-introduccion-play/introduccion-play.html#3-antes-de-empezar-la-practica","text":"Descarga e instala el software indicado en el apartado anterior. Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. 1 2 $ git config --global user.name Pepe Perez $ git config --global user.email pepe.perez@example.com lt ; Descarga la imagen de Docker para poder compilar y ejecutar los proyectos Play: 1 2 3 4 $ docker pull domingogallardo/playframework $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE domingogallardo/playframework latest 95c1eb17ecb4 5 weeks ago 530MB Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings Profile y actualizando el campo Name . Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente el repositorio todolist-2018- usuario en la organizaci\u00f3n mads-ua-18 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base Play (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas: Tambi\u00e9n el profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-18 . Descarga el proyecto y comprueba que se compila y ejecuta correctamente con la imagen de Docker y usando la base de datos de memoria (muy \u00fatil para pruebas y lanzar los tests). 1 2 3 4 5 6 7 8 9 10 11 12 13 $ git clone https://github.com/mads-ua/todolist-2018-usuario.git $ cd todolist-2018-usuario $ docker run --rm -it -v ${ PWD } :/code -p 9000 :9000 domingogallardo/playframework [ info ] Loading project definition from /code/project [ info ] Updating { file:/code/project/ } code-build... [ info ] Resolving org.fusesource.jansi#jansi ; 1 .4 ... [ info ] Done updating. [ info ] Set current project to play-java ( in build file:/code/ ) [ mads-todolist-inicial ] $ test ... [ info ] Passed: Total 35 , Failed 0 , Errors 0 , Passed 35 [ success ] Total time: 35 s, completed Sep 4 , 2018 9 :34:04 AM [ mads-todolist-inicial ] $ run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:9000 en la m\u00e1quina host. Para salir del comando run de sbt debemos hacer CTRL+d . Podemos lanzar cualquier otro comando de sbt (consultar Using the SBT console . Para salir del contenedor podemos escribir el comando exit o hacer CTRL+c . Prueba que la aplicaci\u00f3n funciona correctamente trabajando con la base de datos MySQL (el funcionamiento real de la aplicaci\u00f3n y para hacer pruebas de integraci\u00f3n). Lanza MySQL con Docker: 1 $ docker run -d -p 3316 :3306 --name db-mysql -e MYSQL_ROOT_PASSWORD = mads -e MYSQL_DATABASE = mads mysql:5 Importante En los laboratorios de la EPS est\u00e1 instalada la imagen Docker 5.7.18 de MySQL. Hay que definir expl\u00edcitamente esa versi\u00f3n en el comando docker, escribiendo mysql:5.7.18 . Para parar y volver a poner en marcha el contenedor mysql puedes usar los comandos docker stop y docker start . Los datos a\u00f1adidos en la base de datos se mantendr\u00e1n mientras que el contenedor no se borre. El comando docker container ls -a lista todos los contenedores existentes (parados y en marcha): 1 2 3 4 5 6 7 8 9 $ docker container ls CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 30 minutes ago Up 22 minutes 33060 /tcp, 0 .0.0.0:3316- gt ; 3306 /tcp db-mysql $ docker container stop bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 31 minutes ago Exited ( 0 ) 7 seconds ago db-mysql $ docker container start bd057639b6ac CONTAINER ID IMAGE CREATED STATUS PORTS NAMES bd057639b6ac mysql:5 32 minutes ago Up 5 seconds 33060 /tcp, 0 .0.0.0:3316- gt ; 3306 /tcp db-mysql Ahora ya podemos lanzar la aplicaci\u00f3n con docker para que trabaje con la base de datos del contenedor, definiendo ahora en variables de entorno la URL, el usuario y la contrase\u00f1a con la que debe conectarse la aplicaci\u00f3n a la base de datos. Usamos la opci\u00f3n link de docker para definir el nombre l\u00f3gico del contenedor al que debe conectarse la aplicaci\u00f3n. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000 :9000 -e \\ DB_URL = jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME = root -e \\ DB_USER_PASSWD = mads -v ${ PWD } :/code domingogallardo/playframework Y desde la consola sbt modificamos la preferencia config.file para que la aplicaci\u00f3n utilice la configuraci\u00f3n definida en el fichero conf/develop-mysql.conf . 1 2 [mads-todolist-inicial] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-inicial] $ run Prueba que la aplicaci\u00f3n funciona correctamente. Puedes comprobar las tablas y los datos almacenados en la base de datos conect\u00e1ndote a la base de datos en el puerto 3316 desde cualquier cliente MySQL: En los laboratorios de la EPS, usando MySQL Workbench . En IntelliJ IDEA puedes usar la consola MySQL: Es posible examinar el esquema de la base de datos: Y examinar tablas en concreto: Con todo lo hecho hasta ahora ya hemos comprobado que la aplicaci\u00f3n se compila correctamente y se ejecuta sin problema en las dos configuraciones m\u00e1s importantes con las que trabajaremos: base de datos en memoria y base de datos MySQL. Para el desarrollo de la pr\u00e1ctica que viene a continuaci\u00f3n es fundamental que entiendas el funcionamiento de Play Framework. Lo explicaremos r\u00e1pidamente en la clase de teor\u00eda usando el documento introducci\u00f3n a Play Framework para las pr\u00e1cticas de MADS . Pero es imprescindible que hagas t\u00fa un esfuerzo descargando, probando y modificando las dos aplicaciones: domingogallardo/play-proyecto-inicial y domingogallardo/mads-todolist-inicial (es la aplicaci\u00f3n que se ha copiado en tu repositorio). Puedes trabajar en estos proyectos sin miedo de estropearlos. Es m\u00e1s, cuanto m\u00e1s los estropees mejor, porque es la forma de aprender. No deber\u00e1s entregar nada de estos proyectos.","title":"3. Antes de empezar la pr\u00e1ctica"},{"location":"01-introduccion-play/introduccion-play.html#4-desarrollo-de-la-practica","text":"En esta primera pr\u00e1ctica vamos a desarrollar las siguientes dos historias de usuario o features : P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de equipos P\u00e1gina descripci\u00f3n de equipo La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : wiki, issues , pull requests (con sus commits en los que se desarrolla paso a paso cada issue ) y tablero del proyecto. Haremos paso a paso la primera caracter\u00edstica, creando la primera versi\u00f3n 1.0.0 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.","title":"4. Desarrollo de la pr\u00e1ctica"},{"location":"01-introduccion-play/introduccion-play.html#41-version-100","text":"La versi\u00f3n 1.0.0 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de .","title":"4.1. Versi\u00f3n 1.0.0"},{"location":"01-introduccion-play/introduccion-play.html#42-version-110","text":"El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 2 opcionales: Barra de men\u00fa, obligatoria. P\u00e1gina de equipos de un usuario, obligatoria. P\u00e1gina de descripci\u00f3n de un equipo con el listado de usuarios que participan en \u00e9l, obligatoria. (Opcional) Usuario administrador que gestiona los equipos Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio.","title":"4.2. Versi\u00f3n 1.1.0"},{"location":"01-introduccion-play/introduccion-play.html#5-entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 9 de octubre. La parte obligatoria punt\u00faa sobre 7 y la opcional sobre 3 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 12% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean en sbt para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"5. Entrega y evaluaci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html","text":"Pr\u00e1ctica 2: Integraci\u00f3n con Travis y TDD En esta pr\u00e1ctica 2 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua conectando el repositorio de GitHub con Travis. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request sobre la base de datos MySQL. A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 5 de noviembre. Desarrollo de la release 1.2.0 En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release . Pasos a seguir Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en master es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega. Refactorizaci\u00f3n de la relaci\u00f3n uno-a-muchos Antes de comenzar la pr\u00e1ctica hay que hacer una refactorizaci\u00f3n en la relaci\u00f3n una-a-muchos entre usuario y tareas: pasar la lista de tareas de un usuario de List a Set . A diferencias del tipo List , el Set no permite elementos repetidos y es m\u00e1s conveniente definir las relaciones JPA de esta forma. Pasos a seguir Realiza un commit en master (no hace falta que hagas un pull request) con los cambios que aparecen este commit . Lanza los tests para comprobar que todo funciona correctamente y sube el commit a GitHub. Configuraci\u00f3n de la aplicaci\u00f3n Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos MySQL de producci\u00f3n. En esta pr\u00e1ctica vamos a configurar un perfil de la aplicaci\u00f3n para poder lanzar los tests y ejecutar la aplicaci\u00f3n usando una base de datos MySQL. En la pr\u00e1ctica 3 veremos c\u00f3mo definir un perfil para trabajar con una base de datos de producci\u00f3n. Nota La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos en la pr\u00e1ctica 3 que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir un flujo de trabajo para implementar en el esquema de datos de la base de datos un cambio en el modelo de datos de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir distintas configuraciones de ejecuci\u00f3n de la aplicaci\u00f3n, utilizando los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos MySQL. La configuraci\u00f3n de tests con base de datos MySQL la utilizaremos para ejecutar los tests de integraci\u00f3n en el proceso de integraci\u00f3n continua de Travis. Ficheros de configuraci\u00f3n de la aplicaci\u00f3n Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir las propiedades definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-mysql.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con MySQL. Pasos a seguir Instala Docker Desktop . Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Lo vamos a utilizar para lanzar el servidor MySQL de base de datos y tambi\u00e9n para la futura pr\u00e1ctica 3. Si tienes Windows, Docker no es compatible con VirtualBox . Si quieres usar ambos programas puedes usar una versi\u00f3n limitada de Docker llamada Docker Toolbox . Si tienes Ubuntu debes instalar Docker usando apt . Aqu\u00ed tienes un tutorial para instalar Docker en Ubuntu 18.04 . Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con MySQL . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. 1 2 $ ( master ) git checkout -b perfiles $ ( perfiles ) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-mysql.properties : 1 2 3 4 5 6 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos MySQL, su usuario ( root ) y contrase\u00f1a (vac\u00eda) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.MySQL5InnoDBDialect ). Adem\u00e1s se indica que no se debe cargar ning\u00fan fichero de datos inicial. El esquema de la base de datos se actualizar\u00e1 si hay cambios en las entidades de la aplicaci\u00f3n, y los datos se mantendr\u00e1n en la base de datos. Copia el siguiente fichero en src/test/resources/application-mysql.properties : 1 2 3 4 5 spring.datasource.url=jdbc:mysql://localhost:3306/mads_test spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=create La diferencia m\u00e1s importante es el valor de spring.jpa.hibernate.ddl-auto , que es create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver mysql-connector-java y poder utilizar una base de datos MySQL en la aplicaci\u00f3n: Fichero pom.xml : 1 2 3 4 5 6 7 8 9 artifactId h2 /artifactId scope runtime /scope /dependency + dependency + groupId mysql /groupId + artifactId mysql-connector-java /artifactId + /dependency dependency groupId org.springframework.boot /groupId Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor MySQL en el puerto 3306 con el usuario root sin contrase\u00f1a. Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: 1 $ docker run -d -p 3306 :3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 Docker se descarga la imagen mysql:5 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 3306 y sobre la base de datos mads . Le da como nombre mysql-develop . Puedes ejecutar los siguientes comandos de Docker: 1 2 3 $ docker container ls -a ( comprueba todos los contenedores en marcha ) $ docker container stop nombre o id de contenedor ( para un contenedor ) $ docker container rm nombre o id de contenedor ( elimina un contenedor ) Arranca la aplicaci\u00f3n con el siguiente comando: 1 $ mvn spring-boot:run -Dspring-boot.run.profiles = mysql Se cargar\u00e1n las preferencias de src/main/resource/application.profile y src/main/resource/application-mysql.profile . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos con MySQL Workbench o alguna aplicaci\u00f3n similar. Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop : 1 2 3 4 $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e mysql:5 ... mysql-develop $ docker container stop mysql-develop Lanzamos ahora otro contenedor con la base de datos de test: 1 $ docker run -d -p 3306 :3306 --name mysql-test -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads_test mysql:5 Y lanzamos los tests sobre la base de datos MySQL con el siguiente comando: 1 $ mvn -DargLine = -Dspring.profiles.active=mysql test Comprobamos con MySQL Workbench que los datos que hay en la base de datos corresponden con los introducidos en el fichero datos-test.sql que se carga antes de ejecutar los tests. Podemos parar y arrancar el contenedor MySQL que necesitemos con docker container stop y docker container start . Por ejemplo, para parar el contenedor MySQL con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: 1 2 3 $ docker container ls -a $ docker container stop mysql-test $ docker container start mysql-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en master : 1 2 3 4 5 6 7 8 $ ( perfiles ) git add . $ ( perfiles ) git commit -m A\u00f1adidos perfiles para trabajar con MySQL $ ( perfiles ) git push // Mezclamos el Pull Request en GitHub $ ( perfiles ) git checkout master $ ( master ) git pull $ ( master ) git branch -d perfiles $ ( master ) git remote prune origin Integraci\u00f3n continua con Travis Travis-ci.com es un servicio que permite realizar integraci\u00f3n continua on-line, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Es un servicio de pago, pero es gratuito para los repositorios abiertos ( open source ) y para las cuentas educativas de GitHub. La organizaci\u00f3n de GitHub mads-ua tambi\u00e9n est\u00e1 autorizada como organizaci\u00f3n educativa, por lo que todos los repositorios creados dentro de esa organizaci\u00f3n podr\u00e1n trabajar con Travis. Puedes consultar el funcionamiento de Travis leyendo su documentaci\u00f3n, comenzando por la p\u00e1gina Getting started . En la pr\u00e1ctica vamos a configurar Travis para que todos los pull requests deban pasar los tests de integraci\u00f3n (conect\u00e1ndose a la base de datos MySQL) antes de realizar el merge con master . Conexi\u00f3n con GitHub En GitHub est\u00e1 configurada la conexi\u00f3n con Travis para todos los proyectos en la organizaci\u00f3n mads-ua . En tu cuenta de Travis, una vez logeado, podr\u00e1s acceder a tu repositorio en la organizaci\u00f3n mads-ua y comprobar su configuraci\u00f3n. Ver\u00e1s una pantalla como la siguiente: Tests en los pull requests Usando Travis es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Travis. Una vez abierto el PR, Travis comprueba si la integraci\u00f3n de master con la rama pasa los tests definidos en el fichero de configuraci\u00f3n. S\u00f3lo si los tests pasan es posible realizar el merge del PR en master. El fichero de configuraci\u00f3n La configuraci\u00f3n de Travis se realiza con el fichero .travis.yml en la ra\u00edz del repositorio. El fichero .travis.yml para mi repositorio soluci\u00f3n de la pr\u00e1ctica es el siguiente: Fichero .travis.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 language: java branches: only: - master services: - mysql before_install: - mysql -e CREATE DATABASE mads_test; script: ./mvnw -DargLine= -Dspring.profiles.active=mysql test Puntos interesantes a destacar: Se puede espeficar la rama en la que se activa la integraci\u00f3n continua en el apartado branches . En nuestro caso es la rama master . En cualquier commit o pull request que se haga sobre esa rama se lanzar\u00e1 la integraci\u00f3n continua. El apartado services define los servicios necesarios para que se ejecute el script de integraci\u00f3n. En nuestro caso mysql . Cuando se lance travis se lanzar\u00e1 un servidor de MySQL en el puerto por defecto (3306) y con usuario root sin contrase\u00f1a. En el apartado before_install se definen los comandos a realizar antes de ejecutar el script con los tests. En nuestro caso se ejecuta un comando sobre el servicio mysql para crear la base de datos mads_test vac\u00eda. En el apartado script se definen los comandos a realizar para lanzar los tests. En nuestro caso lanzamos el comando mvnw que lanza el Maven instalado en el repositorio (ver punto siguiente). Builds en Travis En Travis tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla una vez ha terminado el build o mientras se est\u00e1 ejecutando. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su Nota S\u00f3lo es posible ejecutar un build simult\u00e1neo en la organizaci\u00f3n mads-ua . Cuando hay otro build ejecut\u00e1ndose los nuevos builds que se lancen quedar\u00e1n encolados por fecha de inicio. Maven Wrapper Maven Wrapper es una forma muy sencilla de distribuir un proyecto que use Maven para que se pueda construir en un sistema operativo en el que Maven no est\u00e9 instalado. En el propio repositorio se instala una versi\u00f3n de Maven que se puede lanzar desde cualquier sistema operativo. Lo utilizaremos para no tener que instalar Maven en Travis. As\u00ed podremos lanzar los tests en Travis con un \u00fanico comando que se ejecuta usando el Maven del propio proyecto. 1 ./mvnw -DargLine= -Dspring.profiles.active=mysql test Pasos a seguir Crea un issue llamado Integraci\u00f3n continua con Travis . Abre una rama travis , s\u00fabela a GitHub y abre un pull request. Instala Maven Wrapper en tu repositorio: 1 $ mvn -N io.takari:maven:wrapper Con este comando se instala Maven en tu propio respositorio (en el directorio .mvn ) y se instalan los comandos mvnw (para Linux) y mvnw.cmd (para Windows). Si est\u00e1s en Windows deber\u00e1s actualizar el permiso de ejecuci\u00f3n del comando mvnw con la siguiente instrucci\u00f3n: 1 $ git update-index --chmod = +x mvnw Prueba que funciona correctamente ejecutando los tests con el comando ./mvnw : 1 $ ./mvnw -DargLine = -Dspring.profiles.active=mysql test Elimina del fichero .gitignore la l\u00ednea .mvn (por un error se ha introducido esa l\u00ednea desde el comienzo de la pr\u00e1ctica) para que los ficheros necesarios de Maven Wrapper (en el directorio .mvn/wrapper ) se incluyan en el repositorio: Fichero .gitignore : 1 2 3 4 target/ - .mvn .idea *.iml Crea un commit y s\u00fabelo a GitHub. A\u00f1ade el fichero .travis.yml en la ra\u00edz del repositorio. Haz otro commit y s\u00fabelo a GitHub. Date de alta en Travis-ci.com y con\u00e9ctalo al repositorio de la pr\u00e1ctica. Comprueba que se pasan los tests en Travis y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build de Travis falla. Vuelve a realizar los cambios para corregirlos, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request con master . Se volver\u00e1n a lanzar los tests en Travis y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. 1 2 3 4 $ ( travis ) git checkout master $ ( master ) git pull $ ( master ) git branch -d travis $ ( master ) git remote prune origin TDD En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta. 008 Listado de equipos La descripci\u00f3n de la historia de usuario es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el nombre del equipo aparecer\u00e1 un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de abajo a arriba . Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional. Pasos a seguir Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea los issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo. Primer test - Entidad Equipo El primer test es para crear la entidad Equipo . Por ahora s\u00f3lo creamos la clase Java, sin las anotaciones JPA. Un equipo Fichero `src/test/java/madstodolist/EquipoTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package madstodolist ; import madstodolist.model.Equipo ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class EquipoTest { @Test public void crearEquipo () { Equipo equipo = new Equipo ( Proyecto Cobalto ); assertThat ( equipo . getNombre ()). isEqualTo ( Proyecto Cobalto ); } } Escribe el c\u00f3digo necesario para que pase el test. No debes escribir c\u00f3digo de m\u00e1s, s\u00f3lo el c\u00f3digo m\u00ednimo para que el test pase . Haz un commit que contenga el test y el c\u00f3digo y s\u00fabelo a la rama remota. Segundo test - Entidad en base de datos Con el segundo test queremos conseguir que funcione JPA con la entidad Equipo y que podamos usar una tabla de equipos en la base de datos, en la que podamos guardar entidades equipo . Para comprobar que la entidad se ha guardado correctamente, comprobaremos se ha actualizando su identificador. Lo hacemos a\u00f1adiendo el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private EquipoRepository equipoRepository ; @Test @Transactional public void grabarEquipo () { // GIVEN Equipo equipo = new Equipo ( Proyecto Cobalto ); // WHEN equipoRepository . save ( equipo ); // THEN assertThat ( equipo . getId ()). isNotNull (); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Tercer test - Definici\u00f3n de igualdad entre equipos Ahora que hemos introducido el id del equipo escribimos un test para comprobar que dos equipos son iguales. Debes escribir el c\u00f3digo de los m\u00e9todos equals y hashCode (necesario este \u00faltimo para que funcione correctamente la comprobaci\u00f3n de igualdades en las colecciones). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Test public void comprobarIgualdadEquipos () { // GIVEN // Creamos tres equipos sin id, s\u00f3lo con el nombre Equipo equipo1 = new Equipo ( Proyecto Cobalto ); Equipo equipo2 = new Equipo ( Proyecto N\u00edquel ); Equipo equipo3 = new Equipo ( Proyecto N\u00edquel ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isNotEqualTo ( equipo2 ); assertThat ( equipo2 ). isEqualTo ( equipo3 ); // WHEN // A\u00f1adimos identificadores y comprobamos igualdad por identificadores equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isEqualTo ( equipo2 ); assertThat ( equipo2 ). isNotEqualTo ( equipo3 ); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Cuarto test - Buscar equipo en base de datos Escribimos ahora un test para recuperar equipos por su identificador de la base de datos. A\u00f1adimos un equipo a la tabla en el fichero datos-test.sql para poder comprobar que funciona correctamente. A\u00f1adimos en el fichero src/test/java/resources/datos-test.sql : 1 INSERT INTO equipos (id, nombre) VALUES( 1 , Proyecto Cobalto ); Test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void comprobarRecuperarEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo ). isNotNull (); assertThat ( equipo . getId ()). isEqualTo ( 1L ); assertThat ( equipo . getNombre ()). isEqualTo ( Proyecto Cobalto ); } Comprueba el test y si es necesario escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Quinto test - Relaci\u00f3n en memoria muchos-a-muchos entre equipos y usuarios Vamos ahora a dise\u00f1ar un test que introduzca la relaci\u00f3n entre equipos y usuarios. Debe ser una relaci\u00f3n muchos-a-muchos: un equipo contiene muchos usuarios y un usuario puede pertenecer a 0, 1 o muchos equipos. Empezamos por un test para crear la relaci\u00f3n en memoria, con las anotaciones m\u00ednimas para que JPA no se queje: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void relaci\u00f3nMuchosAMuchosVacia () { // GIVEN Equipo equipo = new Equipo ( Proyecto Cobalto ); Usuario usuario = new Usuario ( prueba@gmail.com ); // WHEN // THEN assertThat ( equipo . getUsuarios ()). isEmpty (); assertThat ( usuario . getEquipos ()). isEmpty (); } Para que este test funcione hay que crear la relaci\u00f3n muchos-a-muchos entre equipos y usuarios. Por s\u00f3lo la definimos en memoria, sin especificar c\u00f3mo se mapea en la base de datos: Fichero src/main/java/madstodolist/model/Equipo.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 private String nombre; + @ManyToMany + Set Usuario usuarios = new HashSet (); ... public void setId(Long id) { this.id = id; } + public Set Usuario getUsuarios() { + return usuarios; + } Fichero src/main/java/madstodolist/model/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 @OneToMany(mappedBy = usuario , fetch = FetchType.EAGER) Set Tarea tareas = new HashSet (); + @ManyToMany + Set Equipo equipos = new HashSet (); ... + public Set Equipo getEquipos() { + return equipos; + } Comprueba el test, haz un commit en la rama y s\u00fabelo a GitHub. Sexto test - Relaci\u00f3n entre usuarios y equipos en base de datos En este test se va a especificar la relaci\u00f3n muchos-a-muchos en base de datos. Para definir la relaci\u00f3n se va a definir la tabla equipo_usuario en la que cada fila va a representar una relaci\u00f3n de un usuario con un equipo. Las columnas definen las claves ajenas que contienen el identificador de equipo y el del usuario. Para definir el test, creamos una relaci\u00f3n en la base de datos de prueba: 1 2 3 INSERT INTO tareas (id, titulo, usuario_id) VALUES( 2 , Renovar DNI , 1 ); + INSERT INTO equipos (id, nombre) VALUES( 1 , Proyecto Cobalto ); + INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES( 1 , 1 ); Y comprobamos que se el usuario y equipo devuelto por cada clase repository tienen actualizada esa relaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Autowired private UsuarioRepository usuarioRepository ; @Test public void comprobarRelacionBaseDatos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); Usuario usuario = usuarioRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo . getUsuarios ()). hasSize ( 1 ); assertThat ( equipo . getUsuarios ()). contains ( usuario ); assertThat ( usuario . getEquipos ()). hasSize ( 1 ); assertThat ( usuario . getEquipos ()). contains ( equipo ); } Para solucionar el test actualizamos la definici\u00f3n de la relaci\u00f3n en las entidades: 1 2 3 4 5 @ManyToMany + @JoinTable(name = equipo_usuario , + joinColumns = { @JoinColumn(name = fk_equipo ) }, + inverseJoinColumns = {@JoinColumn(name = fk_usuario )}) Set Usuario usuarios = new HashSet (); 1 2 3 - @ManyToMany + @ManyToMany(mappedBy = usuarios ) Set Equipo equipos = new HashSet (); Comprueba el test, haz un commit en la rama y s\u00fabelo a GitHub. S\u00e9ptimo test - listado de equipos Ya por fin tenemos todo lo necesario para definir un test para obtener una lista de equipos en el repository : Actualizamos la base de datos de prueba con otro equipo: 1 2 INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES( 1 , 1 ); + INSERT INTO equipos (id, nombre) VALUES( 2 , Proyecto Adamantium ); Y a\u00f1adimos el test. Queremos que el tipo devuelto por el repository sea List . 1 2 3 4 5 6 7 8 9 10 11 @Test public void comprobarFindAll () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List Equipo equipos = equipoRepository . findAll (); // THEN assertThat ( equipos ). hasSize ( 2 ); } La soluci\u00f3n consiste en a\u00f1adir el m\u00e9todo findAll en la interfaz p EquipoRepository , definiendo el tipo devuelto como List . Spring Boot se encarga de construir autom\u00e1ticamente la implementaci\u00f3n de este m\u00e9todo. Fichero EquipoRepository.java : 1 2 3 4 5 + import java.util.List; public interface EquipoRepository extends CrudRepository Equipo, Long { + public List Equipo findAll(); } Octavo test - M\u00e9todo de servicio para el listado de equipos \u00a1Y por fin llegamos a la capa de servicio! Creamos el test que nos obliga a codificar en esa capa el m\u00e9todo que lista todos los equipos existentes. Lo llamamos findAllOrderedByName() para indicar que queremos que el resultado sea una lista ordenada por los nombres de los equipos. Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package madstodolist ; import madstodolist.model.Equipo ; import madstodolist.service.EquipoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import java.util.List ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class EquipoServiceTest { @Autowired EquipoService equipoService ; @Test public void obtenerListadoEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List Equipo equipos = equipoService . findAllOrderedByName (); // THEN assertThat ( equipos ). hasSize ( 2 ); assertThat ( equipos . get ( 0 ). getNombre ()). isEqualTo ( Proyecto Adamantium ); assertThat ( equipos . get ( 1 ). getNombre ()). isEqualTo ( Proyecto Cobalto ); } } Escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Noveno test - M\u00e9todo de servicio para recuperar un equipo Vamos a centrar este test en la forma de traer a memoria los objetos que participan en la relaci\u00f3n USUARIO-EQUIPO . En JPA hay dos formas de definir una relaci\u00f3n a-muchos: EAGER : Si una relaci\u00f3n a-muchos es EAGER , cuando la clase repository devuelve un objeto (ya sea al recuperarlo individualmente, o en una consulta en la que se recupera una colecci\u00f3n), se obtienen tambi\u00e9n de la base de datos todos los objetos con los que est\u00e1 relacionado. Por ejemplo, en la pr\u00e1ctica tenemos definida de esta forma la relaci\u00f3n entre usuarios y tareas. LAZY : Si una relaci\u00f3n a-muchos es LAZY , cuando la clase repository devuelve un objeto, no recupera de la base de datos los objetos relacionados. S\u00f3lo lo hace cuando se accede a la colecci\u00f3n que contiene la relaci\u00f3n. Entonces es cuando se realiza la consulta a la base de datos y se traen estos objetos a memoria. Si estos objetos tienen otras relaciones se traer\u00e1n a memoria o no dependiendo de si son EAGER o LAZY . Para que funcione la recuperaci\u00f3n perezosa debe estar abierta la conexi\u00f3n con la base de datos en el momento en que se accede a la colecci\u00f3n. Para ello es muy importante la etiqueta @Transactional . Cuando ponemos esta etiqueta en los m\u00e9todos de las clases de servicio se garantiza que todo el m\u00e9todo se realiza en una \u00fanica transacci\u00f3n. Por ello, al finalizar el m\u00e9todo se cerrar\u00e1 la conexi\u00f3n con la base de datos y el objeto que se devolver\u00e1 al controller estar\u00e1 desconectado de la base de datos , por lo que la recuperaci\u00f3n perezosa no funcionar\u00e1 en el controller . En el caso de la relaci\u00f3n USUARIO-EQUIPO vamos a definir el siguiente dise\u00f1o: La relaci\u00f3n entre un usuario y sus equipos ser\u00e1 EAGER . Cuando recuperemos un usuario, recuperaremos tambi\u00e9n la informaci\u00f3n de todos los equipos en los que participa. La relaci\u00f3n entre un equipo y sus usuarios ser\u00e1 LAZY . Esto es muy importante. Si no lo hici\u00e9ramos as\u00ed \u00a1podr\u00edamos f\u00e1cilmente traernos a memoria toda la base de datos!. Un equipo recuperar\u00eda todos sus usuarios, que tambi\u00e9n pueden estar en otros equipos, que a su vez tambi\u00e9n se traer\u00edan a memoria. Vamos entonces a definir un test que sirve para crear el m\u00e9todo de servicio que recupera un equipo y que se asegura de que la relaci\u00f3n entre equipos y usuarios es LAZY . Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void obtenerEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoService . findById ( 1L ); // THEN assertThat ( equipo . getNombre ()). isEqualTo ( Proyecto Cobalto ); // Comprobamos que la relaci\u00f3n con Usuarios es lazy: al // intentar acceder a la colecci\u00f3n de usuarios se debe lanzar una // excepci\u00f3n de tipo LazyInitializationException. assertThatThrownBy (() - { equipo . getUsuarios (). size (); }). isInstanceOf ( LazyInitializationException . class ); } Comprueba si hay que modificar el c\u00f3digo, haz un commit y s\u00fabelo a GitHub. D\u00e9cimo test - comprobaci\u00f3n de recuperaci\u00f3n eager de equipos Hacemos ahora un test para definir la relaci\u00f3n entre usuarios y equipos como eager . Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void comprobarRelacionUsuarioEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Usuario usuario = usuarioService . findById ( 1L ); // THEN assertThat ( usuario . getEquipos ()). hasSize ( 1 ); } Comprueba que el test falla (por un error \"failed to lazily initialize a collection\"), arregla el c\u00f3digo para que pase, haz un commit y s\u00fabelo a GitHub. Onceavo test - M\u00e9todo de servicio para obtener los usuarios de un equipo El \u00faltimo test que sirve para definir el m\u00e9todo de servicio usuariosEquipo(Long idEquipo) que devuelve la lista de usuarios de un equipo. Despu\u00e9s de comprobar que la lista que se devuelve es correcta, volvemos a comprobar que la relaci\u00f3n entre usuarios y equipos es EAGER , esto es, que desde un usuario se puede obtener la lista de equipos a los que pertenece. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void obtenerUsuariosEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List Usuario usuarios = equipoService . usuariosEquipo ( 1L ); // THEN assertThat ( usuarios ). hasSize ( 1 ); assertThat ( usuarios . get ( 0 ). getEmail ()). isEqualTo ( ana.garcia@gmail.com ); // Comprobamos que la relaci\u00f3n entre usuarios y equipos es eager // Primero comprobamos que la colecci\u00f3n de equipos tiene 1 elemento assertThat ( usuarios . get ( 0 ). getEquipos ()). hasSize ( 1 ); // Y despu\u00e9s que el elemento es el equipo Proyecto Cobalto assertThat ( usuarios . get ( 0 ). getEquipos (). stream (). findFirst (). get (). getNombre ()). isEqualTo ( Proyecto Cobalto ); } } Escribe el c\u00f3digo necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Cierre del issue Cuando hayas terminado todos los ciclos de TDD anteriores habr\u00e1s terminado el issue y testeado e implementado los m\u00e9todos necesarios para la clase de servicio que gestiona el listado de equipos y usuarios de esos equipos. Crea un pull request que cierre el issue , comprueba que Travis pasa correctamente los tests e int\u00e9gralo en master en GitHub. Baja los cambios al repositorio local. Vista y controller listado de equipos Abre un nuevo issue para implementar el controller y la vista que permita listar los equipos y sus miembros. Realiza el desarrollo del issue usando varios commits en los que a\u00f1adas las funcionalidades poco a poco. No hace falta que hagas TDD, pero a\u00f1ade al menos un test por cada m\u00e9todo del controller. Resto de historias de usuario Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Pasos a seguir Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 29 de octubre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 5% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 2 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Pr\u00e1ctica 2"},{"location":"02-pruebas-tdd/integration-tdd.html#practica-2-integracion-con-travis-y-tdd","text":"En esta pr\u00e1ctica 2 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua conectando el repositorio de GitHub con Travis. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request sobre la base de datos MySQL. A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 5 de noviembre.","title":"Pr\u00e1ctica 2: Integraci\u00f3n con Travis y TDD"},{"location":"02-pruebas-tdd/integration-tdd.html#desarrollo-de-la-release-120","text":"En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release .","title":"Desarrollo de la release 1.2.0"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir","text":"Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en master es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#refactorizacion-de-la-relacion-uno-a-muchos","text":"Antes de comenzar la pr\u00e1ctica hay que hacer una refactorizaci\u00f3n en la relaci\u00f3n una-a-muchos entre usuario y tareas: pasar la lista de tareas de un usuario de List a Set . A diferencias del tipo List , el Set no permite elementos repetidos y es m\u00e1s conveniente definir las relaciones JPA de esta forma.","title":"Refactorizaci\u00f3n de la relaci\u00f3n uno-a-muchos"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_1","text":"Realiza un commit en master (no hace falta que hagas un pull request) con los cambios que aparecen este commit . Lanza los tests para comprobar que todo funciona correctamente y sube el commit a GitHub.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#configuracion-de-la-aplicacion","text":"Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos MySQL de producci\u00f3n. En esta pr\u00e1ctica vamos a configurar un perfil de la aplicaci\u00f3n para poder lanzar los tests y ejecutar la aplicaci\u00f3n usando una base de datos MySQL. En la pr\u00e1ctica 3 veremos c\u00f3mo definir un perfil para trabajar con una base de datos de producci\u00f3n. Nota La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos en la pr\u00e1ctica 3 que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir un flujo de trabajo para implementar en el esquema de datos de la base de datos un cambio en el modelo de datos de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir distintas configuraciones de ejecuci\u00f3n de la aplicaci\u00f3n, utilizando los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos MySQL. La configuraci\u00f3n de tests con base de datos MySQL la utilizaremos para ejecutar los tests de integraci\u00f3n en el proceso de integraci\u00f3n continua de Travis.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html#ficheros-de-configuracion-de-la-aplicacion","text":"Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir las propiedades definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-mysql.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con MySQL.","title":"Ficheros de configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_2","text":"Instala Docker Desktop . Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Lo vamos a utilizar para lanzar el servidor MySQL de base de datos y tambi\u00e9n para la futura pr\u00e1ctica 3. Si tienes Windows, Docker no es compatible con VirtualBox . Si quieres usar ambos programas puedes usar una versi\u00f3n limitada de Docker llamada Docker Toolbox . Si tienes Ubuntu debes instalar Docker usando apt . Aqu\u00ed tienes un tutorial para instalar Docker en Ubuntu 18.04 . Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con MySQL . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. 1 2 $ ( master ) git checkout -b perfiles $ ( perfiles ) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-mysql.properties : 1 2 3 4 5 6 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos MySQL, su usuario ( root ) y contrase\u00f1a (vac\u00eda) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.MySQL5InnoDBDialect ). Adem\u00e1s se indica que no se debe cargar ning\u00fan fichero de datos inicial. El esquema de la base de datos se actualizar\u00e1 si hay cambios en las entidades de la aplicaci\u00f3n, y los datos se mantendr\u00e1n en la base de datos. Copia el siguiente fichero en src/test/resources/application-mysql.properties : 1 2 3 4 5 spring.datasource.url=jdbc:mysql://localhost:3306/mads_test spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect spring.jpa.hibernate.ddl-auto=create La diferencia m\u00e1s importante es el valor de spring.jpa.hibernate.ddl-auto , que es create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver mysql-connector-java y poder utilizar una base de datos MySQL en la aplicaci\u00f3n: Fichero pom.xml : 1 2 3 4 5 6 7 8 9 artifactId h2 /artifactId scope runtime /scope /dependency + dependency + groupId mysql /groupId + artifactId mysql-connector-java /artifactId + /dependency dependency groupId org.springframework.boot /groupId Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor MySQL en el puerto 3306 con el usuario root sin contrase\u00f1a. Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: 1 $ docker run -d -p 3306 :3306 --name mysql-develop -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 Docker se descarga la imagen mysql:5 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 3306 y sobre la base de datos mads . Le da como nombre mysql-develop . Puedes ejecutar los siguientes comandos de Docker: 1 2 3 $ docker container ls -a ( comprueba todos los contenedores en marcha ) $ docker container stop nombre o id de contenedor ( para un contenedor ) $ docker container rm nombre o id de contenedor ( elimina un contenedor ) Arranca la aplicaci\u00f3n con el siguiente comando: 1 $ mvn spring-boot:run -Dspring-boot.run.profiles = mysql Se cargar\u00e1n las preferencias de src/main/resource/application.profile y src/main/resource/application-mysql.profile . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos con MySQL Workbench o alguna aplicaci\u00f3n similar. Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop : 1 2 3 4 $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e mysql:5 ... mysql-develop $ docker container stop mysql-develop Lanzamos ahora otro contenedor con la base de datos de test: 1 $ docker run -d -p 3306 :3306 --name mysql-test -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads_test mysql:5 Y lanzamos los tests sobre la base de datos MySQL con el siguiente comando: 1 $ mvn -DargLine = -Dspring.profiles.active=mysql test Comprobamos con MySQL Workbench que los datos que hay en la base de datos corresponden con los introducidos en el fichero datos-test.sql que se carga antes de ejecutar los tests. Podemos parar y arrancar el contenedor MySQL que necesitemos con docker container stop y docker container start . Por ejemplo, para parar el contenedor MySQL con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: 1 2 3 $ docker container ls -a $ docker container stop mysql-test $ docker container start mysql-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en master : 1 2 3 4 5 6 7 8 $ ( perfiles ) git add . $ ( perfiles ) git commit -m A\u00f1adidos perfiles para trabajar con MySQL $ ( perfiles ) git push // Mezclamos el Pull Request en GitHub $ ( perfiles ) git checkout master $ ( master ) git pull $ ( master ) git branch -d perfiles $ ( master ) git remote prune origin","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#integracion-continua-con-travis","text":"Travis-ci.com es un servicio que permite realizar integraci\u00f3n continua on-line, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Es un servicio de pago, pero es gratuito para los repositorios abiertos ( open source ) y para las cuentas educativas de GitHub. La organizaci\u00f3n de GitHub mads-ua tambi\u00e9n est\u00e1 autorizada como organizaci\u00f3n educativa, por lo que todos los repositorios creados dentro de esa organizaci\u00f3n podr\u00e1n trabajar con Travis. Puedes consultar el funcionamiento de Travis leyendo su documentaci\u00f3n, comenzando por la p\u00e1gina Getting started . En la pr\u00e1ctica vamos a configurar Travis para que todos los pull requests deban pasar los tests de integraci\u00f3n (conect\u00e1ndose a la base de datos MySQL) antes de realizar el merge con master .","title":"Integraci\u00f3n continua con Travis"},{"location":"02-pruebas-tdd/integration-tdd.html#conexion-con-github","text":"En GitHub est\u00e1 configurada la conexi\u00f3n con Travis para todos los proyectos en la organizaci\u00f3n mads-ua . En tu cuenta de Travis, una vez logeado, podr\u00e1s acceder a tu repositorio en la organizaci\u00f3n mads-ua y comprobar su configuraci\u00f3n. Ver\u00e1s una pantalla como la siguiente:","title":"Conexi\u00f3n con GitHub"},{"location":"02-pruebas-tdd/integration-tdd.html#tests-en-los-pull-requests","text":"Usando Travis es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Travis. Una vez abierto el PR, Travis comprueba si la integraci\u00f3n de master con la rama pasa los tests definidos en el fichero de configuraci\u00f3n. S\u00f3lo si los tests pasan es posible realizar el merge del PR en master.","title":"Tests en los pull requests"},{"location":"02-pruebas-tdd/integration-tdd.html#el-fichero-de-configuracion","text":"La configuraci\u00f3n de Travis se realiza con el fichero .travis.yml en la ra\u00edz del repositorio. El fichero .travis.yml para mi repositorio soluci\u00f3n de la pr\u00e1ctica es el siguiente: Fichero .travis.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 language: java branches: only: - master services: - mysql before_install: - mysql -e CREATE DATABASE mads_test; script: ./mvnw -DargLine= -Dspring.profiles.active=mysql test Puntos interesantes a destacar: Se puede espeficar la rama en la que se activa la integraci\u00f3n continua en el apartado branches . En nuestro caso es la rama master . En cualquier commit o pull request que se haga sobre esa rama se lanzar\u00e1 la integraci\u00f3n continua. El apartado services define los servicios necesarios para que se ejecute el script de integraci\u00f3n. En nuestro caso mysql . Cuando se lance travis se lanzar\u00e1 un servidor de MySQL en el puerto por defecto (3306) y con usuario root sin contrase\u00f1a. En el apartado before_install se definen los comandos a realizar antes de ejecutar el script con los tests. En nuestro caso se ejecuta un comando sobre el servicio mysql para crear la base de datos mads_test vac\u00eda. En el apartado script se definen los comandos a realizar para lanzar los tests. En nuestro caso lanzamos el comando mvnw que lanza el Maven instalado en el repositorio (ver punto siguiente).","title":"El fichero de configuraci\u00f3n"},{"location":"02-pruebas-tdd/integration-tdd.html#builds-en-travis","text":"En Travis tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla una vez ha terminado el build o mientras se est\u00e1 ejecutando. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su Nota S\u00f3lo es posible ejecutar un build simult\u00e1neo en la organizaci\u00f3n mads-ua . Cuando hay otro build ejecut\u00e1ndose los nuevos builds que se lancen quedar\u00e1n encolados por fecha de inicio.","title":"Builds en Travis"},{"location":"02-pruebas-tdd/integration-tdd.html#maven-wrapper","text":"Maven Wrapper es una forma muy sencilla de distribuir un proyecto que use Maven para que se pueda construir en un sistema operativo en el que Maven no est\u00e9 instalado. En el propio repositorio se instala una versi\u00f3n de Maven que se puede lanzar desde cualquier sistema operativo. Lo utilizaremos para no tener que instalar Maven en Travis. As\u00ed podremos lanzar los tests en Travis con un \u00fanico comando que se ejecuta usando el Maven del propio proyecto. 1 ./mvnw -DargLine= -Dspring.profiles.active=mysql test","title":"Maven Wrapper"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_3","text":"Crea un issue llamado Integraci\u00f3n continua con Travis . Abre una rama travis , s\u00fabela a GitHub y abre un pull request. Instala Maven Wrapper en tu repositorio: 1 $ mvn -N io.takari:maven:wrapper Con este comando se instala Maven en tu propio respositorio (en el directorio .mvn ) y se instalan los comandos mvnw (para Linux) y mvnw.cmd (para Windows). Si est\u00e1s en Windows deber\u00e1s actualizar el permiso de ejecuci\u00f3n del comando mvnw con la siguiente instrucci\u00f3n: 1 $ git update-index --chmod = +x mvnw Prueba que funciona correctamente ejecutando los tests con el comando ./mvnw : 1 $ ./mvnw -DargLine = -Dspring.profiles.active=mysql test Elimina del fichero .gitignore la l\u00ednea .mvn (por un error se ha introducido esa l\u00ednea desde el comienzo de la pr\u00e1ctica) para que los ficheros necesarios de Maven Wrapper (en el directorio .mvn/wrapper ) se incluyan en el repositorio: Fichero .gitignore : 1 2 3 4 target/ - .mvn .idea *.iml Crea un commit y s\u00fabelo a GitHub. A\u00f1ade el fichero .travis.yml en la ra\u00edz del repositorio. Haz otro commit y s\u00fabelo a GitHub. Date de alta en Travis-ci.com y con\u00e9ctalo al repositorio de la pr\u00e1ctica. Comprueba que se pasan los tests en Travis y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build de Travis falla. Vuelve a realizar los cambios para corregirlos, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request con master . Se volver\u00e1n a lanzar los tests en Travis y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. 1 2 3 4 $ ( travis ) git checkout master $ ( master ) git pull $ ( master ) git branch -d travis $ ( master ) git remote prune origin","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#tdd","text":"En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta.","title":"TDD"},{"location":"02-pruebas-tdd/integration-tdd.html#008-listado-de-equipos","text":"La descripci\u00f3n de la historia de usuario es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el nombre del equipo aparecer\u00e1 un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de abajo a arriba . Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional.","title":"008 Listado de equipos"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_4","text":"Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea los issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#resto-de-historias-de-usuario","text":"Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa.","title":"Resto de historias de usuario"},{"location":"02-pruebas-tdd/integration-tdd.html#pasos-a-seguir_5","text":"Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica.","title":"Pasos a seguir"},{"location":"02-pruebas-tdd/integration-tdd.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 29 de octubre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 5% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 2 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Entrega y evaluaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html","text":"Pr\u00e1ctica 3: Trabajo en equipo GitFlow y despliegue de la aplicaci\u00f3n Objetivos y resumen de la pr\u00e1ctica En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Implementar GitFlow. Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow. Despliegue de la nueva versi\u00f3n en producci\u00f3n. Formaci\u00f3n de equipos En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas (de forma excepcional podr\u00edan ser 2 o 4 personas). Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Se formar\u00e1 tambi\u00e9n un team en la organizaci\u00f3n mads-ua-18 en el que participar\u00e1n todos los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio. Pasos a seguir Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolistgrupo-2018-NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 1, el repositorio se crear\u00e1 en el grupo mads-ua-18 . Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 1 y 2. Escoged el proyecto que vais a usar en estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: 1 2 $ git remote set-url origin https://github.com/mads-ua-18/todolistgrupo-2018-NOMBRE-EQUIPO.git $ git push -u origin master Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto en el fichero build.sbt a mads-todolist-equipo-XX . Tambi\u00e9n deber\u00e9is cambiar el fichero Dockerfile para actualizar el nombre de la aplicaci\u00f3n a ejecutar, y el fichero .travis.yml para modificar el nombre de la m\u00e1quina a publicar en Docker Hub (pod\u00e9is llamarla tambi\u00e9n mads-todolist-equipo-XX ). Pod\u00e9is usar como usuario de Docker Hub el propietario del repositorio escogido. Haced un commit directamente en master con estos cambios. Para conectar el repositorio con Travis hay que acceder a la cuenta personal en Travis.com y sincronizar el nuevo repositorio todolistgrupo en la organizaci\u00f3n mads-ua-18 . Puedes acceder a la p\u00e1gina para sincronizar este nuevo repositorio desde la p\u00e1gina principal de Travis, pulsando el bot\u00f3n + : Aseguraos que funciona correctamente la nueva imagen subida probando a ejecutar la aplicaci\u00f3n: 1 $ docker run -it --rm -p 9000 :9000 lt ; usuario gt ; /mads-todolist-equipo-XX El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C . Nuevo flujo de trabajo para los issues Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable. Nueva rama con el issue : El responsable ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al final, todos los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Integraci\u00f3n del pull request : Cuando todos dan el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios. Comandos Git Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: 1 2 $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar una rama del repositorio remoto: 1 2 $ git fetch $ git checkout nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas cacheadas a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). En el caso del comando anterior, el comando git checkout nueva-rama es equivalente a git checkout -b nueva-rama origin/nueva-rama . Se crea una rama local nueva-rama conectada a la rama origin/nueva-rama . Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: 1 $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . El comando git fetch actualiza la rama remota origin/nueva-rama . El comando git pull es equivalente a hacer: 1 2 3 $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: 1 2 (estando en la rama que queremos subir) $ git push El comando git push funcionar\u00e1 correctamente sin m\u00e1s par\u00e1metros si previamente hemos subido la rama con un git push -u . Comprobar el estado de las ramas locales y remotas: 1 $ git branch -vv Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: 1 2 $ git fetch --all $ git branch -vv Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que baja las ramas remotas cach\u00e9s locales. Informaci\u00f3n de los repositorios remotos: 1 $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. 1 $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminar: 1 2 $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama master . Podemos hacer un merge de la rama master en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en master y que necesitamos en nuestra nueva rama: 1 2 $ git checkout nueva-rama $ git merge master Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y master . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: 1 2 3 4 5 6 7 $ git checkout master $ git pull $ git checkout nueva-rama $ git merge master # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub Pasos a seguir Probad el nuevo flujo de trabajo en el tablero del proyecto creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en master y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en master que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en master . Configuraci\u00f3n de GitFlow El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ). Pero vamos a introducir alguna variante en la nomenclatura de las ramas. Ramas de largo recorrido En GitFlow se publican las distintas versiones del proyecto en la rama long-lived master y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en master sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings Branches Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop . Ramas de feature Desde el comienzo de trabajo con Git en las pr\u00e1cticas 1 y 2 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request. Ramas de release Hasta ahora hemos hecho los releases en la rama master . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en master y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request. Pasos a seguir El equipo elegir\u00e1 un responsable de integraci\u00f3n que se encargue de crear la rama develop y configurarla como rama principal del proyecto en GitHub. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. Habr\u00e1 que modificar el fichero de configuraci\u00f3n de Travis, para que tambi\u00e9n se lancen los builds en esta rama. Haced un PR de prueba en la rama develop para comprobar que todo funciona bien. Cread un issue con la tarea Lanzar release 1.3.0 que tendr\u00e1 como responsable tambi\u00e9n al responsable de integraci\u00f3n. El responsable de integraci\u00f3n deber\u00e1 publicar la nueva versi\u00f3n siguiendo los pasos de GitFlow: Crear la rama local release-1.3.0 a partir de develop . Realizar en esta rama los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina \"Acerca de\" \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero build.sbt . Publicar la rama release-1.3.0 en GitHub y hacer un pull request sobre master . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en master creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Por \u00faltimo, subir a Docker Hub la nueva versi\u00f3n 1.3.0. Docker Hub hace el papel de \"repositorio de artefactos\" de nuestra cadena de integraci\u00f3n continua. Publicaremos all\u00ed todas las releases compiladas en forma de im\u00e1genes docker que vayamos generando. Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas master y develop estar\u00e1n actualizadas a las nuevas versiones. La rama develop tambi\u00e9n ser\u00e1 integrada por Travis. Debemos comprobar que pasan todos los tests y que sube a Docker Hub la imagen con la etiqueta latest . Por \u00faltimo, deber\u00e9is realizar un hot fix , siguiendo el flujo de trabajo de GitFlow, y actualizando el n\u00famero de versi\u00f3n a 1.3.1 . Despliegue El objetivo del despliegue es poner en producci\u00f3n la \u00faltima versi\u00f3n lanzada de la aplicaci\u00f3n. Como no ha sido posible encontrar ning\u00fan servicio gratuito de hosting que soporte Play Framework (o Docker) y MySQL, se realizar\u00e1 el despliegue en un ordenador de uno de los miembros del equipo. El responsable de despliegue deber\u00e1 desplegar la aplicaci\u00f3n docker correspondiente a la \u00faltima versi\u00f3n (que se estar\u00e1 publicada en Docker Hub). Deber\u00e1 realizar el despliegue en modo producci\u00f3n, trabajando con el fichero de configuraci\u00f3n production.conf , y sobre una base de datos de producci\u00f3n MySQL que contendr\u00e1 todos los datos guardados en todas las ejecuciones de la aplicaci\u00f3n en este entorno de producci\u00f3n. Para que funcione correctamente, se deber\u00e1 actualizar el esquema de datos de la base de datos de producci\u00f3n en el caso en que se haya modificado dicho esquema en el desarrollo. Vamos a ver primero los elementos que necesitamos para realizar el despliegue y despu\u00e9s enumeraremos paso a paso las actividades a realizar en la pr\u00e1ctica. Gesti\u00f3n de la base de datos de producci\u00f3n La base de datos de producci\u00f3n deber\u00e1 crearse inicialmente con el esquema de datos necesario. Despu\u00e9s deber\u00e1 actualizarse con cada nueva versi\u00f3n que modifique el esquema de datos. La base de datos de producci\u00f3n contendr\u00e1 todos los datos introducidos por distintas pruebas realizadas, simulando usuarios reales que utilizan la aplicaci\u00f3n. Exportaci\u00f3n del esquema de datos inicial Para conseguir el esquema de datos inicial de la aplicaci\u00f3n podemos exportarlo una vez creado por la aplicaci\u00f3n ejecut\u00e1ndose en modo develop. Para ello lanzamos la aplicaci\u00f3n como lo hemos hecho hasta ahora, trabajando contra el contenedor MySQL reci\u00e9n arrancado. Al arrancar la aplicaci\u00f3n JPA crea en la base de datos el esquema necesario para que la aplicaci\u00f3n funcione. No hace falta a\u00f1adir ning\u00fan dato, porque solo nos interesa el esquema de datos. Una incializado el esquema de datos podemos exportarlo con el siguiente comando mysqldum lanzado al contenedor db-mysql en marcha: 1 $ docker exec db-mysql sh -c exec mysqldump --no-data mads -uroot -pmads schema.sql El comando anterior ejecuta el comando mysqldump en el contenedor docker. Este comando exporta el esquema de datos (sin los datos a\u00f1adidos) y lo graba el fichero schema.sql en el directorio actual. El fichero deber\u00eda ser parecido a este: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 -- MySQL dump 10.13 Distrib 5.7.23, for Linux (x86_64) -- -- Host: localhost Database: mads -- ------------------------------------------------------ -- Server version 5.7.23 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */ ; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */ ; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */ ; /*!40101 SET NAMES utf8 */ ; /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */ ; /*!40103 SET TIME_ZONE= +00:00 */ ; /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */ ; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */ ; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE= NO_AUTO_VALUE_ON_ZERO */ ; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */ ; -- -- Table structure for table `Admin` -- DROP TABLE IF EXISTS ` Admin ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Admin ` ( ` usuario_id ` bigint ( 20 ) NOT NULL , PRIMARY KEY ( ` usuario_id ` ), CONSTRAINT ` FKk02c1a5a0iytp4s5ijsk8i038 ` FOREIGN KEY ( ` usuario_id ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Equipo` -- DROP TABLE IF EXISTS ` Equipo ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Equipo ` ( ` id ` bigint ( 20 ) NOT NULL , ` nombre ` varchar ( 255 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Equipo_Usuario` -- DROP TABLE IF EXISTS ` Equipo_Usuario ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Equipo_Usuario ` ( ` fk_equipo ` bigint ( 20 ) NOT NULL , ` fk_usuario ` bigint ( 20 ) NOT NULL , PRIMARY KEY ( ` fk_equipo ` , ` fk_usuario ` ), KEY ` FKfhluff2qt31bph8boc2xiadfd ` ( ` fk_usuario ` ), CONSTRAINT ` FKfhluff2qt31bph8boc2xiadfd ` FOREIGN KEY ( ` fk_usuario ` ) REFERENCES ` Usuario ` ( ` id ` ), CONSTRAINT ` FKhiod88sx7eufxk2p9379o37wh ` FOREIGN KEY ( ` fk_equipo ` ) REFERENCES ` Equipo ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Etiqueta` -- DROP TABLE IF EXISTS ` Etiqueta ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Etiqueta ` ( ` id ` bigint ( 20 ) NOT NULL , ` texto ` varchar ( 255 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Etiqueta_Tarea` -- DROP TABLE IF EXISTS ` Etiqueta_Tarea ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Etiqueta_Tarea ` ( ` fk_etiqueta ` bigint ( 20 ) NOT NULL , ` fk_tarea ` bigint ( 20 ) NOT NULL , PRIMARY KEY ( ` fk_etiqueta ` , ` fk_tarea ` ), KEY ` FKpok50kklbh3b9c4h3gyxug37a ` ( ` fk_tarea ` ), CONSTRAINT ` FK2x5gddvr7tkl4crl8dgcxiojc ` FOREIGN KEY ( ` fk_etiqueta ` ) REFERENCES ` Etiqueta ` ( ` id ` ), CONSTRAINT ` FKpok50kklbh3b9c4h3gyxug37a ` FOREIGN KEY ( ` fk_tarea ` ) REFERENCES ` Tarea ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Tarea` -- DROP TABLE IF EXISTS ` Tarea ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Tarea ` ( ` id ` bigint ( 20 ) NOT NULL , ` titulo ` varchar ( 255 ) DEFAULT NULL , ` usuarioId ` bigint ( 20 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ), KEY ` FKepne2t52y8dmn8l9da0dd7l51 ` ( ` usuarioId ` ), CONSTRAINT ` FKepne2t52y8dmn8l9da0dd7l51 ` FOREIGN KEY ( ` usuarioId ` ) REFERENCES ` Usuario ` ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `Usuario` -- DROP TABLE IF EXISTS ` Usuario ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` Usuario ` ( ` id ` bigint ( 20 ) NOT NULL , ` apellidos ` varchar ( 255 ) DEFAULT NULL , ` email ` varchar ( 255 ) DEFAULT NULL , ` fechaNacimiento ` date DEFAULT NULL , ` login ` varchar ( 255 ) DEFAULT NULL , ` nombre ` varchar ( 255 ) DEFAULT NULL , ` password ` varchar ( 255 ) DEFAULT NULL , PRIMARY KEY ( ` id ` ) ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; -- -- Table structure for table `hibernate_sequence` -- DROP TABLE IF EXISTS ` hibernate_sequence ` ; /*!40101 SET @saved_cs_client = @@character_set_client */ ; /*!40101 SET character_set_client = utf8 */ ; CREATE TABLE ` hibernate_sequence ` ( ` next_val ` bigint ( 20 ) DEFAULT NULL ) ENGINE = InnoDB DEFAULT CHARSET = latin1 ; /*!40101 SET character_set_client = @saved_cs_client */ ; /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */ ; /*!40101 SET SQL_MODE=@OLD_SQL_MODE */ ; /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */ ; /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */ ; /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */ ; /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */ ; /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */ ; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */ ; -- Dump completed on 2018-10-30 10:50:52 Inicializaci\u00f3n de la imagen docker MySQL Para inicializar los datos de la base de datos de producci\u00f3n podemos utilizar el directorio /docker-entrypoint-initdb.d . Lo primero que hace el contenedor docker reci\u00e9n inicializado es consultar ese directorio y ejecutar todos los ficheros con la extensi\u00f3n .sql que encuentre ah\u00ed. Los ejecuta en el orden alfab\u00e9tico del nombre de fichero. Por ejemplo, si colocamos el fichero backup.sql en el directorio actual, podemos lanzar el contenedor docker de la siguiente forma, para que cargue este fichero nada m\u00e1s arrancar: 1 $ docker run -d --name db-mysql -v ${ PWD } :/docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD = mads -e MYSQL_DATABASE = mads mysql:5 De esta forma se lanza MySQL cargando el esquema y los datos que hayamos incluido en el fichero backup.sql . Grabado de los datos Es posible volcar los datos de la base de datos del contenedor de producci\u00f3n con el siguiente comando: 1 $ docker exec db-mysql sh -c exec mysqldump mads -uroot -pmads backup.sql De esta forma podemos hacer una copia de seguridad de los datos a\u00f1adidos y del esquema de datos actual. Actualizaci\u00f3n del esquema de datos Cuando se despliegue una nueva versi\u00f3n de la aplicaci\u00f3n que contenga un cambio en el modelo de datos se deber\u00e1 actualizar el esquema de datos de la base de datos para que la aplicaci\u00f3n funcione correctamente. Esta actualizaci\u00f3n deber\u00e1 hacerse sin modificar los datos existentes. Para ello, definiremos un fichero upgradeXXX.sql en el que introduciremos las instrucciones necesarias para actualizar el modelo de datos. Este fichero upgradeXXX.sql lo colocaremos en el mismo directorio de inicializaci\u00f3n junto con el fichero backup.sql que contiene los datos y el esquema anterior. El contenedor cargar\u00e1 ambos ficheros en el orden correcto (primero backup.sql y despu\u00e9s upgradeXXX.sql ). En esta primera versi\u00f3n a\u00f1adiremos en el fichero upgrade001.sql la inicializaci\u00f3n de la tabla de secuencias de Hibernate, necesaria para que Hibernate genere las claves primarias de las entidades: 1 2 3 4 5 6 7 8 9 -- -- Dumping data for table `hibernate_sequence` -- LOCK TABLES ` hibernate_sequence ` WRITE ; /*!40000 ALTER TABLE `hibernate_sequence` DISABLE KEYS */ ; INSERT INTO ` hibernate_sequence ` VALUES ( 1 ),( 1 ); /*!40000 ALTER TABLE `hibernate_sequence` ENABLE KEYS */ ; UNLOCK TABLES ; En las siguientes releases, en cada versi\u00f3n nueva que conlleve una modificaci\u00f3n del esquema de datos, deberemos: Grabar los datos en un fichero backup.sql y parar y borrar el contenedor docker. Colocar ese fichero backup.sql junto con el fichero upgradeXXX.sql que contiene los comandos ALTER TABLE necesarios para la nueva versi\u00f3n en el mismo directorio. Volver a arrancar el contenedor docker sobre el directorio en el que se encuentran los ficheros backup.sql y upgradeXXX.sql . Los datos se volver\u00e1n a cargar en la base de datos y se ejecutar\u00e1n los comandos de actualizaci\u00f3n de las tablas. Ejecuci\u00f3n de la aplicaci\u00f3n en producci\u00f3n En la configuraci\u00f3n de producci\u00f3n en lugar de dejar que JPA cree las tablas de la base de datos, vamos nosotros a inicializar la base de datos MySQL con los esquemas y datos predefinidos. JPA va a validar que las tablas se corresponden con el esquema de datos. Para ello podemos usar el siguiente fichero de configuraci\u00f3n conf/production.conf 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Este fichero define como unidad de persistencia de JPA la unidad denominada default que est\u00e1 definida en el fichero de configuraci\u00f3n de JPA conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 !-- MySQL Persistence Unit - Production: hbm2ddl.auto = VALIDATE -- persistence-unit name= production transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class class models.Admin /class class models.Etiqueta /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit Vemos que en esta configuraci\u00f3n el valor de la propiedad hibernate.hbm2ddl.auto es validate . De esta forma JPA validar\u00e1 que el esquema de base de datos existente se mapea correctamente con las entidades definidas. Para ejecutar la aplicaci\u00f3n Play en modo producci\u00f3n lanzamos nuestra imagen definiendo las variables de entorno para que la configuraci\u00f3n se conecte con la BD y usando el fichero conf/production.conf como fichero de inicializaci\u00f3n. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000:9000 \\ -e DB_URL= jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME= root \\ -e DB_USER_PASSWD= mads -e CONFIG_FILE= conf/production.conf usuario /mads-todolist-equipo-XX El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C . Pasos a seguir Cread un nuevo issue con el t\u00edtulo Esquema de datos . El equipo escoger\u00e1 un responsable de base de datos , que se encargar\u00e1 de este issue abriendo un nuevo PR en develop . Para resolver el issue se deber\u00e1 obtener el fichero schema.sql con el esquema inicial de la aplicaci\u00f3n y a\u00f1adirlo en un nuevo directorio sql en la ra\u00edz del proyecto Play. Se deber\u00e1 crear tambi\u00e9n dentro de ese directorio el fichero upgrade001.sql con el contenido necesario para actualizar la tabla de secuencias de Hibernate. Lanzad una nueva release 1.3.2 desde develop y realizad su despliegue en producci\u00f3n. A\u00f1adid algunos ejemplos de usuarios, tareas y equipos en producci\u00f3n. Una vez a\u00f1adidos, volcad la base de datos resultante y guardadla con el nombre de bd-producion-1.sql . A\u00f1adid un nuevo issue con el t\u00edtulo Prueba actualizaci\u00f3n bd producci\u00f3n . Abrid un PR desde develop y modificad alguna entidad (por ejemplo, a\u00f1adid un atributo de texto direccion al usuario) y lanzad una nueva release 1.3.3 desde develop . En la rama de release el responsable de base de datos deber\u00e1 comprobar el esquema de datos que se genera con los cambios introducidos en la nueva release y a\u00f1adir un nuevo fichero upgrade002.sql para que contemple esos cambios. Una vez terminado el release el responsable de despliegue actualizar la base de datos de producci\u00f3n con los nuevos cambios. Se deber\u00e1 por \u00faltimo a\u00f1adir alg\u00fan dato m\u00e1s y volcar la base de datos resultante con el nombre de bd-produccion-2.sql . Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 20 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 5% en la nota final de la asignatura. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto y los ficheros bd-produccion-1.sql y bd-produdcci\u00f3n-2.sql . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"Pr\u00e1ctica 3: Trabajo en equipo GitFlow y despliegue de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#practica-3-trabajo-en-equipo-gitflow-y-despliegue-de-la-aplicacion","text":"","title":"Pr\u00e1ctica 3: Trabajo en equipo GitFlow y despliegue de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Implementar GitFlow. Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow. Despliegue de la nueva versi\u00f3n en producci\u00f3n.","title":"Objetivos y resumen de la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#formacion-de-equipos","text":"En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas (de forma excepcional podr\u00edan ser 2 o 4 personas). Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Se formar\u00e1 tambi\u00e9n un team en la organizaci\u00f3n mads-ua-18 en el que participar\u00e1n todos los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio.","title":"Formaci\u00f3n de equipos"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir","text":"Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolistgrupo-2018-NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 1, el repositorio se crear\u00e1 en el grupo mads-ua-18 . Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 1 y 2. Escoged el proyecto que vais a usar en estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: 1 2 $ git remote set-url origin https://github.com/mads-ua-18/todolistgrupo-2018-NOMBRE-EQUIPO.git $ git push -u origin master Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto en el fichero build.sbt a mads-todolist-equipo-XX . Tambi\u00e9n deber\u00e9is cambiar el fichero Dockerfile para actualizar el nombre de la aplicaci\u00f3n a ejecutar, y el fichero .travis.yml para modificar el nombre de la m\u00e1quina a publicar en Docker Hub (pod\u00e9is llamarla tambi\u00e9n mads-todolist-equipo-XX ). Pod\u00e9is usar como usuario de Docker Hub el propietario del repositorio escogido. Haced un commit directamente en master con estos cambios. Para conectar el repositorio con Travis hay que acceder a la cuenta personal en Travis.com y sincronizar el nuevo repositorio todolistgrupo en la organizaci\u00f3n mads-ua-18 . Puedes acceder a la p\u00e1gina para sincronizar este nuevo repositorio desde la p\u00e1gina principal de Travis, pulsando el bot\u00f3n + : Aseguraos que funciona correctamente la nueva imagen subida probando a ejecutar la aplicaci\u00f3n: 1 $ docker run -it --rm -p 9000 :9000 lt ; usuario gt ; /mads-todolist-equipo-XX El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C .","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#nuevo-flujo-de-trabajo-para-los-issues","text":"Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable. Nueva rama con el issue : El responsable ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al final, todos los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Integraci\u00f3n del pull request : Cuando todos dan el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios.","title":"Nuevo flujo de trabajo para los issues"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#comandos-git","text":"Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: 1 2 $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar una rama del repositorio remoto: 1 2 $ git fetch $ git checkout nueva-rama El comando git fetch se descarga todos los cambios pero no los mezcla con las ramas locales. Los deja en ramas cacheadas a las que les da el nombre del servidor y la rama ( origin/nueva-rama ). En el caso del comando anterior, el comando git checkout nueva-rama es equivalente a git checkout -b nueva-rama origin/nueva-rama . Se crea una rama local nueva-rama conectada a la rama origin/nueva-rama . Actualizar una rama con cambios que otros compa\u00f1eros han subido al repositorio remoto: 1 $ git pull El comando git pull es equivalente a un git fetch seguido de un git merge . El comando git fetch actualiza la rama remota origin/nueva-rama . El comando git pull es equivalente a hacer: 1 2 3 $ git checkout nueva-rama $ git fetch $ git merge origin/nueva-rama Subir cambios de la rama actual: 1 2 (estando en la rama que queremos subir) $ git push El comando git push funcionar\u00e1 correctamente sin m\u00e1s par\u00e1metros si previamente hemos subido la rama con un git push -u . Comprobar el estado de las ramas locales y remotas: 1 $ git branch -vv Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: 1 2 $ git fetch --all $ git branch -vv Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que baja las ramas remotas cach\u00e9s locales. Informaci\u00f3n de los repositorios remotos: 1 $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. 1 $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminar: 1 2 $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama master . Podemos hacer un merge de la rama master en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en master y que necesitamos en nuestra nueva rama: 1 2 $ git checkout nueva-rama $ git merge master Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y master . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: 1 2 3 4 5 6 7 $ git checkout master $ git pull $ git checkout nueva-rama $ git merge master # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub","title":"Comandos Git"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_1","text":"Probad el nuevo flujo de trabajo en el tablero del proyecto creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en master y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en master que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en master .","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#configuracion-de-gitflow","text":"El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ). Pero vamos a introducir alguna variante en la nomenclatura de las ramas.","title":"Configuraci\u00f3n de GitFlow"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ramas-de-largo-recorrido","text":"En GitFlow se publican las distintas versiones del proyecto en la rama long-lived master y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en master sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings Branches Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop .","title":"Ramas de largo recorrido"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ramas-de-feature","text":"Desde el comienzo de trabajo con Git en las pr\u00e1cticas 1 y 2 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request.","title":"Ramas de feature"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ramas-de-release","text":"Hasta ahora hemos hecho los releases en la rama master . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en master y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request.","title":"Ramas de release"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_2","text":"El equipo elegir\u00e1 un responsable de integraci\u00f3n que se encargue de crear la rama develop y configurarla como rama principal del proyecto en GitHub. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. Habr\u00e1 que modificar el fichero de configuraci\u00f3n de Travis, para que tambi\u00e9n se lancen los builds en esta rama. Haced un PR de prueba en la rama develop para comprobar que todo funciona bien. Cread un issue con la tarea Lanzar release 1.3.0 que tendr\u00e1 como responsable tambi\u00e9n al responsable de integraci\u00f3n. El responsable de integraci\u00f3n deber\u00e1 publicar la nueva versi\u00f3n siguiendo los pasos de GitFlow: Crear la rama local release-1.3.0 a partir de develop . Realizar en esta rama los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina \"Acerca de\" \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero build.sbt . Publicar la rama release-1.3.0 en GitHub y hacer un pull request sobre master . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en master creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Por \u00faltimo, subir a Docker Hub la nueva versi\u00f3n 1.3.0. Docker Hub hace el papel de \"repositorio de artefactos\" de nuestra cadena de integraci\u00f3n continua. Publicaremos all\u00ed todas las releases compiladas en forma de im\u00e1genes docker que vayamos generando. Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas master y develop estar\u00e1n actualizadas a las nuevas versiones. La rama develop tambi\u00e9n ser\u00e1 integrada por Travis. Debemos comprobar que pasan todos los tests y que sube a Docker Hub la imagen con la etiqueta latest . Por \u00faltimo, deber\u00e9is realizar un hot fix , siguiendo el flujo de trabajo de GitFlow, y actualizando el n\u00famero de versi\u00f3n a 1.3.1 .","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#despliegue","text":"El objetivo del despliegue es poner en producci\u00f3n la \u00faltima versi\u00f3n lanzada de la aplicaci\u00f3n. Como no ha sido posible encontrar ning\u00fan servicio gratuito de hosting que soporte Play Framework (o Docker) y MySQL, se realizar\u00e1 el despliegue en un ordenador de uno de los miembros del equipo. El responsable de despliegue deber\u00e1 desplegar la aplicaci\u00f3n docker correspondiente a la \u00faltima versi\u00f3n (que se estar\u00e1 publicada en Docker Hub). Deber\u00e1 realizar el despliegue en modo producci\u00f3n, trabajando con el fichero de configuraci\u00f3n production.conf , y sobre una base de datos de producci\u00f3n MySQL que contendr\u00e1 todos los datos guardados en todas las ejecuciones de la aplicaci\u00f3n en este entorno de producci\u00f3n. Para que funcione correctamente, se deber\u00e1 actualizar el esquema de datos de la base de datos de producci\u00f3n en el caso en que se haya modificado dicho esquema en el desarrollo. Vamos a ver primero los elementos que necesitamos para realizar el despliegue y despu\u00e9s enumeraremos paso a paso las actividades a realizar en la pr\u00e1ctica.","title":"Despliegue"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#gestion-de-la-base-de-datos-de-produccion","text":"La base de datos de producci\u00f3n deber\u00e1 crearse inicialmente con el esquema de datos necesario. Despu\u00e9s deber\u00e1 actualizarse con cada nueva versi\u00f3n que modifique el esquema de datos. La base de datos de producci\u00f3n contendr\u00e1 todos los datos introducidos por distintas pruebas realizadas, simulando usuarios reales que utilizan la aplicaci\u00f3n.","title":"Gesti\u00f3n de la base de datos de producci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#ejecucion-de-la-aplicacion-en-produccion","text":"En la configuraci\u00f3n de producci\u00f3n en lugar de dejar que JPA cree las tablas de la base de datos, vamos nosotros a inicializar la base de datos MySQL con los esquemas y datos predefinidos. JPA va a validar que las tablas se corresponden con el esquema de datos. Para ello podemos usar el siguiente fichero de configuraci\u00f3n conf/production.conf 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Este fichero define como unidad de persistencia de JPA la unidad denominada default que est\u00e1 definida en el fichero de configuraci\u00f3n de JPA conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 !-- MySQL Persistence Unit - Production: hbm2ddl.auto = VALIDATE -- persistence-unit name= production transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class class models.Admin /class class models.Etiqueta /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit Vemos que en esta configuraci\u00f3n el valor de la propiedad hibernate.hbm2ddl.auto es validate . De esta forma JPA validar\u00e1 que el esquema de base de datos existente se mapea correctamente con las entidades definidas. Para ejecutar la aplicaci\u00f3n Play en modo producci\u00f3n lanzamos nuestra imagen definiendo las variables de entorno para que la configuraci\u00f3n se conecte con la BD y usando el fichero conf/production.conf como fichero de inicializaci\u00f3n. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000:9000 \\ -e DB_URL= jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME= root \\ -e DB_USER_PASSWD= mads -e CONFIG_FILE= conf/production.conf usuario /mads-todolist-equipo-XX El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C .","title":"Ejecuci\u00f3n de la aplicaci\u00f3n en producci\u00f3n"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_3","text":"Cread un nuevo issue con el t\u00edtulo Esquema de datos . El equipo escoger\u00e1 un responsable de base de datos , que se encargar\u00e1 de este issue abriendo un nuevo PR en develop . Para resolver el issue se deber\u00e1 obtener el fichero schema.sql con el esquema inicial de la aplicaci\u00f3n y a\u00f1adirlo en un nuevo directorio sql en la ra\u00edz del proyecto Play. Se deber\u00e1 crear tambi\u00e9n dentro de ese directorio el fichero upgrade001.sql con el contenido necesario para actualizar la tabla de secuencias de Hibernate. Lanzad una nueva release 1.3.2 desde develop y realizad su despliegue en producci\u00f3n. A\u00f1adid algunos ejemplos de usuarios, tareas y equipos en producci\u00f3n. Una vez a\u00f1adidos, volcad la base de datos resultante y guardadla con el nombre de bd-producion-1.sql . A\u00f1adid un nuevo issue con el t\u00edtulo Prueba actualizaci\u00f3n bd producci\u00f3n . Abrid un PR desde develop y modificad alguna entidad (por ejemplo, a\u00f1adid un atributo de texto direccion al usuario) y lanzad una nueva release 1.3.3 desde develop . En la rama de release el responsable de base de datos deber\u00e1 comprobar el esquema de datos que se genera con los cambios introducidos en la nueva release y a\u00f1adir un nuevo fichero upgrade002.sql para que contemple esos cambios. Una vez terminado el release el responsable de despliegue actualizar la base de datos de producci\u00f3n con los nuevos cambios. Se deber\u00e1 por \u00faltimo a\u00f1adir alg\u00fan dato m\u00e1s y volcar la base de datos resultante con el nombre de bd-produccion-2.sql .","title":"Pasos a seguir"},{"location":"03-gitflow-despliegue/gitflow-despliegue.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 20 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 5% en la nota final de la asignatura. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto y los ficheros bd-produccion-1.sql y bd-produdcci\u00f3n-2.sql . Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Correcci\u00f3n del c\u00f3digo.","title":"Entrega y evaluaci\u00f3n"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html","text":"Pr\u00e1ctica 2: Integraci\u00f3n con Travis y TDD En esta pr\u00e1ctica 2 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua conectando el repositorio de GitHub con Travis. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request sobre la base de datos MySQL. A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Important Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir en la pr\u00e1ctica . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 2 semanas y la fecha l\u00edmita de entrega es el d\u00eda 30 de octubre. Refactorizaci\u00f3n de la relaci\u00f3n uno-a-muchos Antes de comenzar la pr\u00e1ctica hay que hacer una refactorizaci\u00f3n en la relaci\u00f3n una-a-muchos entre usuario y tareas: pasar la lista de tareas de un usuario de List a Set . A diferencias del tipo List , el Set no permite elementos repetidos y es m\u00e1s conveniente definir las relaciones JPA de esta forma. Pasos a seguir en la pr\u00e1ctica Realiza un commit en master (no hace falta que hagas un pull request) con los cambios que aparecen este commit . Lanza los tests para comprobar que todo funciona correctamente y sube el commit a GitHub. Configuraci\u00f3n de la aplicaci\u00f3n Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos MySQL de producci\u00f3n. En esta pr\u00e1ctica vamos a configurar un perfil de la aplicaci\u00f3n para poder lanzar los tests y ejecutar la aplicaci\u00f3n usando una base de datos MySQL. En la pr\u00e1ctica 3 veremos c\u00f3mo definir un perfil para trabajar con una base de datos de producci\u00f3n. Note La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos en la pr\u00e1ctica 3 que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir un flujo de trabajo para implementar en el esquema de datos de la base de datos un cambio en el modelo de datos de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir distintas configuraciones de ejecuci\u00f3n de la aplicaci\u00f3n, utilizando los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos MySQL. La configuraci\u00f3n de tests con base de datos MySQL la utilizaremos para ejecutar los tests de integraci\u00f3n en el proceso de integraci\u00f3n continua de Travis. Ficheros de configuraci\u00f3n de la aplicaci\u00f3n Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir las propiedades definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.profile donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-mysql.profile (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con MySQL. Pasos a seguir en la pr\u00e1ctica Instala Docker Desktop . Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Lo vamos a utilizar para lanzar el servidor MySQL de base de datos y tambi\u00e9n para la futura pr\u00e1ctica 3. Si tienes Windows, Docker no es compatible con VirtualBox. Si quieres usar ambos programas puedes usar una versi\u00f3n limitada de Docker llamada Docker Toolbox Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con MySQL . Crea una rama nueva y haz los siguientes cambios en ella. Copia el siguiente fichero en src/main/resources/application-mysql.properties : 1 2 3 4 5 6 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos MySQL, su usuario ( root ) y contrase\u00f1a (vac\u00eda) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.MySQL5Dialect ). Adem\u00e1s se indica que no se debe cargar ning\u00fan fichero de datos inicial. El esquema de la base de datos se actualizar\u00e1 si hay cambios en las entidades de la aplicaci\u00f3n, y los datos se mantendr\u00e1n en la base de datos. Copia el siguiente fichero en src/test/resources/application-mysql.properties : 1 2 3 4 5 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect spring.jpa.hibernate.ddl-auto=create La diferencia m\u00e1s importante es el valor de spring.jpa.hibernate.ddl-auto , que es create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver mysql-connector-java y poder utilizar una base de datos MySQL en la aplicaci\u00f3n: Fichero pom.xml : 1 2 3 4 5 6 7 8 9 artifactId h2 /artifactId scope runtime /scope /dependency + dependency + groupId mysql /groupId + artifactId mysql-connector-java /artifactId + /dependency dependency groupId org.springframework.boot /groupId Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor MySQL en el puerto 3306 con el usuario root sin contrase\u00f1a. Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: 1 $ docker run -d -p 3306 :3306 -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 Docker se descarga la imagen mysql:5 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 3306 y sobre la base de datos mads . Puedes ejecutar los siguientes comandos de docker: 1 2 3 4 5 ``` $ docker container ls -a (comprueba todos los contenedores en marcha) $ docker container stop lt;nombre o id de contenedor gt; (para un contenedor) $ docker container rm lt;nombre o id de contenedor gt; (elimina un contenedor) ``` Arranca la aplicaci\u00f3n con el siguiente comando: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ mvn spring-boot:run -Dspring-boot.run.profiles = mysql ``` Se cargar\u00e1n las preferencias de ` src/main/resource/application.profile ` y ` src/main/resource/application-mysql.profile ` . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos con ` MySQL Workbench ` o alguna aplicaci\u00f3n similar. img src = images/mysql-workbench.png width = 600px / La propiedad Java ` config.file ` permite definir un fichero de configuraci\u00f3n distinto del de por defecto. Se puede configurar en las ` javaOptions ` de ` sbt ` : ``` text [ mads-todolist-dgallardo ] $ set javaOptions += -Dconf.file=conf/ FICHERO-CONF .conf Vamos a utilizar dos ficheros de configuraci\u00f3n distintos: Fichero conf/develop-mysql.conf : para lanzar las pruebas de integraci\u00f3n. Fichero conf/production.conf : para ejecutar la aplicaci\u00f3n en producci\u00f3n. Fichero conf/develop-mysql.conf : 1 2 3 4 5 6 include application.conf db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Fichero conf/production.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Ambos ficheros incluyen el fichero application.conf en el que se definen las siguientes propiedades relacionadas con la base de datos: Fichero `conf/application.conf : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Default persistenceUnit for JPA jpa.default = develop db { # You can declare as many datasources as you want. # By convention, the default datasource is named `default` # https://www.playframework.com/documentation/latest/Developing-with-the-H2-Database # Memory H2 database default.driver = org.h2.Driver default.url = jdbc:h2:mem:play;MODE=MYSQL #default.username = sa #default.password = # Definimos el nombre JNDI de la BD que va a usar la aplicaci\u00f3n default.jndiName=DBTodoList # You can turn on SQL logging for any datasource # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements # default.logSql=true } Fichero de configuraci\u00f3n de JPA Vemos en los ficheros anteriores que la diferencia fundamental es el valor de la propiedad jpa.default . En esta propiedad se define el nombre de la unidad de persistencia que se va a usar en JPA. Las unidades de persistencia est\u00e1n definidas en el fichero conf/META-INF/persistence.xml . Fichero `conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 !-- MySQL Persistence Unit - Develop: hbm2ddl.auto = UPDATE -- persistence-unit name= develop transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class class models.Admin /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit !-- MySQL Persistence Unit - Production: hbm2ddl.auto = VALIDATE -- persistence-unit name= production transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class class models.Admin /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit La diferencia fundamental entre ambas unidades de persistencia es el valor de la propiedad hibernate.hbm2ddl.auto , que define c\u00f3mo gestiona JPA el mapeo entre las entidades Java y las tablas f\u00edsicas de la base de datos. En la unidad de persistencia develop hemos usado el valor update . Esto significa que JPA actualizar\u00e1 la base de datos, modificando su esquema, para hacerlo corresponder con las entidades definidas en la aplicaci\u00f3n. Si en alguna entidad a\u00f1adimos alg\u00fan atributo, el esquema de la base de datos se actualizar\u00e1, a\u00f1adiendo un campo en la tabla correspondiente. En la unidad de persistencia production hemos usado el valor validate . En este caso JPA comprobar\u00e1 si el esquema de la base de datos se corresponde con las entidades de la aplicaci\u00f3n. Si no es as\u00ed, se lanzar\u00e1 una excepci\u00f3n y JPA dejar\u00e1 de funcionar. El primer valor es muy \u00fatil para el realizar el desarrollo y los tests de integraci\u00f3n de la aplicaci\u00f3n. Pero no se debe usar en producci\u00f3n porque no queremos que la base de datos de producci\u00f3n (donde est\u00e1n todos los datos introducidos por los usuarios finales) se modifique tan f\u00e1cilmente. Cualquier modificaci\u00f3n de la base de datos de producci\u00f3n debe realizarse mediante un proceso que garantice la posibilidad de la vuelta atr\u00e1s y la recuperaci\u00f3n de posibles errores que se puedan cometer. Variables de entorno En ambos ficheros se usan variables de entorno para definir los valores de la URL de la conexi\u00f3n a la base de datos y el usuario y contrase\u00f1a de esa conexi\u00f3n. Los valores de esas variables se pueden definir de dos formas para que sean visibles dentro de sbt : En el shell en el que se lanza el comando sbt 1 2 3 4 $ export DB_URL = jdbc:mysql://localhost:3316/mads $ export DB_USER_NAME = root $ export DB_USER_PASSWD = mads $ sbt ; set javaOptions += \\ -Dconfig.file=conf/develop-mysql.conf\\ ; test En la \u00faltima l\u00ednea vemos c\u00f3mo es posible lanzar sbt junto con unos comandos que se lanzar\u00e1n dentro del propio sbt . Desde dentro del propio sbt con set javaOptions : 1 2 3 4 5 [mads-todolist-dgallardo] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-dgallardo] $ set javaOptions += -DDB_URL=jdbc:mysql://localhost:3316/mads [mads-todolist-dgallardo] $ set javaOptions += -DDB_USER_NAME=root [mads-todolist-dgallardo] $ set javaOptions += -DDB_USER_PASSWD=mads [mads-todolist-dgallardo] $ test Pasos a seguir en la pr\u00e1ctica Ejecuta los tests de la pr\u00e1ctica usando el fichero de configuraci\u00f3n develop-mysql.conf para que los realice usando la base de datos MySQL (que deber\u00e1s tener activa). Captura la pantalla en la que aparezca el resultado de los tests y el nombre de la base de datos MySQL . Por ejemplo, si ejecutas sbt desde IntelliJ, la pantalla resultante deber\u00e1 ser como la siguiente: Construcci\u00f3n y publicaci\u00f3n de la imagen docker Para facilitar la ejecuci\u00f3n de la aplicaci\u00f3n en diferentes entornos, vamos a generar y publicar una imagen docker de la misma. Alta en Docker Hub Crea una cuenta en docker hub . La utilizar\u00e1s para subir all\u00ed, utilizando tu Docker ID , la image docker de tu pr\u00e1ctica. Construcci\u00f3n de la imagen docker Empezamos construyendo la imagen docker en local y comprobando que funciona correctamente. Comando stage de sbt El comando stage de sbt genera un comando ejecutable con el que se puede lanzar la aplicaci\u00f3n sin usar sbt . Genera un script con el nombre de la aplicaci\u00f3n en el directorio target/universal/stage/bin . Genera tambi\u00e9n un fichero bat para Windows. 1 [mads-todolist-dgallardo] $ stage El script generado lanza la aplicaci\u00f3n en modo producci\u00f3n. En este modo es necesario definir la variable play.crypto.key con una cadena inicial. 1 $ target/universal/stage/bin/mads-todolist-dgallardo -Dplay.crypto.secret = abcdefghijk Al lanzar el comando generado por sbt stage es posible definir el fichero de configuraci\u00f3n que va a usar la ejecuci\u00f3n de la aplicaci\u00f3n. Esta va a ser la caracter\u00edstica clave que nos va a permitir usar distintas configuraciones. 1 $ target/universal/stage/bin/mads-todolist-dgallardo -Dconfig.file = conf/ FICHERO-CONF .conf Fichero Dockerfile El fichero Dockerfile es el fichero en el que se definen las instrucciones para construir la imagen. Docker lo ejecuta paso a paso para ir creando una imagen de una m\u00e1quina virtual con los elementos necesarios para ejecutar nuestra aplicaci\u00f3n. Debemos colocar el fichero Dockerfile en la ra\u00edz del proyecto. Fichero Dockerfile : 1 2 3 4 5 6 7 8 9 10 FROM domingogallardo/playframework WORKDIR /app COPY . /app RUN sbt clean stage EXPOSE 9000 ENV CONFIG_FILE=conf/application.conf ENV SECRET=abcdefghijk CMD target/universal/stage/bin/mads-todolist-2017 -Dplay.crypto.secret=$SECRET -Dconfig.file=$CONFIG_FILE Algunos puntos a destacar: La l\u00ednea FROM indica la imagen docker base sobre la que se construye la aplicaci\u00f3n. La l\u00ednea WORKDIR indica el directorio en el que se van a ejecutar todos los comandos COPY , RUN o CMD . Si el directorio no existe en la imagen, se crea. En este caso creamos el directorio /app en el que se va a compilar la aplicaci\u00f3n. El comando COPY copia el directorio actual (y sus subdirectorios) en el directorio /app de la m\u00e1quina Docker. De esta forma copiamos el fuente de la aplicaci\u00f3n Play. El comando RUN ejecuta lo que hay a continuaci\u00f3n dentro de la m\u00e1quina virtual en el proceso de construcci\u00f3n de la imagen. En este caso se lanza sbt clean stage para compilar el proyecto y generar el ejecutable (que se guardar\u00e1 en el directorio target/universal/stage/bin/NOMBRE_PROYECTO ). Los siguientes comandos ya son para cuando se ejecuta el contenedor. El comando EXPOSE define un puerto a mapear con la m\u00e1quina host. En este caso el puerto 9000, que es en el que se lanza la aplicaci\u00f3n. El comando ENV define valores por defecto de variables de entorno. Estas variables pueden ser sobreescritas con el par\u00e1metro -e en un docker run . En nuestro caso definimos el fichero de configuraci\u00f3n por defecto y la palabra SECRET por defecto. Por \u00faltimo, CMD define el comando que se ejecuta en el contenedor cuando se realiza un docker run . En nuestro caso llamamos a la aplicaci\u00f3n pasando como par\u00e1metro el fichero de configuraci\u00f3n y la palabra SECRET . Comando docker build Una vez creado el fichero Dockerfile ya podemos hacer un docker build para construir la imagen con nuestra aplicaci\u00f3n. Como nombre de la imagen usaremos usuario-docker /mads-todolist:1.1.0 . Docker identifica el n\u00famero que hay despu\u00e9s de los dos puntos como el n\u00famero de versi\u00f3n. 1 2 $ cd mads-todolist-guia $ docker build -t DOCKER-ID /mads-todolist:1.1.0 . Ejecuci\u00f3n de la imagen docker Una vez construida la imagen es posible usarla para ejecutar la aplicaci\u00f3n de muchas maneras. En todas ellas se lanzar\u00e1 la imagen usando el comando docker run . Lo m\u00e1s sencillo es ejecutar la aplicaci\u00f3n trabajando con la base de datos en memoria: 1 $ docker run -it --rm -p 9000 :9000 domingogallardo/mads-todolist:1.1.0 El flag -it permite visualizar en el terminal de forma interactiva la salida est\u00e1ndar de la aplicaci\u00f3n Play y terminarla haciendo un CTRL-C . Tambi\u00e9n podemos lanzar la aplicaci\u00f3n para que trabaje con MySQL, definiendo las variables de entorno necesarias. 1 2 3 $ docker run --link db-mysql --rm -it -p 9000 :9000 \\ -e DB_URL = jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME = root \\ -e DB_USER_PASSWD = mads -e CONFIG_FILE = conf/develop-mysql.conf domingogallardo/mads-todolist:1.1.0 El comando se conecta con el contenedor db-mysql en el que hemos lanzado la base de datos MySQL: 1 $ docker run -d -p 3316 :3306 --name db-mysql -e MYSQL_ROOT_PASSWORD = mads -e MYSQL_DATABASE = mads mysql:5 Si en alg\u00fan momento nos encontramos con un error podemos ver el log del contenedor (si estamos depurando es convieniente lanzar la aplicaci\u00f3n sin el flag --rm para poder examinar el contenedor): 1 2 3 4 5 6 7 8 9 10 $ docker container ls -a CONTAINER ID IMAGE STATUS PORTS NAMES 19986a063c03 domingogallardo/mads-todolist:1.1.0 Up 2 minutes 0 .0.0.0:9000- 9000/tcp zen_payne $ docker container logs 19986a063c03 [ info ] application - Creating Pool for datasource default [ info ] p.a.d.HikariCPConnectionPool - datasource [ default ] bound to JNDI as DBTodoList [ info ] p.a.d.DefaultDBApi - Database [ default ] connected at jdbc:mysql://db-mysql:3306/mads [ info ] application - ApplicationTimer demo: Starting application at 2018 -10-06T11:57:24.119Z [ info ] play.api.Play - Application started ( Prod ) [ info ] p.c.s.NettyServer - Listening for HTTP on /0.0.0.0:9000 Lanzamiento de tests Podemos tambi\u00e9n ejecutar los tests haciendo que el contenedor ejecute el comando bash con sbt test : 1 $ docker run --rm domingogallardo/mads-todolist:1.1.0 /bin/bash -c sbt test Para los tests de integraci\u00f3n con la base de datos real MySQL: 1 2 3 $ docker run --link db-mysql --rm -e DB_URL = jdbc:mysql://db-mysql:3306/mads \\ -e DB_USER_NAME = root -e DB_USER_PASSWD = mads domingogallardo/mads-todolist:1.1.0 \\ /bin/bash -c sbt ; set javaOptions += \\ -Dconfig.file=conf/develop-mysql.conf\\ ; test Subida a docker hub Una vez construida la imagen se puede subir a Docker Hub haciendo docker push (despu\u00e9s de autenticarse con docker login ). Tardar\u00e1 bastante la primera vez. En las siguientes compilaciones ya no tardar\u00e1 tanto, porque s\u00f3lo se subir\u00e1 la parte que cambia de la m\u00e1quina. 1 2 3 4 $ docker login Username: docker-id Password: contrase\u00f1a $ docker push domingogallardo/mads-todolist:1.1.0 All\u00ed estar\u00e1 disponible para descargarla y ejecutarla desde cualquier servidor. La etiqueta latest Utilizando la etiqueta latest marcamos una imagen como la imagen por defecto que se descarga si no se proporciona un n\u00famero de versi\u00f3n. 1 2 3 4 5 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE domingogallardo/mads-todolist 1 .1.0 b80593e5f646 31 hours ago 734MB $ docker tag b80593e5f646 domingogallardo/mads-todolist:latest $ docker push domingogallardo/mads-todolist:latest Una vez subida esta imagen es la que se descargar\u00e1 si se hace un pull del repositorio domingogallardo/mads-todolist Pasos a seguir en la pr\u00e1ctica Crea un nuevo issue llamado Integraci\u00f3n continua con Travis , crea una nueva rama integracion-continua y s\u00fabela a GitHub. Realiza un commit con el fichero Dockerfile a\u00f1adido. Construye la m\u00e1quina docker con tu pr\u00e1ctica, prueba que funciona bien la ejecuci\u00f3n en memoria y el lanzamiento de los tests contra la base de datos MySQL (tests de integraci\u00f3n) y s\u00fabela a Docker Hub, con la versi\u00f3n 1.1.0 y la versi\u00f3n latest . Comparte en el foro de la asignatura el nombre de tu m\u00e1quina y el enlace a tu p\u00e1gina de Docker Hub. Integraci\u00f3n continua con Travis Travis-ci.com es un servicio que permite realizar integraci\u00f3n continua on-line, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Es un servicio de pago, pero es gratuito para los repositorios abiertos ( open source ) y para las cuentas educativas de GitHub. La organizaci\u00f3n de GitHub mads-ua-18 tambi\u00e9n est\u00e1 autorizada como organizaci\u00f3n educativa, por lo que todos los repositorios creados dentro de esa organizaci\u00f3n podr\u00e1n trabajar con Travis. Puedes consultar el funcionamiento de Travis leyendo su documentaci\u00f3n, comenzando por la p\u00e1gina Getting started . En la pr\u00e1ctica vamos a configurar Travis para que todos los pull requests deban pasar los tests de integraci\u00f3n (conect\u00e1ndose a la base de datos MySQL) y para que cuando se realice el merge con master se suba una nueva versi\u00f3n de la m\u00e1quina docker con la aplicaci\u00f3n a Docker Hub. Conexi\u00f3n con GitHub En GitHub est\u00e1 configurada la conexi\u00f3n con Travis para todos los proyectos en la organizaci\u00f3n mads-u-18 . En tu cuenta de Travis, una vez logeado, podr\u00e1s sincronizar tu repositorio y configurar la conexi\u00f3n. Ver\u00e1s una pantalla como la siguiente: Tests en los pull requests Usando Travis es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Travis. Una vez abierto el PR, Travis comprueba si la integraci\u00f3n de master con la rama pasa los tests definidos en el fichero de configuraci\u00f3n. S\u00f3lo si los tests pasan es posible realizar el merge del PR en master. El fichero de configuraci\u00f3n La configuraci\u00f3n de Travis se realiza con el fichero .travis.yml en la ra\u00edz del repositorio. El fichero .travis.yml para mi repositorio soluci\u00f3n de la pr\u00e1ctica es el siguiente: Fichero .travis.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 sudo: required language: bash branches: only: - master services: - docker before_script: - docker build -t domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER . script: - docker run -d --rm -p 3306:3306 --name db-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 - docker run --link db-mysql --rm -e DB_URL= jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME= root -e DB_USER_PASSWD= mads domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER /bin/bash -c sbt ; set javaOptions += \\ -Dconfig.file=conf/develop-mysql.conf\\ ; test after_success: - if [ $TRAVIS_EVENT_TYPE != pull_request ]; then docker login -u= $DOCKER_USERNAME -p= $DOCKER_PASSWORD ; docker push domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER; docker tag domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER domingogallardo/mads-todolist:latest; docker push domingogallardo/mads-todolist:latest; fi Puntos interesantes a destacar: Se puede espeficar la rama en la que se activa la integraci\u00f3n continua en el apartado branches . En nuestro caso es la rama master . En cualquier commit o pull request que se haga sobre esa rama se lanzar\u00e1 la integraci\u00f3n continua. El apartado services define los servicios necesarios para que se ejecute el script de integraci\u00f3n. En nuestro caso docker . En el apartado before_script se definen los comandos a realizar antes de ejecutar el script con los tests. En nuestro caso construimos la imagen docker. En el apartado script se definen los comandos a realizar para lanzar los tests. En nuestro caso ponemos en marcha el servicio docker de MySQL y lanzamos la m\u00e1quina docker de la aplicaci\u00f3n para que ejecute los tests usando la conexi\u00f3n con ese servicio. Por \u00faltimo, el apartado after_success se ejecuta si los tests han pasado correctamente. En nuestro caso definimos la condici\u00f3n adicional de que la ejecuci\u00f3n de Travis se haya lanzado no por un pull request abierto sino porque se ha hecho un merge del pull request en master. En ese caso se sube a Docker Hub la \u00faltima imagen creada, con el n\u00famero de versi\u00f3n definido por el n\u00famero de build de Travis y tambi\u00e9n con la etiqueta latest . Builds en Travis En Travis tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla una vez ha terminado el build o mientras se est\u00e1 ejecutando. Nota S\u00f3lo es posible ejecutar un build simult\u00e1neo en la organizaci\u00f3n mads-ua-18 . Cuando hay otro build ejecut\u00e1ndose los nuevos builds que se lancen quedar\u00e1n encolados por fecha de inicio. Versiones en Docker Hub En Docker Hub tendremos el hist\u00f3rico de versiones generadas en la integraci\u00f3n continua. Y la \u00faltima estar\u00e1 etiquetada con latest . Pasos a seguir en la pr\u00e1ctica Date de alta en Travis-ci.com y con\u00e9ctalo al repositorio de la pr\u00e1ctica. Adapta el fichero .travis.yml a tu pr\u00e1ctica y a\u00f1\u00e1delo con un commit a la rama integracion-continua . Sube el commit a GitHub y abre un pull request con la rama. Comprueba que se pasan los tests en Travis y que se marca como correcto el pull request . Si hay alg\u00fan fallo, realiza los cambios necesarios para corregirlos y vuelve a subir el commit. Mezcla el pull request con master . Se volver\u00e1n a lanzar los tests en Travis y se subir\u00e1 la m\u00e1quina docker resultante a Docker Hub. Crea en la wiki una p\u00e1gina llamada Integraci\u00f3n continua y documenta en ella lo que has hecho en esta parte de la pr\u00e1ctica. Como m\u00ednimo: Captura de pantalla de los tests de integraci\u00f3n con sbt . Enlace a Docker Hub. TDD En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 a\u00f1adirme y eliminarme de cualquier equipo para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos : Como administrador podr\u00e9 crear, cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta. 008 Listado de equipos La descripci\u00f3n de la historia de usuario es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el nombre del equipo aparecer\u00e1 un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de abajo a arriba . Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional. Pasos a seguir en la pr\u00e1ctica Crea la historia de usuario en el tablero Trello. Crea los issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo. Primer test - Entidiad Equipo El primer test es para crear la entidad Equipo . Por ahora s\u00f3lo creamos la clase Java, sin las anotaciones JPA. Un equipo Fichero `src/test/java/madstodolist/EquipoTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package madstodolist ; import madstodolist.model.Equipo ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class EquipoTest { @Test public void crearEquipo () { Equipo equipo = new Equipo ( Proyecto Cobalto ); assertThat ( equipo . getNombre ()). isEqualTo ( Proyecto Cobalto ); } } Escribe el c\u00f3digo necesario para que pase el test. No debes escribir c\u00f3digo de m\u00e1s, s\u00f3lo el c\u00f3digo m\u00ednimo para que el test pase . Haz un commit que contenga el test y el c\u00f3digo y s\u00fabelo a la rama remota. Segundo test - Entidad en base de datos Con el segundo test queremos conseguir que funcione JPA con la entidad Equipo y que podamos usar una tabla de equipos en la base de datos, en la que podamos guardar entidades equipo . Para comprobar que la entidad se ha guardado correctamente, comprobaremos se ha actualizando su identificador. Lo hacemos a\u00f1adiendo el siguiente test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private EquipoRepository equipoRepository ; @Test @Transactional public void grabarEquipo () { // GIVEN Equipo equipo = new Equipo ( Proyecto Cobalto ); // WHEN equipoRepository . save ( equipo ); // THEN assertThat ( equipo . getId ()). isNotNull (); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Tercer test - Definici\u00f3n de igualdad entre equipos Ahora que hemos introducido el id del equipo escribimos un test para comprobar que dos equipos son iguales. Debes escribir el c\u00f3digo de los m\u00e9todos equals y hashCode (necesario este \u00faltimo para que funcione correctamente la comprobaci\u00f3n de igualdades en las colecciones). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Test public void comprobarIgualdadEquipos () { // GIVEN // Creamos tres equipos sin id, s\u00f3lo con el nombre Equipo equipo1 = new Equipo ( Proyecto Cobalto ); Equipo equipo2 = new Equipo ( Proyecto N\u00edquel ); Equipo equipo3 = new Equipo ( Proyecto N\u00edquel ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isNotEqualTo ( equipo2 ); assertThat ( equipo2 ). isEqualTo ( equipo3 ); // WHEN // A\u00f1adimos identificadores y comprobamos igualdad por identificadores equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isEqualTo ( equipo2 ); assertThat ( equipo2 ). isNotEqualTo ( equipo3 ); } Escribe el c\u00f3digo necesario para se pase el test y haz un commit. Cuarto test - Buscar equipo en base de datos Escribimos ahora un test para recuperar equipos por su identificador de la base de datos. A\u00f1adimos un equipo a la tabla en el fichero datos-test.sql para poder comprobar que funciona correctamente. A\u00f1adimos en el fichero src/test/java/resources/datos-test.sql : 1 INSERT INTO equipos (id, nombre) VALUES( 1 , Proyecto Cobalto ); Test: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void comprobarRecuperarEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo ). isNotNull (); assertThat ( equipo . getId ()). isEqualTo ( 1L ); assertThat ( equipo . getNombre ()). isEqualTo ( Proyecto Cobalto ); } Comprueba el test y si es necesario escribe el c\u00f3digo estr\u00edctamente necesario para que pase. Haz un commit en la rama y s\u00fabelo a GitHub. Quinto test - Relaci\u00f3n en memoria muchos-a-muchos entre equipos y usuarios Vamos ahora a dise\u00f1ar un test que introduzca la relaci\u00f3n entre equipos y usuarios. Debe ser una relaci\u00f3n muchos-a-muchos: un equipo contiene muchos usuarios y un usuario puede pertenecer a 0, 1 o muchos equipos. Empezamos por un test para crear la relaci\u00f3n en memoria, con las anotaciones m\u00ednimas para que JPA no se queje: 1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void relaci\u00f3nMuchosAMuchosVacia () { // GIVEN Equipo equipo = new Equipo ( Proyecto Cobalto ); Usuario usuario = new Usuario ( prueba@gmail.com ); // WHEN // THEN assertThat ( equipo . getUsuarios ()). isEmpty (); assertThat ( usuario . getEquipos ()). isEmpty (); } Para que este test funcione hay que crear la relaci\u00f3n muchos-a-muchos entre equipos y usuarios. Por s\u00f3lo la definimos en memoria, sin especificar c\u00f3mo se mapea en la base de datos: Fichero src/main/java/madstodolist/model/Equipo.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 private String nombre; + @ManyToMany + Set Usuario usuarios = new HashSet (); ... public void setId(Long id) { this.id = id; } + public Set Usuario getUsuarios() { + return usuarios; + } Fichero src/main/java/madstodolist/model/Usuario.java : 1 2 3 4 5 6 7 8 9 10 11 @OneToMany(mappedBy = usuario , fetch = FetchType.EAGER) Set Tarea tareas = new HashSet (); + @ManyToMany + Set Equipo equipos = new HashSet (); ... + public Set Equipo getEquipos() { + return equipos; + } Sexto test - Relaci\u00f3n entre usuarios y equipos en base de datos 1 2 3 INSERT INTO tareas (id, titulo, usuario_id) VALUES( 2 , Renovar DNI , 1 ); + INSERT INTO equipos (id, nombre) VALUES( 1 , Proyecto Cobalto ); + INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES( 1 , 1 ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Autowired private UsuarioRepository usuarioRepository ; @Test public void comprobarRelacionBaseDatos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoRepository . findById ( 1L ). orElse ( null ); Usuario usuario = usuarioRepository . findById ( 1L ). orElse ( null ); // THEN assertThat ( equipo . getUsuarios ()). hasSize ( 1 ); assertThat ( equipo . getUsuarios ()). contains ( usuario ); assertThat ( usuario . getEquipos ()). hasSize ( 1 ); assertThat ( usuario . getEquipos ()). contains ( equipo ); } Soluci\u00f3n: 1 2 3 4 5 @ManyToMany + @JoinTable(name = equipo_usuario , + joinColumns = { @JoinColumn(name = fk_equipo ) }, + inverseJoinColumns = {@JoinColumn(name = fk_usuario )}) Set Usuario usuarios = new HashSet (); 1 2 3 - @ManyToMany + @ManyToMany(mappedBy = usuarios ) Set Equipo equipos = new HashSet (); S\u00e9ptimo test - listado de equipos 1 2 INSERT INTO equipo_usuario (fk_equipo, fk_usuario) VALUES( 1 , 1 ); + INSERT INTO equipos (id, nombre) VALUES( 2 , Proyecto Adamantium ); 1 2 3 4 5 6 7 8 9 10 11 12 @Test @Transactional public void comprobarFindAll () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List Equipo equipos = equipoRepository . findAll (); // THEN assertThat ( equipos ). hasSize ( 2 ); } Soluci\u00f3n: Fichero EquipoRepository.java : 1 2 3 4 5 + import java.util.List; public interface EquipoRepository extends CrudRepository Equipo, Long { + public List Equipo findAll(); } Octavo test - M\u00e9todo de servicio para el listado de equipos Fichero src/test/java/madstodolist/EquipoServiceTest.java : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package madstodolist ; import madstodolist.model.Equipo ; import madstodolist.service.EquipoService ; import org.junit.Test ; import org.junit.runner.RunWith ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.junit4.SpringRunner ; import java.util.List ; import static org.assertj.core.api.Assertions.assertThat ; @RunWith ( SpringRunner . class ) @SpringBootTest public class EquipoServiceTest { @Autowired EquipoService equipoService ; @Test public void obtenerListadoEquipos () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List Equipo equipos = equipoService . findAllOrderedByName (); // THEN assertThat ( equipos ). hasSize ( 2 ); assertThat ( equipos . get ( 0 ). getNombre ()). isEqualTo ( Proyecto Adamantium ); assertThat ( equipos . get ( 1 ). getNombre ()). isEqualTo ( Proyecto Cobalto ); } } Noveno test - M\u00e9todo de servicio para recuperar un equipo En el fichero src/test/java/madstodolist/EquipoServiceTest.java a\u00f1adimos el siguiente test. El test sirve para crear el m\u00e9todo de servicio que recupera un equipo y para asegurarnos de que la relaci\u00f3n entre equipos y usuarios es LAZY . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void obtenerEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN Equipo equipo = equipoService . findById ( 1L ); // THEN assertThat ( equipo . getNombre ()). isEqualTo ( Proyecto Cobalto ); // Comprobamos que la relaci\u00f3n con Usuarios es lazy: al // intentar acceder a la colecci\u00f3n de usuarios se debe lanzar una // excepci\u00f3n de tipo LazyInitializationException. assertThatThrownBy (() - { equipo . getUsuarios (). size (); }). isInstanceOf ( LazyInitializationException . class ); } D\u00e9cimo test - M\u00e9todo de servicio para obtener los usuarios de un equipo Un test algo complejo, que sirve para definir el m\u00e9todo de servicio usuariosEquipo(Long idEquipo) que devuelve la lista de usuarios de un equipo. Despu\u00e9s de comprobar que la lista que se devuelve es correcta, se comprueba que la relaci\u00f3n entre usuarios y equipos es EAGER , esto es, que desde un usuario se puede obtener la lista de equipos a los que pertenece. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void obtenerUsuariosEquipo () { // GIVEN // En el application.properties se cargan los datos de prueba del fichero datos-test.sql // WHEN List Usuario usuarios = equipoService . usuariosEquipo ( 1L ); // THEN assertThat ( usuarios ). hasSize ( 1 ); assertThat ( usuarios . get ( 0 ). getEmail ()). isEqualTo ( ana.garcia@gmail.com ); // Comprobamos que la relaci\u00f3n entre usuarios y equipos es eager // Primero comprobamos que la colecci\u00f3n de equipos tiene 1 elemento assertThat ( usuarios . get ( 0 ). getEquipos ()). hasSize ( 1 ); // Y despu\u00e9s que el elemento es el equipo Proyecto Cobalto assertThat ( usuarios . get ( 0 ). getEquipos (). stream (). findFirst (). get (). getNombre ()). isEqualTo ( Proyecto Cobalto ); } } Pasos a seguir en la pr\u00e1ctica Crea una feature nueva en la wiki, un nuevo issue para resolverla (con el milestone 1.2.0) y una nueva rama en la que desarrollar\u00e1s el issue . Completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Continua usando TDD y haciendo commits test-code y refactor para terminar de implementar la feature , escribiendo los tests necesarios para terminar de implementar la capa de repositorio y la capa de servicio con los m\u00e9todos necesarios para implementar la nueva funcionalidad. Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Termina de implementar la historia de usuario modificando las vistas y los controllers necesarios. Crea un pull request y mezcla en master la nueva funcionalidad. Se subir\u00e1 a Docker Hub la nueva versi\u00f3n de la m\u00e1quina docker. Realiza el nuevo release con el n\u00famero 1.2.0 , genera a mano la m\u00e1quina docker con esa versi\u00f3n y s\u00fabela a Docker Hub. Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 30 de octubre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 8% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean en sbt para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub y la URL de la m\u00e1quina en Docker Hub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Integration tdd bak"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#practica-2-integracion-con-travis-y-tdd","text":"En esta pr\u00e1ctica 2 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua conectando el repositorio de GitHub con Travis. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request sobre la base de datos MySQL. A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Important Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir en la pr\u00e1ctica . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 2 semanas y la fecha l\u00edmita de entrega es el d\u00eda 30 de octubre.","title":"Pr\u00e1ctica 2: Integraci\u00f3n con Travis y TDD"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#refactorizacion-de-la-relacion-uno-a-muchos","text":"Antes de comenzar la pr\u00e1ctica hay que hacer una refactorizaci\u00f3n en la relaci\u00f3n una-a-muchos entre usuario y tareas: pasar la lista de tareas de un usuario de List a Set . A diferencias del tipo List , el Set no permite elementos repetidos y es m\u00e1s conveniente definir las relaciones JPA de esta forma.","title":"Refactorizaci\u00f3n de la relaci\u00f3n uno-a-muchos"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#pasos-a-seguir-en-la-practica","text":"Realiza un commit en master (no hace falta que hagas un pull request) con los cambios que aparecen este commit . Lanza los tests para comprobar que todo funciona correctamente y sube el commit a GitHub.","title":"Pasos a seguir en la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#configuracion-de-la-aplicacion","text":"Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos MySQL de producci\u00f3n. En esta pr\u00e1ctica vamos a configurar un perfil de la aplicaci\u00f3n para poder lanzar los tests y ejecutar la aplicaci\u00f3n usando una base de datos MySQL. En la pr\u00e1ctica 3 veremos c\u00f3mo definir un perfil para trabajar con una base de datos de producci\u00f3n. Note La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos en la pr\u00e1ctica 3 que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir un flujo de trabajo para implementar en el esquema de datos de la base de datos un cambio en el modelo de datos de la aplicaci\u00f3n. Vamos a ver en este apartado c\u00f3mo definir distintas configuraciones de ejecuci\u00f3n de la aplicaci\u00f3n, utilizando los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos MySQL. La configuraci\u00f3n de tests con base de datos MySQL la utilizaremos para ejecutar los tests de integraci\u00f3n en el proceso de integraci\u00f3n continua de Travis.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#ficheros-de-configuracion-de-la-aplicacion","text":"Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir las propiedades definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.profile donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-mysql.profile (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con MySQL.","title":"Ficheros de configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#pasos-a-seguir-en-la-practica_1","text":"Instala Docker Desktop . Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Lo vamos a utilizar para lanzar el servidor MySQL de base de datos y tambi\u00e9n para la futura pr\u00e1ctica 3. Si tienes Windows, Docker no es compatible con VirtualBox. Si quieres usar ambos programas puedes usar una versi\u00f3n limitada de Docker llamada Docker Toolbox Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con MySQL . Crea una rama nueva y haz los siguientes cambios en ella. Copia el siguiente fichero en src/main/resources/application-mysql.properties : 1 2 3 4 5 6 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect spring.jpa.hibernate.ddl-auto=update spring.datasource.initialization-mode=never En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos MySQL, su usuario ( root ) y contrase\u00f1a (vac\u00eda) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.MySQL5Dialect ). Adem\u00e1s se indica que no se debe cargar ning\u00fan fichero de datos inicial. El esquema de la base de datos se actualizar\u00e1 si hay cambios en las entidades de la aplicaci\u00f3n, y los datos se mantendr\u00e1n en la base de datos. Copia el siguiente fichero en src/test/resources/application-mysql.properties : 1 2 3 4 5 spring.datasource.url=jdbc:mysql://localhost:3306/mads spring.datasource.username=root spring.datasource.password= spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect spring.jpa.hibernate.ddl-auto=create La diferencia m\u00e1s importante es el valor de spring.jpa.hibernate.ddl-auto , que es create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver mysql-connector-java y poder utilizar una base de datos MySQL en la aplicaci\u00f3n: Fichero pom.xml : 1 2 3 4 5 6 7 8 9 artifactId h2 /artifactId scope runtime /scope /dependency + dependency + groupId mysql /groupId + artifactId mysql-connector-java /artifactId + /dependency dependency groupId org.springframework.boot /groupId Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor MySQL en el puerto 3306 con el usuario root sin contrase\u00f1a. Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: 1 $ docker run -d -p 3306 :3306 -e MYSQL_ALLOW_EMPTY_PASSWORD = yes -e MYSQL_DATABASE = mads mysql:5 Docker se descarga la imagen mysql:5 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 3306 y sobre la base de datos mads . Puedes ejecutar los siguientes comandos de docker: 1 2 3 4 5 ``` $ docker container ls -a (comprueba todos los contenedores en marcha) $ docker container stop lt;nombre o id de contenedor gt; (para un contenedor) $ docker container rm lt;nombre o id de contenedor gt; (elimina un contenedor) ``` Arranca la aplicaci\u00f3n con el siguiente comando: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ mvn spring-boot:run -Dspring-boot.run.profiles = mysql ``` Se cargar\u00e1n las preferencias de ` src/main/resource/application.profile ` y ` src/main/resource/application-mysql.profile ` . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos con ` MySQL Workbench ` o alguna aplicaci\u00f3n similar. img src = images/mysql-workbench.png width = 600px / La propiedad Java ` config.file ` permite definir un fichero de configuraci\u00f3n distinto del de por defecto. Se puede configurar en las ` javaOptions ` de ` sbt ` : ``` text [ mads-todolist-dgallardo ] $ set javaOptions += -Dconf.file=conf/ FICHERO-CONF .conf Vamos a utilizar dos ficheros de configuraci\u00f3n distintos: Fichero conf/develop-mysql.conf : para lanzar las pruebas de integraci\u00f3n. Fichero conf/production.conf : para ejecutar la aplicaci\u00f3n en producci\u00f3n. Fichero conf/develop-mysql.conf : 1 2 3 4 5 6 include application.conf db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Fichero conf/production.conf : 1 2 3 4 5 6 7 8 9 10 include application.conf play.crypto.secret= abcdefghijkl jpa.default = production db.default.driver=com.mysql.jdbc.Driver db.default.url=${?DB_URL} db.default.username=${?DB_USER_NAME} db.default.password=${?DB_USER_PASSWD} Ambos ficheros incluyen el fichero application.conf en el que se definen las siguientes propiedades relacionadas con la base de datos: Fichero `conf/application.conf : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Default persistenceUnit for JPA jpa.default = develop db { # You can declare as many datasources as you want. # By convention, the default datasource is named `default` # https://www.playframework.com/documentation/latest/Developing-with-the-H2-Database # Memory H2 database default.driver = org.h2.Driver default.url = jdbc:h2:mem:play;MODE=MYSQL #default.username = sa #default.password = # Definimos el nombre JNDI de la BD que va a usar la aplicaci\u00f3n default.jndiName=DBTodoList # You can turn on SQL logging for any datasource # https://www.playframework.com/documentation/latest/Highlights25#Logging-SQL-statements # default.logSql=true }","title":"Pasos a seguir en la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#fichero-de-configuracion-de-jpa","text":"Vemos en los ficheros anteriores que la diferencia fundamental es el valor de la propiedad jpa.default . En esta propiedad se define el nombre de la unidad de persistencia que se va a usar en JPA. Las unidades de persistencia est\u00e1n definidas en el fichero conf/META-INF/persistence.xml . Fichero `conf/META-INF/persistence.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 !-- MySQL Persistence Unit - Develop: hbm2ddl.auto = UPDATE -- persistence-unit name= develop transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class class models.Admin /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= update / /properties /persistence-unit !-- MySQL Persistence Unit - Production: hbm2ddl.auto = VALIDATE -- persistence-unit name= production transaction-type= RESOURCE_LOCAL provider org.hibernate.jpa.HibernatePersistenceProvider /provider non-jta-data-source DBTodoList /non-jta-data-source class models.Usuario /class class models.Tarea /class class models.Equipo /class class models.Admin /class properties property name= hibernate.dialect value= org.hibernate.dialect.MySQL5Dialect / property name= hibernate.hbm2ddl.auto value= validate / /properties /persistence-unit La diferencia fundamental entre ambas unidades de persistencia es el valor de la propiedad hibernate.hbm2ddl.auto , que define c\u00f3mo gestiona JPA el mapeo entre las entidades Java y las tablas f\u00edsicas de la base de datos. En la unidad de persistencia develop hemos usado el valor update . Esto significa que JPA actualizar\u00e1 la base de datos, modificando su esquema, para hacerlo corresponder con las entidades definidas en la aplicaci\u00f3n. Si en alguna entidad a\u00f1adimos alg\u00fan atributo, el esquema de la base de datos se actualizar\u00e1, a\u00f1adiendo un campo en la tabla correspondiente. En la unidad de persistencia production hemos usado el valor validate . En este caso JPA comprobar\u00e1 si el esquema de la base de datos se corresponde con las entidades de la aplicaci\u00f3n. Si no es as\u00ed, se lanzar\u00e1 una excepci\u00f3n y JPA dejar\u00e1 de funcionar. El primer valor es muy \u00fatil para el realizar el desarrollo y los tests de integraci\u00f3n de la aplicaci\u00f3n. Pero no se debe usar en producci\u00f3n porque no queremos que la base de datos de producci\u00f3n (donde est\u00e1n todos los datos introducidos por los usuarios finales) se modifique tan f\u00e1cilmente. Cualquier modificaci\u00f3n de la base de datos de producci\u00f3n debe realizarse mediante un proceso que garantice la posibilidad de la vuelta atr\u00e1s y la recuperaci\u00f3n de posibles errores que se puedan cometer.","title":"Fichero de configuraci\u00f3n de JPA"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#variables-de-entorno","text":"En ambos ficheros se usan variables de entorno para definir los valores de la URL de la conexi\u00f3n a la base de datos y el usuario y contrase\u00f1a de esa conexi\u00f3n. Los valores de esas variables se pueden definir de dos formas para que sean visibles dentro de sbt : En el shell en el que se lanza el comando sbt 1 2 3 4 $ export DB_URL = jdbc:mysql://localhost:3316/mads $ export DB_USER_NAME = root $ export DB_USER_PASSWD = mads $ sbt ; set javaOptions += \\ -Dconfig.file=conf/develop-mysql.conf\\ ; test En la \u00faltima l\u00ednea vemos c\u00f3mo es posible lanzar sbt junto con unos comandos que se lanzar\u00e1n dentro del propio sbt . Desde dentro del propio sbt con set javaOptions : 1 2 3 4 5 [mads-todolist-dgallardo] $ set javaOptions += -Dconfig.file=conf/develop-mysql.conf [mads-todolist-dgallardo] $ set javaOptions += -DDB_URL=jdbc:mysql://localhost:3316/mads [mads-todolist-dgallardo] $ set javaOptions += -DDB_USER_NAME=root [mads-todolist-dgallardo] $ set javaOptions += -DDB_USER_PASSWD=mads [mads-todolist-dgallardo] $ test","title":"Variables de entorno"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#pasos-a-seguir-en-la-practica_2","text":"Ejecuta los tests de la pr\u00e1ctica usando el fichero de configuraci\u00f3n develop-mysql.conf para que los realice usando la base de datos MySQL (que deber\u00e1s tener activa). Captura la pantalla en la que aparezca el resultado de los tests y el nombre de la base de datos MySQL . Por ejemplo, si ejecutas sbt desde IntelliJ, la pantalla resultante deber\u00e1 ser como la siguiente:","title":"Pasos a seguir en la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#construccion-y-publicacion-de-la-imagen-docker","text":"Para facilitar la ejecuci\u00f3n de la aplicaci\u00f3n en diferentes entornos, vamos a generar y publicar una imagen docker de la misma.","title":"Construcci\u00f3n y publicaci\u00f3n de la imagen docker"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#alta-en-docker-hub","text":"Crea una cuenta en docker hub . La utilizar\u00e1s para subir all\u00ed, utilizando tu Docker ID , la image docker de tu pr\u00e1ctica.","title":"Alta en Docker Hub"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#construccion-de-la-imagen-docker","text":"Empezamos construyendo la imagen docker en local y comprobando que funciona correctamente.","title":"Construcci\u00f3n de la imagen docker"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#pasos-a-seguir-en-la-practica_3","text":"Crea un nuevo issue llamado Integraci\u00f3n continua con Travis , crea una nueva rama integracion-continua y s\u00fabela a GitHub. Realiza un commit con el fichero Dockerfile a\u00f1adido. Construye la m\u00e1quina docker con tu pr\u00e1ctica, prueba que funciona bien la ejecuci\u00f3n en memoria y el lanzamiento de los tests contra la base de datos MySQL (tests de integraci\u00f3n) y s\u00fabela a Docker Hub, con la versi\u00f3n 1.1.0 y la versi\u00f3n latest . Comparte en el foro de la asignatura el nombre de tu m\u00e1quina y el enlace a tu p\u00e1gina de Docker Hub.","title":"Pasos a seguir en la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#integracion-continua-con-travis","text":"Travis-ci.com es un servicio que permite realizar integraci\u00f3n continua on-line, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Es un servicio de pago, pero es gratuito para los repositorios abiertos ( open source ) y para las cuentas educativas de GitHub. La organizaci\u00f3n de GitHub mads-ua-18 tambi\u00e9n est\u00e1 autorizada como organizaci\u00f3n educativa, por lo que todos los repositorios creados dentro de esa organizaci\u00f3n podr\u00e1n trabajar con Travis. Puedes consultar el funcionamiento de Travis leyendo su documentaci\u00f3n, comenzando por la p\u00e1gina Getting started . En la pr\u00e1ctica vamos a configurar Travis para que todos los pull requests deban pasar los tests de integraci\u00f3n (conect\u00e1ndose a la base de datos MySQL) y para que cuando se realice el merge con master se suba una nueva versi\u00f3n de la m\u00e1quina docker con la aplicaci\u00f3n a Docker Hub.","title":"Integraci\u00f3n continua con Travis"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#conexion-con-github","text":"En GitHub est\u00e1 configurada la conexi\u00f3n con Travis para todos los proyectos en la organizaci\u00f3n mads-u-18 . En tu cuenta de Travis, una vez logeado, podr\u00e1s sincronizar tu repositorio y configurar la conexi\u00f3n. Ver\u00e1s una pantalla como la siguiente:","title":"Conexi\u00f3n con GitHub"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#tests-en-los-pull-requests","text":"Usando Travis es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Travis. Una vez abierto el PR, Travis comprueba si la integraci\u00f3n de master con la rama pasa los tests definidos en el fichero de configuraci\u00f3n. S\u00f3lo si los tests pasan es posible realizar el merge del PR en master.","title":"Tests en los pull requests"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#el-fichero-de-configuracion","text":"La configuraci\u00f3n de Travis se realiza con el fichero .travis.yml en la ra\u00edz del repositorio. El fichero .travis.yml para mi repositorio soluci\u00f3n de la pr\u00e1ctica es el siguiente: Fichero .travis.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 sudo: required language: bash branches: only: - master services: - docker before_script: - docker build -t domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER . script: - docker run -d --rm -p 3306:3306 --name db-mysql -e MYSQL_ROOT_PASSWORD=mads -e MYSQL_DATABASE=mads mysql:5 - docker run --link db-mysql --rm -e DB_URL= jdbc:mysql://db-mysql:3306/mads -e DB_USER_NAME= root -e DB_USER_PASSWD= mads domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER /bin/bash -c sbt ; set javaOptions += \\ -Dconfig.file=conf/develop-mysql.conf\\ ; test after_success: - if [ $TRAVIS_EVENT_TYPE != pull_request ]; then docker login -u= $DOCKER_USERNAME -p= $DOCKER_PASSWORD ; docker push domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER; docker tag domingogallardo/mads-todolist:$TRAVIS_BUILD_NUMBER domingogallardo/mads-todolist:latest; docker push domingogallardo/mads-todolist:latest; fi Puntos interesantes a destacar: Se puede espeficar la rama en la que se activa la integraci\u00f3n continua en el apartado branches . En nuestro caso es la rama master . En cualquier commit o pull request que se haga sobre esa rama se lanzar\u00e1 la integraci\u00f3n continua. El apartado services define los servicios necesarios para que se ejecute el script de integraci\u00f3n. En nuestro caso docker . En el apartado before_script se definen los comandos a realizar antes de ejecutar el script con los tests. En nuestro caso construimos la imagen docker. En el apartado script se definen los comandos a realizar para lanzar los tests. En nuestro caso ponemos en marcha el servicio docker de MySQL y lanzamos la m\u00e1quina docker de la aplicaci\u00f3n para que ejecute los tests usando la conexi\u00f3n con ese servicio. Por \u00faltimo, el apartado after_success se ejecuta si los tests han pasado correctamente. En nuestro caso definimos la condici\u00f3n adicional de que la ejecuci\u00f3n de Travis se haya lanzado no por un pull request abierto sino porque se ha hecho un merge del pull request en master. En ese caso se sube a Docker Hub la \u00faltima imagen creada, con el n\u00famero de versi\u00f3n definido por el n\u00famero de build de Travis y tambi\u00e9n con la etiqueta latest .","title":"El fichero de configuraci\u00f3n"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#builds-en-travis","text":"En Travis tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla una vez ha terminado el build o mientras se est\u00e1 ejecutando. Nota S\u00f3lo es posible ejecutar un build simult\u00e1neo en la organizaci\u00f3n mads-ua-18 . Cuando hay otro build ejecut\u00e1ndose los nuevos builds que se lancen quedar\u00e1n encolados por fecha de inicio.","title":"Builds en Travis"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#versiones-en-docker-hub","text":"En Docker Hub tendremos el hist\u00f3rico de versiones generadas en la integraci\u00f3n continua. Y la \u00faltima estar\u00e1 etiquetada con latest .","title":"Versiones en Docker Hub"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#pasos-a-seguir-en-la-practica_4","text":"Date de alta en Travis-ci.com y con\u00e9ctalo al repositorio de la pr\u00e1ctica. Adapta el fichero .travis.yml a tu pr\u00e1ctica y a\u00f1\u00e1delo con un commit a la rama integracion-continua . Sube el commit a GitHub y abre un pull request con la rama. Comprueba que se pasan los tests en Travis y que se marca como correcto el pull request . Si hay alg\u00fan fallo, realiza los cambios necesarios para corregirlos y vuelve a subir el commit. Mezcla el pull request con master . Se volver\u00e1n a lanzar los tests en Travis y se subir\u00e1 la m\u00e1quina docker resultante a Docker Hub. Crea en la wiki una p\u00e1gina llamada Integraci\u00f3n continua y documenta en ella lo que has hecho en esta parte de la pr\u00e1ctica. Como m\u00ednimo: Captura de pantalla de los tests de integraci\u00f3n con sbt . Enlace a Docker Hub.","title":"Pasos a seguir en la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#tdd","text":"En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 a\u00f1adirme y eliminarme de cualquier equipo para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos : Como administrador podr\u00e9 crear, cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta.","title":"TDD"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#008-listado-de-equipos","text":"La descripci\u00f3n de la historia de usuario es la siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el nombre del equipo aparecer\u00e1 un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de abajo a arriba . Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional.","title":"008 Listado de equipos"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#pasos-a-seguir-en-la-practica_5","text":"Crea una feature nueva en la wiki, un nuevo issue para resolverla (con el milestone 1.2.0) y una nueva rama en la que desarrollar\u00e1s el issue . Completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Continua usando TDD y haciendo commits test-code y refactor para terminar de implementar la feature , escribiendo los tests necesarios para terminar de implementar la capa de repositorio y la capa de servicio con los m\u00e9todos necesarios para implementar la nueva funcionalidad. Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Termina de implementar la historia de usuario modificando las vistas y los controllers necesarios. Crea un pull request y mezcla en master la nueva funcionalidad. Se subir\u00e1 a Docker Hub la nueva versi\u00f3n de la m\u00e1quina docker. Realiza el nuevo release con el n\u00famero 1.2.0 , genera a mano la m\u00e1quina docker con esa versi\u00f3n y s\u00fabela a Docker Hub.","title":"Pasos a seguir en la pr\u00e1ctica"},{"location":"03-gitflow-despliegue/integration-tdd-bak.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y debe estar terminada el martes 30 de octubre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 8% en la nota final de la asignatura. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un clean en sbt para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub y la URL de la m\u00e1quina en Docker Hub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas.","title":"Entrega y evaluaci\u00f3n"},{"location":"04-iteracion-scrum/iteracion-scrum.html","text":"Pr\u00e1ctica 4: Sprint de Scrum Objetivos y resumen de la pr\u00e1ctica En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 3. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n todolist . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 3 para desarrollar sobre la rama develop : Una p\u00e1gina en la Wiki de GitHub para cada historia de usuario. La historia de usuario se puede descomponer en mas de un issue, o seguir como hasta ahora haciendo un issue por historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues y pull requests El repositorio est\u00e1 conectado a Travis que comprueba de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop y sube una imagen docker a Docker Hub cuando se realiza la integraci\u00f3n. En Docker Hub se tienen numerados todos los builds exitosos de develop , y est\u00e1 etiquetada como latest la \u00faltima versi\u00f3n de la imagen. Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que la pr\u00e1ctica anterior. Adem\u00e1s, aplicaremos algunos elementos de Scrum y pr\u00e1cticas de XP: Planificaci\u00f3n del sprint Reuniones de scrum diario Revisi\u00f3n del sprint (se har\u00e1 el \u00faltimo d\u00eda de clases de la asignatura) Retrospectiva del sprint Al menos dos sesiones de pair programming en las que participen todos los miembros del equipo. Planificaci\u00f3n del sprint En la reuni\u00f3n de planificaci\u00f3n del sprint se seleccionar\u00e1n las historias de usuario a realizar en el sprint y se completar\u00e1n sus condiciones de satisfacci\u00f3n. Artefactos del sprint El equipo utilizar\u00e1 un tablero Trello, la wiki y el tablero de GitHub para documentar el backlog del producto y el backlog del sprint. Tablero Trello Cada equipo crear\u00e1 un tablero Trello compartido en el que se anotar\u00e1n en forma de tarjeta las historias de usuario candidatas para realizar en el sprint. El tablero Trello servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Wiki La wiki del proyecto deber\u00e1 contener los detalles de las historias de usuario escogidas para realizar en el sprint. Como hasta ahora, se definir\u00e1 una p\u00e1gina de la wiki para cada historia de usuario. En la p\u00e1gina se escribir\u00e1 el t\u00edtulo de la historia, su descripci\u00f3n y sus condiciones de satisfacci\u00f3n. Tambi\u00e9n se deber\u00e1 incluir en cada historia de usuario un borrador del aspecto de la interfaz de usuario resultante ( c\u00f3mo a\u00f1adir im\u00e1genes a la wiki en GitHub ). Debe ser un borrador hecho a mano y fotografiado o escaneado. Tambi\u00e9n se actualizar\u00e1 la p\u00e1gina home y el \u00edndice lateral para incluir las nuevas historias de usuario. Tablero La primera columna del tablero ser\u00e1 el backlog del sprint en el que se a\u00f1adir\u00e1n los issues correspondientes a historias de usuario y bugs. Podr\u00eda darse el caso en el que una historia de usuario se divida en m\u00e1s de un issue. En ese caso indicaremos en el t\u00edtulo del issue y en su descripci\u00f3n a qu\u00e9 historia de usuario se corresponde. El resto de columnas las utilizaremos como un tablero Kanban. Como hasta ahora, los issues/ pull requests se ir\u00e1n moviendo por ellas seg\u00fan se vayan desarrollando. Tendremos las siguientes columnas: Sprint backlog : Issues que implementan las historias de usuario (o subtareas de las mismas) y los bugs a terminar en el sprint. In progress : Historias de usuario y bugs que se est\u00e1n desarrollando. Para pasar un issue que corresponde a una historia de usuario a esta columna, debe estar terminada su p\u00e1gina en la wiki y debe tener un responsable. In pull request : issues que tienen un pull request abierto (se archivar\u00e1 la tarjeta del issue y se dejar\u00e1 s\u00f3lo la tarjeta del pull request). QA : Historias de usuario a las que se les est\u00e1 realizando pruebas funcionales y de rendimiento. Cuando todos los pull requests (correspondientes a issues y bugs) de una historia de usuario se han integrado, se anota en la p\u00e1gina de la wiki el enlace al build en DockerHub y se prueba la imagen en un entorno de stage, realiz\u00e1ndose pruebas funcionales y de rendimiento relacionadas con esa historia de usuario. Si se detectan nuevos bugs, se abren nuevos issues en GitHub para resolverlos, y la historia queda detenida en QA. Done : pull requests que se han probado satisfactoriamente. Selecci\u00f3n del backlog Al comienzo de la pr\u00e1ctica el equipo seleccionar\u00e1 las posibles historias de usuario a realizar en la iteraci\u00f3n y estimar\u00e1 su tama\u00f1o. Las anotar\u00e1n en un tablero Trello compartido con el equipo y con el profesor. El profesor validar\u00e1 la selecci\u00f3n y la estimaci\u00f3n de tama\u00f1os. Podr\u00e1n escogerse cualquiera de las historias definidas en el taller de mapping de historias de usuario realizado en clase, o idear alguna nueva. El resultado del taller de mapping de historias de usuario est\u00e1 recogido en los siguientes tableros: https://trello.com/b/KbUefDdN/mapa-1-todolist https://trello.com/b/OyMQTu3W/mapa-2-todolist https://trello.com/b/MdxWoXPZ/mapa-3-todolist https://trello.com/b/ZnK1Kq5R/mapa-4-todolist https://trello.com/b/kHml8CjF/mapa-5-todolist Todos los miembros deber\u00e1n tomar el papel product owner y aportar ideas y sugerencias para definir las historias de usuario. En el tablero Trello se definir\u00e1 una \u00fanica columna Backlog en la que se incluir\u00e1n las historias. Cada historia se analizar\u00e1, especificando claramente su descripci\u00f3n y su alcance. Para la descripci\u00f3n se recomienda usar el formato que vimos en clase: Como ROL quiero ACCI\u00d3N para RESULTADO u OBJETIVO . Tambi\u00e9n se enumerar\u00e1n brevemente una serie de condiciones de satisfacci\u00f3n (COS) que deben cumplirse para dar la historia como terminada. Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia. Al incluir la historia se realizar\u00e1 un planning pocker para volver a consensuar su tama\u00f1o (considerad el tama\u00f1o previo de la historia como una indicaci\u00f3n, pero pod\u00e9is modificarlo). El tama\u00f1o ser\u00e1 un n\u00famero del 1 al 4. Se deben incluir en el sprint historias por un tama\u00f1o total 4 puntos x n\u00famero de personas del equipo: Equipo de 3 personas: 12 puntos Equipo de 4 personas: 16 puntos El profesor no participar\u00e1 en el planning pocker , pero podr\u00e1 pedir aclaraciones sobre el tama\u00f1o de las historias. En la tarjeta de Trello se escribir\u00e1 el t\u00edtulo, el tama\u00f1o (etiqueta) y la descripci\u00f3n de la historia. Responsables de historia de usuario Una vez seleccionadas todas las historias los miembros del equipo elegir\u00e1n responsables para cada historia, se crear\u00e1 el issue (o issues) correspondiente a la historia de usuario y se a\u00f1adir\u00e1 el responsable al issue. El responsable de la historia crear\u00e1 su p\u00e1gina en la wiki de GitHub, detallar\u00e1 all\u00ed las condiciones de satisfacci\u00f3n y a\u00f1adir\u00e1 el borrador de la interfaz de usuario. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. Desarrollo del sprint Se deber\u00e1n realizar los siguientes eventos definidos por Scrum y XP, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: Scrum diario (al menos simular 2 reuniones: la segunda y tercera semana). En nuestro \"tiempo simulado\" en las pr\u00e1cticas, una semana es como un d\u00eda de trabajo completo en una empresa. Retrospectiva del sprint. 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Tablero Kanban Debemos modificar el tablero del proyecto para acercarlo a un tablero Kanban real. L\u00edmite de Work In Progress (WIP): Estimar un n\u00famero de l\u00edmite de WIP para las columnas In progress , In pull request y QA . No se podr\u00e1 incluir en esas columnas m\u00e1s tarjetas que las definidas en el n\u00famero l\u00edmite de WIP (las tarjetas en las columna In progress - Done se suman a las que hay en la columna In progress , y lo mismo con las columnas In pull request - Done y In pull request ). Estimar el l\u00edmite WIP para conseguir un flujo de trabajo correcto. Si se define un l\u00edmite WIP demasiado bajo habr\u00e1 personas ociosas, mientras que si se define un l\u00edmite WIP demasiado alto habr\u00e1 acumulaci\u00f3n de tareas sin terminar. A\u00f1adimos las columnas de buffer en el tablero de issues GitHub para adaptarlo mejor a Kanban: In progress - Done - Se ha terminado el desarrollo y los tests unitarios y no se puede crear el PR porque la columna de In pull request ha alcanzado su l\u00edmite WIP. In pull request - Done - Se ha aprobado el pull request, se ha realizado la integraci\u00f3n master y Travis da el OK. No se puede pasar a QA porque la columna ha alcanzado su l\u00edmite WIP. Desarrollo de los issues Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en master. Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Tambi\u00e9n se debe especificar en la wiki de la historia de usuario del issue los tests manuales que habr\u00eda que hacer (asociados a las condiciones de satisfacci\u00f3n). Seguimos usando Travis para la integraci\u00f3n continua. Publicaci\u00f3n de nueva versi\u00f3n Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama master , y subir a DockerHub la imagen resultante con la etiqueta 1.4.0 . Documentaci\u00f3n del desarrollo Documentar los dailys, para incluir un informe en el documento. Documentar las sesiones de pair programming. Documentar la evoluci\u00f3n del tablero GitHub y alguna m\u00e9trica del desarrollo (pull requests por semana, velocidad de la semana, gr\u00e1fica de burndown, etc.). Entrega y evaluaci\u00f3n La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 20 minutos en las clases de teor\u00eda y pr\u00e1ctica del 19 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint y las nuevas funcionalidades introducidas. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima imagen docker subida a Docker Hub. La fecha de entrega de la pr\u00e1ctica ser\u00e1 el domingo 23 de diciembre . En esa fecha se deber\u00e1 tener disponible: Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub (comprimida, sin el directorio target con los binarios y ejecutables). Deber\u00e1 contener: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF o Markdown con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog: historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en la Wiki). Funcionalidades implementadas (breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica). Informe sobre la metodolog\u00eda seguida (ejemplos de evoluci\u00f3n del tablero, alguna m\u00e9trica del desarrollo realizado en el sprint, etc.) Informes sobre las reuniones de Scrum (planificaci\u00f3n del sprint, scrum diario, revisi\u00f3n) y sobre las sesiones de pair programming. Resultado de la retrospectiva: qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. Versi\u00f3n 1.4.0 de la m\u00e1quina Docker en Docker Hub (es la m\u00e1quina que voy a usar para revisar la ejecuci\u00f3n de la pr\u00e1ctica). El repositorio GitHub deber\u00e1 incluir el tablero de issues/PR completados y la Wiki con las historias de usuario que se deb\u00edan implementar en el sprint.. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de la asignatura. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Pr\u00e1ctica 4: Sprint de Scrum"},{"location":"04-iteracion-scrum/iteracion-scrum.html#practica-4-sprint-de-scrum","text":"","title":"Pr\u00e1ctica 4: Sprint de Scrum"},{"location":"04-iteracion-scrum/iteracion-scrum.html#objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 3. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un incremento de la aplicaci\u00f3n todolist . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 3 para desarrollar sobre la rama develop : Una p\u00e1gina en la Wiki de GitHub para cada historia de usuario. La historia de usuario se puede descomponer en mas de un issue, o seguir como hasta ahora haciendo un issue por historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues y pull requests El repositorio est\u00e1 conectado a Travis que comprueba de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop y sube una imagen docker a Docker Hub cuando se realiza la integraci\u00f3n. En Docker Hub se tienen numerados todos los builds exitosos de develop , y est\u00e1 etiquetada como latest la \u00faltima versi\u00f3n de la imagen. Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que la pr\u00e1ctica anterior. Adem\u00e1s, aplicaremos algunos elementos de Scrum y pr\u00e1cticas de XP: Planificaci\u00f3n del sprint Reuniones de scrum diario Revisi\u00f3n del sprint (se har\u00e1 el \u00faltimo d\u00eda de clases de la asignatura) Retrospectiva del sprint Al menos dos sesiones de pair programming en las que participen todos los miembros del equipo.","title":"Objetivos y resumen de la pr\u00e1ctica"},{"location":"04-iteracion-scrum/iteracion-scrum.html#planificacion-del-sprint","text":"En la reuni\u00f3n de planificaci\u00f3n del sprint se seleccionar\u00e1n las historias de usuario a realizar en el sprint y se completar\u00e1n sus condiciones de satisfacci\u00f3n.","title":"Planificaci\u00f3n del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum.html#artefactos-del-sprint","text":"El equipo utilizar\u00e1 un tablero Trello, la wiki y el tablero de GitHub para documentar el backlog del producto y el backlog del sprint.","title":"Artefactos del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum.html#seleccion-del-backlog","text":"Al comienzo de la pr\u00e1ctica el equipo seleccionar\u00e1 las posibles historias de usuario a realizar en la iteraci\u00f3n y estimar\u00e1 su tama\u00f1o. Las anotar\u00e1n en un tablero Trello compartido con el equipo y con el profesor. El profesor validar\u00e1 la selecci\u00f3n y la estimaci\u00f3n de tama\u00f1os. Podr\u00e1n escogerse cualquiera de las historias definidas en el taller de mapping de historias de usuario realizado en clase, o idear alguna nueva. El resultado del taller de mapping de historias de usuario est\u00e1 recogido en los siguientes tableros: https://trello.com/b/KbUefDdN/mapa-1-todolist https://trello.com/b/OyMQTu3W/mapa-2-todolist https://trello.com/b/MdxWoXPZ/mapa-3-todolist https://trello.com/b/ZnK1Kq5R/mapa-4-todolist https://trello.com/b/kHml8CjF/mapa-5-todolist Todos los miembros deber\u00e1n tomar el papel product owner y aportar ideas y sugerencias para definir las historias de usuario. En el tablero Trello se definir\u00e1 una \u00fanica columna Backlog en la que se incluir\u00e1n las historias. Cada historia se analizar\u00e1, especificando claramente su descripci\u00f3n y su alcance. Para la descripci\u00f3n se recomienda usar el formato que vimos en clase: Como ROL quiero ACCI\u00d3N para RESULTADO u OBJETIVO . Tambi\u00e9n se enumerar\u00e1n brevemente una serie de condiciones de satisfacci\u00f3n (COS) que deben cumplirse para dar la historia como terminada. Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia. Al incluir la historia se realizar\u00e1 un planning pocker para volver a consensuar su tama\u00f1o (considerad el tama\u00f1o previo de la historia como una indicaci\u00f3n, pero pod\u00e9is modificarlo). El tama\u00f1o ser\u00e1 un n\u00famero del 1 al 4. Se deben incluir en el sprint historias por un tama\u00f1o total 4 puntos x n\u00famero de personas del equipo: Equipo de 3 personas: 12 puntos Equipo de 4 personas: 16 puntos El profesor no participar\u00e1 en el planning pocker , pero podr\u00e1 pedir aclaraciones sobre el tama\u00f1o de las historias. En la tarjeta de Trello se escribir\u00e1 el t\u00edtulo, el tama\u00f1o (etiqueta) y la descripci\u00f3n de la historia.","title":"Selecci\u00f3n del backlog"},{"location":"04-iteracion-scrum/iteracion-scrum.html#responsables-de-historia-de-usuario","text":"Una vez seleccionadas todas las historias los miembros del equipo elegir\u00e1n responsables para cada historia, se crear\u00e1 el issue (o issues) correspondiente a la historia de usuario y se a\u00f1adir\u00e1 el responsable al issue. El responsable de la historia crear\u00e1 su p\u00e1gina en la wiki de GitHub, detallar\u00e1 all\u00ed las condiciones de satisfacci\u00f3n y a\u00f1adir\u00e1 el borrador de la interfaz de usuario. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno.","title":"Responsables de historia de usuario"},{"location":"04-iteracion-scrum/iteracion-scrum.html#desarrollo-del-sprint","text":"Se deber\u00e1n realizar los siguientes eventos definidos por Scrum y XP, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: Scrum diario (al menos simular 2 reuniones: la segunda y tercera semana). En nuestro \"tiempo simulado\" en las pr\u00e1cticas, una semana es como un d\u00eda de trabajo completo en una empresa. Retrospectiva del sprint. 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas.","title":"Desarrollo del sprint"},{"location":"04-iteracion-scrum/iteracion-scrum.html#tablero-kanban","text":"Debemos modificar el tablero del proyecto para acercarlo a un tablero Kanban real. L\u00edmite de Work In Progress (WIP): Estimar un n\u00famero de l\u00edmite de WIP para las columnas In progress , In pull request y QA . No se podr\u00e1 incluir en esas columnas m\u00e1s tarjetas que las definidas en el n\u00famero l\u00edmite de WIP (las tarjetas en las columna In progress - Done se suman a las que hay en la columna In progress , y lo mismo con las columnas In pull request - Done y In pull request ). Estimar el l\u00edmite WIP para conseguir un flujo de trabajo correcto. Si se define un l\u00edmite WIP demasiado bajo habr\u00e1 personas ociosas, mientras que si se define un l\u00edmite WIP demasiado alto habr\u00e1 acumulaci\u00f3n de tareas sin terminar. A\u00f1adimos las columnas de buffer en el tablero de issues GitHub para adaptarlo mejor a Kanban: In progress - Done - Se ha terminado el desarrollo y los tests unitarios y no se puede crear el PR porque la columna de In pull request ha alcanzado su l\u00edmite WIP. In pull request - Done - Se ha aprobado el pull request, se ha realizado la integraci\u00f3n master y Travis da el OK. No se puede pasar a QA porque la columna ha alcanzado su l\u00edmite WIP.","title":"Tablero Kanban"},{"location":"04-iteracion-scrum/iteracion-scrum.html#desarrollo-de-los-issues","text":"Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en master. Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Tambi\u00e9n se debe especificar en la wiki de la historia de usuario del issue los tests manuales que habr\u00eda que hacer (asociados a las condiciones de satisfacci\u00f3n). Seguimos usando Travis para la integraci\u00f3n continua.","title":"Desarrollo de los issues"},{"location":"04-iteracion-scrum/iteracion-scrum.html#publicacion-de-nueva-version","text":"Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama master , y subir a DockerHub la imagen resultante con la etiqueta 1.4.0 .","title":"Publicaci\u00f3n de nueva versi\u00f3n"},{"location":"04-iteracion-scrum/iteracion-scrum.html#documentacion-del-desarrollo","text":"Documentar los dailys, para incluir un informe en el documento. Documentar las sesiones de pair programming. Documentar la evoluci\u00f3n del tablero GitHub y alguna m\u00e9trica del desarrollo (pull requests por semana, velocidad de la semana, gr\u00e1fica de burndown, etc.).","title":"Documentaci\u00f3n del desarrollo"},{"location":"04-iteracion-scrum/iteracion-scrum.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 20 minutos en las clases de teor\u00eda y pr\u00e1ctica del 19 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint y las nuevas funcionalidades introducidas. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima imagen docker subida a Docker Hub. La fecha de entrega de la pr\u00e1ctica ser\u00e1 el domingo 23 de diciembre . En esa fecha se deber\u00e1 tener disponible: Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub (comprimida, sin el directorio target con los binarios y ejecutables). Deber\u00e1 contener: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF o Markdown con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog: historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en la Wiki). Funcionalidades implementadas (breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica). Informe sobre la metodolog\u00eda seguida (ejemplos de evoluci\u00f3n del tablero, alguna m\u00e9trica del desarrollo realizado en el sprint, etc.) Informes sobre las reuniones de Scrum (planificaci\u00f3n del sprint, scrum diario, revisi\u00f3n) y sobre las sesiones de pair programming. Resultado de la retrospectiva: qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. Versi\u00f3n 1.4.0 de la m\u00e1quina Docker en Docker Hub (es la m\u00e1quina que voy a usar para revisar la ejecuci\u00f3n de la pr\u00e1ctica). El repositorio GitHub deber\u00e1 incluir el tablero de issues/PR completados y la Wiki con las historias de usuario que se deb\u00edan implementar en el sprint.. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de la asignatura. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo de los issues Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n","title":"Entrega y evaluaci\u00f3n"}]}